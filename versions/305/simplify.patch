diff --git a/source/.github/CODEOWNERS b/source/.github/CODEOWNERS
deleted file mode 100644
index 9d3e4d2..0000000
--- a/source/.github/CODEOWNERS
+++ /dev/null
@@ -1 +0,0 @@
-* @epoberezkin @efim-poberezkin
diff --git a/source/.github/FUNDING.yml b/source/.github/FUNDING.yml
deleted file mode 100644
index 80da3b0..0000000
--- a/source/.github/FUNDING.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-github: simplex-chat
-open_collective: simplex-chat
diff --git a/source/.github/changelog_conf.json b/source/.github/changelog_conf.json
deleted file mode 100644
index 517c2a6..0000000
--- a/source/.github/changelog_conf.json
+++ /dev/null
@@ -1,4 +0,0 @@
-{
-  "template": "${{UNCATEGORIZED}}",
-  "pr_template": "- ${{TITLE}}"
-}
diff --git a/source/.github/workflows/build.yml b/source/.github/workflows/build.yml
deleted file mode 100644
index 536d67b..0000000
--- a/source/.github/workflows/build.yml
+++ /dev/null
@@ -1,85 +0,0 @@
-name: build
-
-on:
-  push:
-    branches:
-      - master
-      - stable
-    tags:
-      - "v*"
-  pull_request:
-
-jobs:
-  build:
-    name: build-${{ matrix.os }}
-    runs-on: ${{ matrix.os }}
-    strategy:
-      fail-fast: false
-      matrix:
-        include:
-          - os: ubuntu-18.04
-          - os: ubuntu-20.04
-    steps:
-      - name: Clone project
-        uses: actions/checkout@v2
-
-      - name: Setup Haskell
-        uses: haskell/actions/setup@v1
-        with:
-          ghc-version: "8.10.7"
-          cabal-version: "latest"
-
-      - name: Cache dependencies
-        uses: actions/cache@v2
-        with:
-          path: |
-            ~/.cabal/store
-            dist-newstyle
-          key: ${{ matrix.os }}-${{ hashFiles('cabal.project', 'simplexmq.cabal') }}
-
-      - name: Build
-        shell: bash
-        run: cabal build --enable-tests
-
-      - name: Test
-        if: matrix.os == 'ubuntu-18.04'
-        timeout-minutes: 30
-        shell: bash
-        run: cabal test --test-show-details=direct
-
-      - name: Prepare binaries
-        if: startsWith(github.ref, 'refs/tags/v') && matrix.os == 'ubuntu-20.04'
-        shell: bash
-        run: |
-          mv $(cabal list-bin smp-server) smp-server-ubuntu-20_04-x86-64
-          mv $(cabal list-bin ntf-server) ntf-server-ubuntu-20_04-x86-64
-
-      - name: Build changelog
-        if: startsWith(github.ref, 'refs/tags/v') && matrix.os == 'ubuntu-20.04'
-        id: build_changelog
-        uses: mikepenz/release-changelog-builder-action@v1
-        with:
-          configuration: .github/changelog_conf.json
-          failOnError: true
-          ignorePreReleases: true
-          commitMode: true
-        env:
-          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-
-      - name: Create release
-        if: startsWith(github.ref, 'refs/tags/v') && matrix.os == 'ubuntu-20.04'
-        uses: softprops/action-gh-release@v1
-        with:
-          body: |
-            See full changelog [here](https://github.com/simplex-chat/simplexmq/blob/master/CHANGELOG.md).
-
-            Commits:
-            ${{ steps.build_changelog.outputs.changelog }}
-          prerelease: true
-          files: |
-            LICENSE
-            smp-server-ubuntu-20_04-x86-64
-            ntf-server-ubuntu-20_04-x86-64
-          fail_on_unmatched_files: true
-        env:
-          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/source/CHANGELOG.md b/source/CHANGELOG.md
deleted file mode 100644
index 8a408cf..0000000
--- a/source/CHANGELOG.md
+++ /dev/null
@@ -1,287 +0,0 @@
-# 4.0.0
-
-SMP server:
-
-- Basic authentication. The server address can now include an optional password that is required to create messaging queues, so the contacts who message you will not be able to receive messages via your server, unless you share with them the address with the password. It is recommended to enable basic authentication on all private servers by adding `create_password` parameter into AUTH section of server INI file (the previously deployed servers do not have this section, you need to add it).
-- Disable creating new queues completely with `new_queues: off` parameter in AUTH section of INI file - it can be used to simplify migrating the exising connections to another server.
-- Updated server CLI with changed defaults:
-  - interactive server initialization, use -y flag to initalize the server non-interactively.
-  - store log is now enabled by default, so messaging queues and messages are restored when the server is restarted (to restore undelivered messages the server needs to be stopped with SIGINT signal).
-  - a random password is now generated by default during the server initialization.
-
-SMP agent:
-
-- API to test SMP servers. It connects to the server, creates and deletes a messaging queue. The new SimpleX Chat client uses this API to allow you to test that you have the correct server address, with the valid certificate fingerprint and pasword, before enabling the new server.
-
-# 3.4.0
-
-SMP agent:
-
-- increase concurrency with connection-level locks
-- fix issues identified in security assessment (see the announcement: https://github.com/simplex-chat/simplex-chat/blob/stable/blog/20221108-simplex-chat-v4.2-security-audit-new-website.md)
-- manual connection queue rotation
-- optional client data in connection requests links
-
-SMP server:
-
-- specialize monad stack to improve performance
-- log slow commands
-
-# 3.3.0
-
-SMP server:
-
-- allow repeated KEY command with the same key (to avoid failures on retries)
-
-SMP agent:
-
-- enable/disable connection notifications
-- asynchronous commands that retry on network error
-- use SQLCipher
-
-# 3.2.0
-
-SMP agent:
-
-- Support multiple server hostnames (including onion hostnames) in server addresses.
-- Network configuration options.
-- Options to define rules to choose server hostname.
-
-# 3.1.0
-
-SMP server and agent:
-
-- SMP protocol v4: batching multiple server commands/responses in a transport block.
-
-# 3.0.0
-
-SMP server:
-
-- restore undeliverd messages when the server is restarted.
-- SMP protocol v3 to support push notification:
-  - updated SEND and MSG to add message flags (for notification flag that contros whether the notification is sent and for any future extensions) and to move message meta-data sent to the recipient into the encrypted envelope.
-  - update NKEY and NID to add e2e encryption keys (for the notification meta-data encryption between SMP server and the client), and update NMSG to include this meta-data.
-  - update ACK command to include message ID (to avoid acknowledging unprocessed message).
-  - add NDEL commands to remove notification subscription credentials from SMP queue.
-  - add GET command to receive messages without subscription - to be used in iOS notification service extension to receive messages without terminating app subscriptions.
-
-SMP agent:
-
-- new protocol for duplex connection handshake reducing traffic and connection time.
-- support for SMP notifications server and managing device token.
-- remove redundant FQDN validation from TLS handshake to prepare for access via Tor.
-- support for fully stopping agent and for termporary suspending agent operations.
-- improve management of duplicate message delivery.
-
-SMP notifications server v1.0:
-
-- SMP notifications protocol with version negotiation during handshake.
-- device token registration and verification (via background notification).
-- SMP notification subscriptions and push notifications via APNS.
-- restoring notification subscriptions when the server is restarted.
-
-# 2.3.0
-
-SMP server:
-
-- Save and restore undelivered messages, to avoid losing them. To save messages the server has to be stopped with SIGINT signal, if it is stopped with SIGTERM undelivered messages would not be saved.
-
-# 2.2.0
-
-SMP server:
-
-- Fix sockets/threads/memory leak
-
-SMP agent:
-
-- Support stopping and resuming agent with `disconnectAgentClient` / `resumeAgentClient`
-
-# 2.1.1
-
-SMP server:
-
-- gracefully close sockets on client disconnection
-- CLI warning when deleting server configuration
-
-# 2.1.0
-
-SMP server:
-
-- configuration to expire inactive clients in ini file, increased TTL and check interval for client expiration
-
-# 2.0.0
-
-Push notifications server (beta):
-
-- supports APNS
-- manage device tokens verification via notification delivery
-- sending periodic background notification to check messages (not more frequent than every 20 min)
-
-SMP server:
-
-- disconnect inactive clients after some period
-- remove undelivered messages after 30 days
-- log aggregate usage daily stats: only the number of queues created/secured/deleted/used and messages sent/delivered is logged, as one line per day, so we can plan server capacity and diagnose any problems.
-
-SMP agent:
-
-- manage device tokens and notification server connection
-- DOWN/UP events to the agent user about server disconnections/reconnections are now sent once per server
-
-# 1.1.0
-
-SMP server:
-
-- message TTL and periodic deletion of old messages
-- configuration to prevent creation of the new queues
-
-SMP agent:
-
-- asynchronous connection handshake
-- configurable SMP servers at run-time
-- use TCP keep-alive for connection stability
-- improve stability of connection subscriptions
-- auto-vacuum DB to remove deleted records
-
-# 1.0.3
-
-SMP server:
-
-- Reduce server message queue quota to 128 messages.
-
-SMP agent:
-
-- Add "yes to migrations" option.
-- Make new SMP client attempt to reconnect on network error.
-- Reduce connection handshake expiration to 2 days.
-
-JSON encoding of types used in simplex-chat, some other minor adjustments.
-
-# 1.0.2
-
-General:
-
-- Enable TLS 1.3 parameters for TLS handshake (server and client).
-- Switch from hs-tls fork to original repo now that it supports getFinished and getPeerFinished APIs for both TLS 1.2 and TLS 1.3.
-
-SMP server:
-
-- Perform TLS handshake in a separate thread per-connection.
-
-SMP agent:
-
-- Cease attempts to send HELLO after one week timeout.
-- Coalesce requests to connect to SMP servers, to have 1 connection per server.
-
-# 1.0.1
-
-SMP server:
-
-- Explicitly set line buffering in stdout/stderr to log each line when output is redirected to files.
-
-# 1.0.0
-
-Security and privacy improvements:
-
-- Faster and more secure 2-layer E2E encryption with additional encryption layer between servers and recipients:
-  - application messages in each duplex connection (managed by SMP agents - see [overview](https://github.com/simplex-chat/simplexmq/blob/master/protocol/overview-tjr.md)) are encrypted using [double-ratchet algorithm](https://www.signal.org/docs/specifications/doubleratchet/), providing forward secrecy and break-in recovery. This layer uses two Curve448 keys per client for [X3DH key agreement](https://www.signal.org/docs/specifications/x3dh/), SHA512 based HKDFs and AES-GCM AEAD encryption.
-  - SMP client messages are additionally E2E encrypted in each SMP queue to avoid cipher-text correlation of messages sent via multiple redundant queues (that will be supported soon). This and the next layer use [NaCl crypto_box algorithm](https://nacl.cr.yp.to/index.html) with XSalsa20Poly1305 cipher and Curve25519 keys for DH key agreement.
-  - Messages delivered from the servers to the recipients are additionally encrypted to avoid cipher-text correlation between sent and received messages.
-- To prevent any traffic correlation by content size, SimpleX uses fixed transport block size of 16kb (16384 bytes) with padding on all encryption layers:
-  - application messages are padded to 15788 bytes before E2E double-ratchet encryption.
-  - messages between SMP clients are padded to 16032 bytes before E2E encryption in each SMP queue.
-  - messages from the server to the recipient are padded to padded to 16088 bytes before the additional encryption layer (see above).
-- TLS 1.2+ with tls-unique channel binding in each command to prevent replay attacks.
-- Server identity verification via server offline certificate fingerprints included in SMP server addresses.
-
-New functionality:
-
-- Support for notification servers with new SMP commands: `NKEY`/`NID`, `NSUB`/`NMSG`.
-
-Efficiency improvements:
-
-- Binary protocol encodings to reduce overhead from circa 15% to approximately 3.7% of transmitted application message size, with only 2.2% overhead for SMP protocol messages.
-- More performant cryptographic algorithms.
-
-For more information about SimpleX:
-
-- [SimpleX overview](https://github.com/simplex-chat/simplexmq/blob/master/protocol/overview-tjr.md).
-- [SimpleX chat v1 announcement](https://github.com/simplex-chat/simplex-chat/blob/master/blog/20220112-simplex-chat-v1-released.md).
-
-# 0.5.2
-
-- Fix message delivery logic that blocked delivery of all server messages when server per-queue quota exceeded, making it concurrent per SMP queue, not per server.
-
-# 0.5.1
-
-- Fix server subscription logic bug that was leading to memory leak / resource exhaustion in some edge cases.
-
-# 0.5.0
-
-- No changes in SMP server implementation - it is backwards compatible with v0.4.1
-- SMP agent changes:
-  - URI syntax for SMP queues and connection requests.
-  - long-term connections links ("contacts") in SMP agent protocol.
-  - agent command changes:
-    - `REQ` notification and `ACPT` command are used only with long-term connection links.
-    - `CONF` notification and `LET` commands are used for normal duplex connections.
-
-# 0.4.1
-
-- Include migrations in the package
-
-# 0.4.0
-
-- SMP server implementation and [SMP protocol](https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md) changes:
-  - support 3072 bit RSA key size
-  - add SMP queue quotas
-  - set default transport block size to 4096 bits
-  - allow SMP client to change transport block size during transport connection handshake
-- SMP agent implementation and protocol changes:
-  - additional connection confirmation step for initiating party
-  - automatically resume subscribed duplex connections once transport connection is resumed
-  - passing an arbitrary binary information between parties during the duplex connection handshake - can be used to identify parties
-  - asynchronous duplex connection handshake - the parties do not have to be online at the same time
-  - asynchronous message delivery - the agent does not need transport connection to accept client messages for delivery
-  - additional confirmation of message reception from the client to prevent message loss in case of process termination
-  - set transport block size to 8192 bits (in the future the agent protocol can allow to have different block sizes for different duplex connections)
-  - added client commands and notifications (see [agent protocol](https://github.com/simplex-chat/simplexmq/blob/master/protocol/agent-protocol.md)):
-    - `REQ` - the notification about joining party establishing connection
-    - `ACPT` - the command to accept connection with the joining party
-    - `INFO` - the notification with the information from the initiating party
-    - `DOWN`/`UP` - the notifications about losing/resuming the connection
-    - `ACK` - the command to confirm that the message reception/processing is complete
-    - `MID` - the response to `SEND` confirming that the message is accepted by the agent
-    - `MERR` - the notification about permanent message delivery error (e.g., `ERR AUTH` indicating that the queue was removed)
-
-# 0.3.2
-
-- Support websockets
-- SMP server CLI commands
-
-# 0.3.1
-
-- Released to hackage.org
-- SMP agent protocol changes:
-  - move SMP server from agent commands NEW/JOIN to agent config
-  - send CON to user only when the 1st party responds HELLO
-- Fix REPLY vulnerability
-- Fix transaction busy error
-
-# 0.3.0
-
-- SMP encrypted transport over TCP
-- Standard X509/PKCS8 encoding for RSA keys
-- Sign and verify agent messages
-- Verify message integrity based on previous message hash and ID
-- Prevent timing attack allowing to determine if queue exists
-- Only allow correct RSA keys and signature sizes
-
-# 0.2.0
-
-- SMP client library
-- SMP agent with E2E encryption
-
-# 0.1.0
-
-- SMP protocol server implementation without encryption
diff --git a/source/README.md b/source/README.md
deleted file mode 100644
index d81afc4..0000000
--- a/source/README.md
+++ /dev/null
@@ -1,252 +0,0 @@
-# SimpleXMQ
-
-[![GitHub build](https://github.com/simplex-chat/simplexmq/workflows/build/badge.svg)](https://github.com/simplex-chat/simplexmq/actions?query=workflow%3Abuild)
-[![GitHub release](https://img.shields.io/github/v/release/simplex-chat/simplexmq)](https://github.com/simplex-chat/simplexmq/releases)
-
-üì¢ SimpleXMQ v1 is released - with many security, privacy and efficiency improvements, new functionality - see [release notes](https://github.com/simplex-chat/simplexmq/releases/tag/v1.0.0).
-
-**Please note**: v1 is not backwards compatible, but it has the version negotiation built into all protocol layers for forwards compatibility of this version and backwards compatibility of the future versions, that will be backwards compatible for at least two versions back.
-
-If you have a server deployed please deploy a new server to a new host and retire the previous version once it is no longer used.
-
-## Message broker for unidirectional (simplex) queues
-
-SimpleXMQ is a message broker for managing message queues and sending messages over public network. It consists of SMP server, SMP client library and SMP agent that implement [SMP protocol](./protocol/simplex-messaging.md) for client-server communication and [SMP agent protocol](./protocol/agent-protocol.md) to manage duplex connections via simplex queues on multiple SMP servers.
-
-SMP protocol is inspired by [Redis serialization protocol](https://redis.io/topics/protocol), but it is much simpler - it currently has only 10 client commands and 8 server responses.
-
-SimpleXMQ is implemented in Haskell - it benefits from robust software transactional memory (STM) and concurrency primitives that Haskell provides.
-
-## SimpleXMQ roadmap
-
-- SimpleX service protocol and application template - to enable users building services and chat bots that work over SimpleX protocol stack. The first such service will be a notification service for a mobile app.
-- SMP queue redundancy and rotation in SMP agent connections.
-- SMP agents synchronization to share connections and messages between multiple agents (it would allow using multiple devices for [simplex-chat](https://github.com/simplex-chat/simplex-chat)).
-
-## Components
-
-### SMP server
-
-[SMP server](./apps/smp-server/Main.hs) can be run on any Linux distribution, including low power/low memory devices. OpenSSL library is required for initialization.
-
-To initialize the server use `smp-server init -n <fqdn>` (or `smp-server init --ip <ip>` for IP based address) command - it will generate keys and certificates for TLS transport. The fingerprint of offline certificate is used as part of the server address to protect client/server connection against man-in-the-middle attacks: `smp://<fingerprint>@<hostname>[:5223]`.
-
-SMP server uses in-memory persistence with an optional append-only log of created queues that allows to re-start the server without losing the connections. This log is compacted on every server restart, permanently removing suspended and removed queues.
-
-To enable store log, initialize server using `smp-server -l` command, or modify `smp-server.ini` created during initialization (uncomment `enable: on` option in the store log section). Use `smp-server --help` for other usage tips.
-
-Starting from version 2.3.0, when store log is enabled, the server would also enable saving undelivered messages on exit and restoring them on start. This can be disabled via a separate setting `restore_messages` in `smp-server.ini` file. Saving messages would only work if the server is stopped with SIGINT signal (keyboard interrupt), if it is stopped with SIGTERM signal the messages would not be saved.
-
-> **Please note:** On initialization SMP server creates a chain of two certificates: a self-signed CA certificate ("offline") and a server certificate used for TLS handshake ("online"). **You should store CA certificate private key securely and delete it from the server. If server TLS credential is compromised this key can be used to sign a new one, keeping the same server identity and established connections.** CA private key location by default is `/etc/opt/simplex/ca.key`.
-
-SMP server implements [SMP protocol](./protocol/simplex-messaging.md).
-
-#### Running SMP server on MacOS
-
-SMP server requires OpenSSL library for initialization. On MacOS OpenSSL library may be replaced with LibreSSL, which doesn't support required algorithms. Before initializing SMP server verify you have OpenSSL installed:
-
-```sh
-openssl version
-```
-
-If it says "LibreSSL", please install original OpenSSL:
-
-```sh
-brew update
-brew install openssl
-echo 'PATH="/opt/homebrew/opt/openssl@3/bin:$PATH"' >> ~/.zprofile # or follow whatever instructions brew suggests
-. ~/.zprofile # or restart your terminal to start a new session
-```
-
-Now `openssl version` should be saying "OpenSSL". You can now run `smp-server init` to initialize your SMP server.
-
-### SMP client library
-
-[SMP client](./src/Simplex/Messaging/Client.hs) is a Haskell library to connect to SMP servers that allows to:
-
-- execute commands with a functional API.
-- receive messages and other notifications via STM queue.
-- automatically send keep-alive commands.
-
-### SMP agent
-
-[SMP agent library](./src/Simplex/Messaging/Agent.hs) can be used to run SMP agent as part of another application and to communicate with the agent via STM queues, without serializing and parsing commands and responses.
-
-Haskell type [ACommand](./src/Simplex/Messaging/Agent/Protocol.hs) represents SMP agent protocol to communicate via STM queues.
-
-See [simplex-chat](https://github.com/simplex-chat/simplex-chat) terminal UI for the example of integrating SMP agent into another application.
-
-[SMP agent executable](./apps/smp-agent/Main.hs) can be used to run a standalone SMP agent process that implements plaintext [SMP agent protocol](./protocol/agent-protocol.md) via TCP port 5224, so it can be used via telnet. It can be deployed in private networks to share access to the connections between multiple applications and services.
-
-## Using SMP server and SMP agent
-
-You can either run your own SMP server locally or deploy using [Linode StackScript](https://cloud.linode.com/stackscripts/748014), or try local SMP agent with the deployed servers:
-
-`smp://u2dS9sG8nMNURyZwqASV4yROM28Er0luVTx5X1CsMrU=@smp4.simplex.im`
-
-`smp://hpq7_4gGJiilmz5Rf-CswuU5kZGkm_zOIooSw6yALRg=@smp5.simplex.im`
-
-`smp://PQUV2eL0t7OStZOoAsPEV2QYWt4-xilbakvGUGOItUo=@smp6.simplex.im`
-
-It's the easiest to try SMP agent via a prototype [simplex-chat](https://github.com/simplex-chat/simplex-chat) terminal UI.
-
-## Deploy SMP server on Linux
-
-You can run your SMP server as a Linux process, optionally using a service manager for booting and restarts.
-
-Notice that `smp-server` requires `openssl` as run-time dependency (it is used to generate server certificates during initialization). Install it with your packet manager:
-
-```sh
-# For Ubuntu
-apt update && apt install openssl
-```
-
-### Install binaries
-
-#### Using Docker
-
-On Linux, you can deploy smp server using Docker.
-
-1. Build your `smp-server` image:
-
-   ```sh
-   git clone https://github.com/simplex-chat/simplexmq
-   cd simplexmq
-   git checkout stable
-   DOCKER_BUILDKIT=1 docker build -t smp-server -f ./download.Dockerfile .
-   ```
-2. Run your Docker container:
-   ```sh
-   docker run -d \
-	     --name smp-server \
-	     -e addr="your_ip_or_domain" \
-	     -p 5223:5223 \
-	     -v ${PWD}/scripts/docker/config:/etc/opt/simplex \
-	     -v ${PWD}/scripts/docker/logs:/var/opt/simplex \
-	     smp-server
-   ```
-
-#### Ubuntu
-
-For Ubuntu you can download a binary from [the latest release](https://github.com/simplex-chat/simplexmq/releases).
-
-### Build from source
-
-#### Using Docker
-
-> **Please note:** to build the app use source code from [stable branch](https://github.com/simplex-chat/simplexmq/tree/stable).
-
-On Linux, you can build smp server using Docker.
-
-1. Build your `smp-server` image:
-
-   ```sh
-   git clone https://github.com/simplex-chat/simplexmq
-   cd simplexmq
-   git checkout stable
-   DOCKER_BUILDKIT=1 docker build -t smp-server -f ./build.Dockerfile .
-   ```
-2. Run your Docker container:
-   ```sh
-   docker run -d \
-	     --name smp-server \
-	     -e addr="your_ip_or_domain" \
-	     -p 5223:5223 \
-	     -v ${PWD}/scripts/docker/config:/etc/opt/simplex \
-	     -v ${PWD}/scripts/docker/logs:/var/opt/simplex \
-	     smp-server
-   ```
-
-#### Using your distribution
-
-1. Install [Haskell GHCup](https://www.haskell.org/ghcup/), GHC 8.10.7 and cabal:
-
-   ```sh
-   curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
-   ghcup install ghc 8.10.7
-   ghcup install cabal
-   ghcup set ghc 8.10.7
-   ghcup set cabal
-   ```
-
-2. Build the project:
-
-   ```sh
-   git clone https://github.com/simplex-chat/simplexmq
-   cd simplexmq
-   git checkout stable
-   # On Ubuntu. Depending on your distribution, use your package manager to determine package names.
-   apt-get update && apt-get install -y build-essential libgmp3-dev zlib1g-dev
-   cabal update
-   cabal install
-   ```
-
-- Initialize SMP server with `smp-server init [-l] -n <fqdn>` or `smp-server init [-l] --ip <ip>` - depending on how you initialize it, either FQDN or IP will be used for server's address.
-
-- Run `smp-server start` to start SMP server, or you can configure a service manager to run it as a service.
-
-- Optionally, `smp-server` can be setup for having an onion address in `tor` network. See: [`scripts/tor`](./scripts/tor/). In this case, the server address can have both public and onion hostname pointing to the same server, to allow two people connect when only one of them is using Tor. The server address would be: `smp://<fingerprint>@<public_hostname>,<onion_hostname>`
-
-See [this section](#smp-server) for more information. Run `smp-server -h` and `smp-server init -h` for explanation of commands and options.
-
-[<img alt="Linode" src="./img/linode.svg" align="right" width="200">](https://cloud.linode.com/stackscripts/748014)
-
-## Deploy SMP server on Linode
-
-\* You can use free credit Linode offers when [creating a new account](https://www.linode.com/) to deploy an SMP server.
-
-Deployment on Linode is performed via StackScripts, which serve as recipes for Linode instances, also called Linodes. To deploy SMP server on Linode:
-
-- Create a Linode account or login with an already existing one.
-- Open [SMP server StackScript](https://cloud.linode.com/stackscripts/748014) and click "Deploy New Linode".
-- You can optionally configure the following parameters:
-  - SMP Server store log flag for queue persistence on server restart, recommended.
-  - [Linode API token](https://www.linode.com/docs/guides/getting-started-with-the-linode-api#get-an-access-token) to attach server address etc. as tags to Linode and to add A record to your 2nd level domain (e.g. `example.com` [domain should be created](https://cloud.linode.com/domains/create) in your account prior to deployment). The API token access scopes:
-    - read/write for "linodes"
-    - read/write for "domains"
-  - Domain name to use instead of Linode IP address, e.g. `smp1.example.com`.
-- Choose the region and plan, Shared CPU Nanode with 1Gb is sufficient.
-- Provide ssh key to be able to connect to your Linode via ssh. If you haven't provided a Linode API token this step is required to login to your Linode and get the server's fingerprint either from the welcome message or from the file `/etc/opt/simplex/fingerprint` after server starts. See [Linode's guide on ssh](https://www.linode.com/docs/guides/use-public-key-authentication-with-ssh/) .
-- Deploy your Linode. After it starts wait for SMP server to start and for tags to appear (if a Linode API token was provided). It may take up to 5 minutes depending on the connection speed on the Linode. Connecting Linode IP address to provided domain name may take some additional time.
-- Get `address` and `fingerprint` either from Linode tags (click on a tag and copy it's value from the browser search panel) or via ssh.
-- Great, your own SMP server is ready! If you provided FQDN use `smp://<fingerprint>@<fqdn>` as SMP server address in the client, otherwise use `smp://<fingerprint>@<ip_address>`.
-
-Please submit an [issue](https://github.com/simplex-chat/simplexmq/issues) if any problems occur.
-
-[<img alt="DigitalOcean" src="/img/digitalocean.png" align="right" width="300">](https://marketplace.digitalocean.com/apps/simplex-server)
-
-## Deploy SMP server on DigitalOcean
-
-> üöß DigitalOcean snapshot is currently not up to date, it will soon be updated üèóÔ∏è
-
-\* When creating a DigitalOcean account you can use [this link](https://try.digitalocean.com/freetrialoffer/) to get free credit. (You would still be required either to provide your credit card details or make a confirmation pre-payment with PayPal)
-
-To deploy SMP server use [SimpleX Server 1-click app](https://marketplace.digitalocean.com/apps/simplex-server) from DigitalOcean marketplace:
-
-- Create a DigitalOcean account or login with an already existing one.
-- Click 'Create SimpleX server Droplet' button.
-- Choose the region and plan according to your requirements (Basic plan should be sufficient).
-- Finalize Droplet creation.
-- Open "Console" on your Droplet management page to get SMP server fingerprint - either from the welcome message or from `/etc/opt/simplex/fingerprint`. Alternatively you can manually SSH to created Droplet, see [DigitalOcean instruction](https://docs.digitalocean.com/products/droplets/how-to/connect-with-ssh/).
-- Great, your own SMP server is ready! Use `smp://<fingerprint>@<ip_address>` as SMP server address in the client.
-
-Please submit an [issue](https://github.com/simplex-chat/simplexmq/issues) if any problems occur.
-
-> **Please note:** SMP server uses server address as a Common Name for server certificate generated during initialization. If you would like your server address to be FQDN instead of IP address, you can log in to your Droplet and run the commands below to re-initialize the server. Alternatively you can use [Linode StackScript](https://cloud.linode.com/stackscripts/748014) which allows this parameterization.
-
-```sh
-smp-server delete
-smp-server init [-l] -n <fqdn>
-```
-
-## SMP server design
-
-![SMP server design](./design/server.svg)
-
-## SMP agent design
-
-![SMP agent design](./design/agent2.svg)
-
-## License
-
-[AGPL v3](./LICENSE)
diff --git a/source/apps/ntf-server/Main.hs b/source/apps/ntf-server/Main.hs
deleted file mode 100644
index aa62d35..0000000
--- a/source/apps/ntf-server/Main.hs
+++ /dev/null
@@ -1,18 +0,0 @@
-module Main where
-
-import Control.Logger.Simple
-import Simplex.Messaging.Notifications.Server.Main
-
-cfgPath :: FilePath
-cfgPath = "/etc/opt/simplex-notifications"
-
-logPath :: FilePath
-logPath = "/var/opt/simplex-notifications"
-
-logCfg :: LogConfig
-logCfg = LogConfig {lc_file = Nothing, lc_stderr = True}
-
-main :: IO ()
-main = do
-  setLogLevel LogDebug -- change to LogError in production
-  withGlobalLogging logCfg $ ntfServerCLI cfgPath logPath
diff --git a/source/apps/smp-agent/Main.hs b/source/apps/smp-agent/Main.hs
deleted file mode 100644
index da43bde..0000000
--- a/source/apps/smp-agent/Main.hs
+++ /dev/null
@@ -1,33 +0,0 @@
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE TypeApplications #-}
-
-module Main where
-
-import Control.Logger.Simple
-import qualified Data.List.NonEmpty as L
-import Simplex.Messaging.Agent.Env.SQLite
-import Simplex.Messaging.Agent.Server (runSMPAgent)
-import Simplex.Messaging.Client (defaultNetworkConfig)
-import Simplex.Messaging.Transport (TLS, Transport (..))
-
-cfg :: AgentConfig
-cfg = defaultAgentConfig
-
-servers :: InitialAgentServers
-servers =
-  InitialAgentServers
-    { smp = L.fromList ["smp://bU0K-bRg24xWW__lS0umO1Zdw_SXqpJNtm1_RrPLViE=@localhost:5223"],
-      ntf = [],
-      netCfg = defaultNetworkConfig
-    }
-
-logCfg :: LogConfig
-logCfg = LogConfig {lc_file = Nothing, lc_stderr = True}
-
-main :: IO ()
-main = do
-  putStrLn $ "SMP agent listening on port " ++ tcpPort (cfg :: AgentConfig)
-  setLogLevel LogInfo -- LogError
-  withGlobalLogging logCfg $ runSMPAgent (transport @TLS) cfg servers
diff --git a/source/apps/smp-server/Main.hs b/source/apps/smp-server/Main.hs
deleted file mode 100644
index 07dbc51..0000000
--- a/source/apps/smp-server/Main.hs
+++ /dev/null
@@ -1,18 +0,0 @@
-module Main where
-
-import Control.Logger.Simple
-import Simplex.Messaging.Server.Main
-
-cfgPath :: FilePath
-cfgPath = "/etc/opt/simplex"
-
-logPath :: FilePath
-logPath = "/var/opt/simplex"
-
-logCfg :: LogConfig
-logCfg = LogConfig {lc_file = Nothing, lc_stderr = True}
-
-main :: IO ()
-main = do
-  setLogLevel LogDebug
-  withGlobalLogging logCfg $ smpServerCLI cfgPath logPath
diff --git a/source/build.Dockerfile b/source/build.Dockerfile
deleted file mode 100644
index c8cf429..0000000
--- a/source/build.Dockerfile
+++ /dev/null
@@ -1,51 +0,0 @@
-FROM ubuntu:focal AS final
-FROM ubuntu:focal AS build
-
-### Build stage
-
-# Install curl and git and smp-related dependencies
-RUN apt-get update && apt-get install -y curl git build-essential libgmp3-dev zlib1g-dev
-
-# Install ghcup
-RUN curl https://downloads.haskell.org/~ghcup/x86_64-linux-ghcup -o /usr/bin/ghcup && \
-    chmod +x /usr/bin/ghcup
-
-# Install ghc
-RUN ghcup install ghc 8.10.7
-# Install cabal
-RUN ghcup install cabal
-# Set both as default
-RUN ghcup set ghc 8.10.7 && \
-    ghcup set cabal
-
-COPY . /project
-WORKDIR /project
-
-# Adjust PATH
-ENV PATH="/root/.cabal/bin:/root/.ghcup/bin:$PATH"
-
-# Compile smp-server
-RUN cabal update
-RUN cabal install
-
-### Final stage
-
-FROM final
-
-# Install OpenSSL dependency
-RUN apt-get update && apt-get install -y openssl
-
-# Copy compiled smp-server from build stage
-COPY --from=build /root/.cabal/bin/smp-server /usr/bin/smp-server
-
-# Copy our helper script
-COPY ./scripts/docker/entrypoint /usr/bin/entrypoint
-
-# Open smp-server listening port
-EXPOSE 5223
-
-# SimpleX requires using SIGINT to correctly preserve undelivered messages and restore them on restart
-STOPSIGNAL SIGINT
-
-# Finally, execute helper script
-ENTRYPOINT [ "/usr/bin/entrypoint" ]
diff --git a/source/cabal.project b/source/cabal.project
deleted file mode 100644
index 96cf5ba..0000000
--- a/source/cabal.project
+++ /dev/null
@@ -1,17 +0,0 @@
-packages: .
--- packages: . ../direct-sqlcipher ../sqlcipher-simple
-
-source-repository-package
-    type: git
-    location: https://github.com/simplex-chat/aeson.git
-    tag: 3eb66f9a68f103b5f1489382aad89f5712a64db7
-
-source-repository-package
-    type: git
-    location: https://github.com/simplex-chat/direct-sqlcipher.git
-    tag: 34309410eb2069b029b8fc1872deb1e0db123294
-
-source-repository-package
-    type: git
-    location: https://github.com/simplex-chat/sqlcipher-simple.git
-    tag: 5e154a2aeccc33ead6c243ec07195ab673137221
diff --git a/source/design/agent-commands.md b/source/design/agent-commands.md
deleted file mode 100644
index 4e5e623..0000000
--- a/source/design/agent-commands.md
+++ /dev/null
@@ -1,185 +0,0 @@
-# SMP agent commands (Duplex protocol commands) 
-
-This document describes Duplex commands flow through SMP agent components (see *design/agent.gv*), as well as some interactions between [recipient and sender](#Recipient-and-sender-terminology) clients, clients' SMP agents and SMP servers, and sequencing of Duplex and SMP commands.
-
-Legend:
-
-- > Command flow through SMP agent in blockquotes
-
-- **Q - Design and other questions in bold**
-
-## Table of contents
-
-- [Recipient and sender terminology](#Recipient-and-sender-terminology)
-- [Agent design comparison](#agent-design-comparison)
-- [Communication between user client and client-side SMP agent](#Communication-between-user-client-and-client-side-SMP-agent)
-  - [User client commands](#User-client-commands)
-    - [`create`](#create)
-    - [`join`](#join)
-    - [`accept`](#accept)
-    - [`subscribe`](#subscribe)
-    - [`getStatus`](#getStatus)
-    - [`send`](#send)
-    - [`acknowledge`](#acknowledge)
-    - [`suspend`](#suspend)
-    - [`delete`](#delete)
-  - [Agent messages to user client](#Agent-messages-to-user-client)
-    - [`connection`](#connection)
-    - [`connectionInvitation`](#connectionInvitation)
-    - [`confirmation`](#confirmation)
-    - [`message`](#message)
-    - [`unsubscribed`](#unsubscribed)
-    - [`queueStatus`](#queueStatus)
-    - [`ok`](#ok)
-    - [`error`](#error)
-- [Communication between SMP agents](#Communication-between-SMP-agents)
-  - [`helloMsg`](#helloMsg)
-  - [`replyQueueMsg`](#replyQueueMsg)
-  - [`deleteQueueMsg`](#deleteQueueMsg)
-  - [`clientMsg`](#clientMsg)
-  - [`acknowledgeMsg`](#acknowledgeMsg)
-- [General questions](#General-questions)
-
-## Recipient and sender terminology
-
-Here and further recipient is referred to the side that initiates the connection, i.e. creates the initial SMP queue and sends an out-of-band invitation to the sender. Sender is referred to the side that joins this SMP queue through the out-of-band invitation and then creates another SMP queue in the opposite direction for the recipient. This is to distinguish the sides for commands that imply specific direction, conceptually in Duplex connection once connection is established both sides act both as a recipient and a sender through different SMP queues.
-
-## Agent design comparison
-
-| Option | Pros | Cons |
-| ------ | ---- | ---- | 
-| agent.gv | one TCP connection to a specific SMP server host is re-used by multiple users. | responses from the same server to multiple users are mixed and have to be correlated not only with commands but with the users as well, this correlation is not present in the design yet |
-| agent2.gv | easier correlation of commands with responses, clear separation of internal user agent API (TBQueues) from TCP api (although this can be done with the first design as well) | if there are multiple users, there may be multiple TCP connections to the same SMP host |
-
-## Communication between user client and client-side SMP agent
-
-### User client commands
-
-#### `create`
-
-üöß **To be fixed according to agent2.gv**
-
-Requests recipient SMP server to create a new SMP queue. 
-
-Is made by the [recipient](#Recipient-and-sender-terminology).
-
-> recipient user client -> user agent TCP socket (main socket) -> runUser thread -> create user connection group (socket and threads) -> user connection group "user" thread -> agent server commands queue -> runServer thread -> SMP `create` command sent to server connection group "send" queue -> server connection group "send" thread -> SMP server connection TCP socket -> recipient's SMP server
-
-- SMP Server then responds with SMP `queueIds` command to SMP server connection TCP socket
-- Recipient agent gets automatically subscribed to receive the messages from the queue
-- Agent replies to user client with Duplex [`connectionInvitation`](#connectionInvitation) command
-- User sends connection invitation out-of-band to sender
-
-- **Q - Shouldn't user connection group be created after server responds, or even after sender joins and invites back?**
-
-  A - Agent has to correlate commands with responses anyway (replying on the fact that responses arrive in the same order that the commands were sent, occasionally interleaved with messages), so all the information needed to create the connection will be available in the command buffer anyway. It is probably better to create connection in the agent after the queue was successfully created in the server, and send an error to the user if SMP server responded with error.
-
-- **Q - How does flow go from runUser thread to user connection group "user" thread? Does runUser pass the the initial `create` command further to "user" thread through socket?**
-
-  A - runUser does not receive any TCP traffic other than initial TCP handshake, when it does it forks all user group threads. It does not participate in commands/messages flow. Commands go from "user" to "runServer" (via TBQueue), responses,messages and acknowledgements (see protocol changes) from "message subscriber" to "send" (via TBQueue)
-
-- **Q - Does sender agent persist partial info about connection record at this point, or only when receives an opposing queue from the sender?**
-
-  A - Yes, it should create connection with one queue (status "PENDING"), the status of the second queue will be "NONE" - see sequence diagram. In types it is `Maybe ConnState` with "NONE" corresponding to `Nothing`, as we don't need to have the second queue record. Also, protocol allows not to have reply queue, so the connection can remain unidirectional.
-
-- **Q - Shouldn't agent at this point answer with Duplex [`connection`](#connection) command? SMP agent commands have conflicting comments in the Duplex protocol. What is that command used for at all at this point?**
-
-  A - There is no need to split creating connection and creating the invitation - it was initially two commands, and now it's merged into one - it creates the queue on SMP server, connection record in the agent and the invitation string to be sent out-of-band to the other party - need to fix any contradictions.
-
-#### `join`
-
-üöß **To be fixed according to agent2.gv**
-
-Replies via out-of-band invitation with sender's key and profile.
-
-Is made by the [sender](#Recipient-and-sender-terminology).
-
-> sender user client -> user agent TCP socket (main socket) -> runUser thread -> create user connection group (socket and threads) -> user connection group "user" thread -> agent server commands queue -> runServer thread -> SMP `send` command sent to server connection group "send" queue, it contains sender's key and profile wrapped in Duplex [`clientMsg`](#clientMsg) command -> server connection group "send" thread -> SMP server connection TCP socket -> recipient's SMP server
-
-- SMP server then delivers sender's message containing key and profile to recipient SMP agent with SMP `message` command
-- Recipient agent secures previously created queue with Duplex [`accept`](#accept) command
-
-#### `accept`
-
-üöß **To be fixed according to agent2.gv**
-
-Secures SMP queue with sender's key.
-
-Is made by the [recipient](#Recipient-and-sender-terminology).
-
-> recipient user client -> user connection TCP socket -> user connection group "user" thread -> agent server commands queue -> runServer thread -> SMP `secure` command sent to server connection group "send" queue -> server connection group "send" thread -> SMP server connection TCP socket -> recipient's SMP server
-
-- Sender's agent at this point repeatedly sends Duplex [`helloMsg`](#helloMsg) command to the recipient SMP server, which should be successful once sender queue is secured by the recipient agent with key provided by the sender in the Duplex [`join`](#join) command
-- **Q - Does this command go through user agent TCP socket (main socket)? This relates to the question whether user connection groups for the recipient agent should be created during Duplex [`create`](#create) command**
-
-  A - User connection group is created during TCP handshake.
-
-#### `subscribe`
-
-Subscribes/unsubscribes user to/from SMP queue.
-
-> agent client -> user connection TCP socket -> "user receive" thread -> user receive TBQueue -> "process commands" thread -> \*
->
-> \* -> commands TBQueue -> client thread; client thread is blocked until receives answer from SMP server -> \#
->
-> \* -> srv snd TBQueue -> "server send" thread -> `subscribe` SMP command is sent through SMP client connection TCP socket -> SMP server responds with first available message or if there is none with SMP `ok` command back to SMP client connection TCP socket -> "server receive" thread -> srv rcv TBQueue -> client thread; client thread becomes unblocked -> \#
->
-> \# -> user SMP TBQueue -> "process responses" thread -> queue is persisted as Disabled -> Duplex [`ok`](#ok) command sent to user send TBQueue -> "user send" thread -> user connection TCP socket -> agent client
-
-- **Q - Which SMP command is sent to the SMP server on Duplex `subscribe Off`?**
-
-  A -
-
-#### `getStatus`
-
-#### `send`
-
-#### `acknowledge`
-
-#### `suspend`
-
-#### `delete`
-
-### Agent messages to user client
-
-TODO
-
-#### `connection`
-
-#### `connectionInvitation`
-
-#### `confirmation`
-
-#### `message`
-
-#### `unsubscribed`
-
-#### `queueStatus`
-
-#### `ok`
-
-#### `error`
-
-## Communication between SMP agents
-
-TODO
-
-#### `helloMsg`
-
-#### `replyQueueMsg`
-
-#### `deleteQueueMsg`
-
-#### `clientMsg`
-
-#### `acknowledgeMsg`
-
-## General questions
-
-- **Q - When does agent set up server connection groups?**
-
-  A - When it sees the new hostname:port combination - see the map of servers inside [AgentClient](https://github.com/simplex-chat/simplex-messaging/blob/client/src/Simplex/Messaging/Agent/Env.hs#L33)
-
-- **Q - Replace command keywords with command names in the Duplex protocol sequence diagram?**
-
-  A - Let's keep keywords, I also use them as constructors in code, they are part of the actual command syntax.
diff --git a/source/design/agent.gv b/source/design/agent.gv
deleted file mode 100644
index 43271a6..0000000
--- a/source/design/agent.gv
+++ /dev/null
@@ -1,79 +0,0 @@
-digraph SMPAgent {
-  graph [fontname=arial]
-  node [fontname=arial fontsize=11 shape=box]
-  edge [fontname=arial fontsize=10 arrowhead=open arrowtail=open]
-
-  subgraph clusterAgent {
-    label="agent threads" 
-    main [shape=hexagon color=orange label="main\nthread"]
-    aSock [label="user agent TCP socket" color=darkgreen]
-    subgraph clusterThreads {
-      label="" 
-      node [shape=hexagon color=orange]
-      runUser [label="runUser\nthread"]
-      runServer [label="runServer\nthread"]
-      msgSubscriber [label="message\nsubscriber\nthread"]
-    }
-    main -> {runUser runServer} [style=dashed label=race color=orange fontcolor=orange]
-    aSock -> runUser [color=darkgreen]
-
-    acInq [shape=larrow label="agent\nserver\ncommands\nTBQueue"]
-    acInq -> runServer [color=darkgreen]
-    runServer -> amInq [color=darkgreen label="unknown\nconnection\nor\nwrong\nconnection\nstate"]
-
-    amInq [shape=rarrow label="agent\nserver\nmessages\nTBQueue"]
-    amInq -> msgSubscriber [color=blue]
-
-    msgSubscriber -> connectionsStore [dir=both]
-    runUser -> connectionsStore [dir=both]
-    runServer -> connectionsStore [dir=both]
-
-    connectionsStore [shape=cylinder label="duplex\nconnection\nrecords"]
-  }
-
-  subgraph clusterUser {
-    label="1 group per user connection"
-    uSock [label="user connection TCP socket" color=darkgreen]
-
-    subgraph clusterUserThreads {
-      graph [fontsize=11]
-      label="user threads"
-      node [shape=hexagon, color=orange]
-      uAgent [label="user"]
-      uSnd [label="send"]
-    }
-
-    runUser -> uSock [style=dashed label="connect" color=darkgreen fontcolor=darkgreen]
-    runUser -> {uAgent uSnd} [style=dashed label=race color=orange fontcolor=orange]
-
-    uOutq [shape=larrow label="send\nTBQueue"]
-    uSock -> uAgent [color=darkgreen]
-    uAgent -> uOutq [color=darkgreen label="SMAP\ncommand\nsyntax\nerror"]
-    uOutq -> uSnd -> uSock [color=darkgreen]
-
-    msgSubscriber -> uOutq [color=blue label="SMAP\nmessages\nand\ncommand\nresponses"]
-    uAgent -> acInq [color=darkgreen label="SMAP\nprotocol\ncommand"]
-  }
-
-  subgraph clusterServer {
-    label="1 group per SMP server connection"
-    sSock [label="SMP server connection TCP socket" color=blue]
-
-    subgraph clusterServerThreads {
-      graph [fontsize=11]
-      label="server threads"
-      node [shape=hexagon, color=orange]
-      sAgent [label="server"]
-      sSnd [label="send"]
-    }
-
-    runServer -> {sAgent sSnd} [style=dashed label=race color=orange fontcolor=orange]
-
-    sOutq [shape=larrow label="send\nTBQueue"]
-    sSock -> sAgent [color=blue]
-    runServer -> sOutq [color=darkgreen label="SMP\nprotocol\ncommand"]
-    sOutq -> sSnd -> sSock [color=blue]
-
-    sAgent -> amInq [color=blue label="wrapped\nSMP\nmessages\nand\ncommand\nresponses"]
-  }
-}
diff --git a/source/design/agent2.gv b/source/design/agent2.gv
deleted file mode 100644
index a93a1fc..0000000
--- a/source/design/agent2.gv
+++ /dev/null
@@ -1,99 +0,0 @@
-digraph SMPAgent {
-  graph [fontname=arial]
-  node [fontname=arial fontsize=11 shape=box]
-  edge [fontname=arial fontsize=10 arrowhead=open arrowtail=open]
-
-  main [shape=hexagon color=orange label="main\nthread"]
-  aSock [label="user agent TCP socket" color=darkgreen]
-
-  subgraph clusterPersistence {
-    graph [fontsize=11 color=gray]
-    label="persistence (sqlite)"
-    connectionsStore [shape=cylinder label="duplex connections,\nSMP queues,\nrecent messages"]
-  }
-
-  subgraph clusterAgent {
-    graph [color=gray]
-    node [shape=hexagon color=orange]
-    label="agent threads" 
-    connectClnt
-    runClnt
-  }
-
-  main -> {runClnt connectClnt} [style=dashed label="race" color=orange fontcolor=orange]
-  aSock -> connectClnt [color=darkgreen]
-
-  subgraph clusterUserTCP {
-    graph [color=gray]
-    label="1 group per user TCP connection"
-    uSock [label="user connection TCP socket" color=darkgreen]
-
-    subgraph clusterUserTCPThreads {
-      graph [fontsize=11 color=gray]
-      label="user TCP threads"
-      node [shape=hexagon, color=orange]
-      uRcv [label="user\nreceive"]
-      uSnd [label="user\nsend"]
-    }
-
-    uSock -> uRcv [color=darkgreen]
-    uSnd -> uSock [color=darkgreen]
-  }
-
-  subgraph clusterUser {
-    graph [color=gray]
-    label="1 group per user TCP connection"
-
-    subgraph clusterUserInterface {
-      graph [fontsize=11]
-      label="user queues"
-      uInq [shape=rarrow label="user\nreceive\nTBQueue"]
-      uOutq [shape=larrow label="user\nsend\nTBQueue"]
-    }
-
-    subgraph clusterUserThreads {
-      graph [fontsize=11]
-      label="user threads\nNote: `user agent` sends\nall commands to `commands TBQueue`s\n(invalid commands with attached responses),\nand only valid commands to `server TBQueue`.\nIt is used to respond in correct order."
-      node [shape=hexagon, color=orange]
-      uAgent [label="user\nagent"]
-      uProcess [label="process\nresponses"]
-    }
-
-    uRcv -> uInq -> uAgent [color=darkgreen]
-    uProcess -> uOutq -> uSnd [color=darkgreen]
-    {uRcv uAgent} -> uOutq [color=green]
-
-    uRespq [shape=rarrow label="user\nSMP\nTBQueue"]
-
-    subgraph clusterClient {
-      label="1 group per SMP client/server connection"
-      runClient [shape=hexagon, color=orange]
-      sOutq [shape=rarrow label="srv send\nTBQueue"]
-      sSock [label="SMP client connection TCP socket" color=blue]
-
-      subgraph clusterServerThreads {
-        graph [fontsize=11]
-        label="SMP client threads"
-        node [shape=hexagon, color=orange]
-        sAgent [label="server\nreceive"]
-        sSnd [label="server\nsend"]
-      }
-
-      runClient -> {sAgent sSnd} [style=dashed label=race color=orange fontcolor=orange]
-      {uAgent uProcess} -> sOutq -> sSnd -> sSock -> sAgent [color=blue]
-    }
-
-    userState [label="connected\nservers,\nsubscribed\nqueues,\nsent\ncommands\n(STM)" shape="folder"]
-
-    {uAgent uProcess} -> userState [dir=both color="#FF8888"]
-    {uAgent uProcess} -> connectionsStore [dir=both color="#880000"]
-
-    connectClnt -> uSock [style=dashed label="connect" color=darkgreen fontcolor=darkgreen]
-    connectClnt -> {uRcv uSnd} [style=dashed label="race" color=orange fontcolor=orange]
-    runClnt -> {uAgent uProcess} [style=dashed label="race" color=orange fontcolor=orange]
-
-    sAgent -> uRespq -> uProcess
-
-    uAgent -> runClient [style=dashed label="fork" color=orange fontcolor=orange]
-  }
-}
diff --git a/source/design/agent2.svg b/source/design/agent2.svg
deleted file mode 100644
index b4f2a0c..0000000
--- a/source/design/agent2.svg
+++ /dev/null
@@ -1,394 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
- "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<!-- Generated by graphviz version 2.40.1 (20161225.0304)
- -->
-<!-- Title: SMPAgent Pages: 1 -->
-<svg width="1073pt" height="1142pt"
- viewBox="0.00 0.00 1073.00 1142.34" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
-<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 1138.3374)">
-<title>SMPAgent</title>
-<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-1138.3374 1069,-1138.3374 1069,4 -4,4"/>
-<g id="clust1" class="cluster">
-<title>clusterPersistence</title>
-<polygon fill="none" stroke="#c0c0c0" points="927,-512.7374 927,-615.3874 1057,-615.3874 1057,-512.7374 927,-512.7374"/>
-<text text-anchor="middle" x="992" y="-601.4874" font-family="arial" font-size="11.00" fill="#000000">persistence (sqlite)</text>
-</g>
-<g id="clust2" class="cluster">
-<title>clusterAgent</title>
-<polygon fill="none" stroke="#c0c0c0" points="175,-963.3624 175,-1040.1624 389,-1040.1624 389,-963.3624 175,-963.3624"/>
-<text text-anchor="middle" x="282" y="-1023.5624" font-family="arial" font-size="14.00" fill="#000000">agent threads</text>
-</g>
-<g id="clust4" class="cluster">
-<title>clusterUserTCP</title>
-<polygon fill="none" stroke="#c0c0c0" points="8,-509.375 8,-933.3624 230,-933.3624 230,-509.375 8,-509.375"/>
-<text text-anchor="middle" x="119" y="-916.7624" font-family="arial" font-size="14.00" fill="#000000">1 group per user TCP connection</text>
-</g>
-<g id="clust5" class="cluster">
-<title>clusterUserTCPThreads</title>
-<polygon fill="none" stroke="#c0c0c0" points="38,-517.375 38,-610.7499 222,-610.7499 222,-517.375 38,-517.375"/>
-<text text-anchor="middle" x="130" y="-596.8499" font-family="arial" font-size="11.00" fill="#000000">user TCP threads</text>
-</g>
-<g id="clust6" class="cluster">
-<title>clusterUser</title>
-<polygon fill="none" stroke="#c0c0c0" points="250,-8 250,-826.5624 919,-826.5624 919,-8 250,-8"/>
-<text text-anchor="middle" x="584.5" y="-809.9624" font-family="arial" font-size="14.00" fill="#000000">1 group per user TCP connection</text>
-</g>
-<g id="clust7" class="cluster">
-<title>clusterUserInterface</title>
-<polygon fill="none" stroke="#c0c0c0" points="258,-400.375 258,-485.175 419,-485.175 419,-400.375 258,-400.375"/>
-<text text-anchor="middle" x="338.5" y="-471.275" font-family="arial" font-size="11.00" fill="#000000">user queues</text>
-</g>
-<g id="clust8" class="cluster">
-<title>clusterUserThreads</title>
-<polygon fill="none" stroke="#c0c0c0" points="622,-634.3874 622,-793.7624 865,-793.7624 865,-634.3874 622,-634.3874"/>
-<text text-anchor="middle" x="743.5" y="-779.8624" font-family="arial" font-size="11.00" fill="#000000">user threads</text>
-<text text-anchor="middle" x="743.5" y="-766.6624" font-family="arial" font-size="11.00" fill="#000000">Note: `user agent` sends</text>
-<text text-anchor="middle" x="743.5" y="-753.4624" font-family="arial" font-size="11.00" fill="#000000">all commands to `commands TBQueue`s</text>
-<text text-anchor="middle" x="743.5" y="-740.2624" font-family="arial" font-size="11.00" fill="#000000">(invalid commands with attached responses),</text>
-<text text-anchor="middle" x="743.5" y="-727.0624" font-family="arial" font-size="11.00" fill="#000000">and only valid commands to `server TBQueue`.</text>
-<text text-anchor="middle" x="743.5" y="-713.8624" font-family="arial" font-size="11.00" fill="#000000">It is used to respond in correct order.</text>
-</g>
-<g id="clust10" class="cluster">
-<title>clusterClient</title>
-<polygon fill="none" stroke="#c0c0c0" points="427,-128.6 427,-482.975 812,-482.975 812,-128.6 427,-128.6"/>
-<text text-anchor="middle" x="619.5" y="-466.375" font-family="arial" font-size="14.00" fill="#000000">1 group per SMP client/server connection</text>
-</g>
-<g id="clust11" class="cluster">
-<title>clusterServerThreads</title>
-<polygon fill="none" stroke="#c0c0c0" points="564,-136.6 564,-229.975 758,-229.975 758,-136.6 564,-136.6"/>
-<text text-anchor="middle" x="661" y="-216.075" font-family="arial" font-size="11.00" fill="#000000">SMP client threads</text>
-</g>
-<!-- main -->
-<g id="node1" class="node">
-<title>main</title>
-<polygon fill="none" stroke="#ffa500" points="382.542,-1106.2499 363.271,-1134.4251 324.729,-1134.4251 305.458,-1106.2499 324.729,-1078.0747 363.271,-1078.0747 382.542,-1106.2499"/>
-<text text-anchor="middle" x="344" y="-1109.5499" font-family="arial" font-size="11.00" fill="#000000">main</text>
-<text text-anchor="middle" x="344" y="-1096.3499" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- connectClnt -->
-<g id="node4" class="node">
-<title>connectClnt</title>
-<polygon fill="none" stroke="#ffa500" points="288.8246,-989.3624 262.4123,-1007.3624 209.5877,-1007.3624 183.1754,-989.3624 209.5877,-971.3624 262.4123,-971.3624 288.8246,-989.3624"/>
-<text text-anchor="middle" x="236" y="-986.0624" font-family="arial" font-size="11.00" fill="#000000">connectClnt</text>
-</g>
-<!-- main&#45;&gt;connectClnt -->
-<g id="edge1" class="edge">
-<title>main&#45;&gt;connectClnt</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M321.6223,-1082.0307C303.5136,-1062.4318 278.0793,-1034.9044 259.6406,-1014.9484"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="252.7011,-1007.4378 262.7926,-1011.7288 256.0942,-1011.1102 259.4874,-1014.7826 259.4874,-1014.7826 259.4874,-1014.7826 256.0942,-1011.1102 256.1823,-1017.8365 252.7011,-1007.4378 252.7011,-1007.4378"/>
-<text text-anchor="middle" x="308.7235" y="-1051.1624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- runClnt -->
-<g id="node5" class="node">
-<title>runClnt</title>
-<polygon fill="none" stroke="#ffa500" points="380.5019,-989.3624 362.251,-1007.3624 325.749,-1007.3624 307.4981,-989.3624 325.749,-971.3624 362.251,-971.3624 380.5019,-989.3624"/>
-<text text-anchor="middle" x="344" y="-986.0624" font-family="arial" font-size="11.00" fill="#000000">runClnt</text>
-</g>
-<!-- main&#45;&gt;runClnt -->
-<g id="edge2" class="edge">
-<title>main&#45;&gt;runClnt</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M344,-1077.9547C344,-1059.6552 344,-1035.9253 344,-1017.631"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="344,-1007.5699 348.5001,-1017.5699 344,-1012.5699 344.0001,-1017.5699 344.0001,-1017.5699 344.0001,-1017.5699 344,-1012.5699 339.5001,-1017.57 344,-1007.5699 344,-1007.5699"/>
-<text text-anchor="middle" x="353.7235" y="-1051.1624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- aSock -->
-<g id="node2" class="node">
-<title>aSock</title>
-<polygon fill="none" stroke="#006400" points="287.8624,-1124.2499 160.1376,-1124.2499 160.1376,-1088.2499 287.8624,-1088.2499 287.8624,-1124.2499"/>
-<text text-anchor="middle" x="224" y="-1102.9499" font-family="arial" font-size="11.00" fill="#000000">user agent TCP socket</text>
-</g>
-<!-- aSock&#45;&gt;connectClnt -->
-<g id="edge3" class="edge">
-<title>aSock&#45;&gt;connectClnt</title>
-<path fill="none" stroke="#006400" d="M225.8487,-1088.2424C227.781,-1069.421 230.8399,-1039.6253 233.0952,-1017.6565"/>
-<polygon fill="#006400" stroke="#006400" points="234.1294,-1007.583 237.5845,-1017.9903 233.6188,-1012.5568 233.1081,-1017.5307 233.1081,-1017.5307 233.1081,-1017.5307 233.6188,-1012.5568 228.6316,-1017.0711 234.1294,-1007.583 234.1294,-1007.583"/>
-</g>
-<!-- connectionsStore -->
-<g id="node3" class="node">
-<title>connectionsStore</title>
-<path fill="none" stroke="#000000" d="M1048.7017,-580.4228C1048.7017,-583.7287 1023.2871,-586.414 992,-586.414 960.7129,-586.414 935.2983,-583.7287 935.2983,-580.4228 935.2983,-580.4228 935.2983,-526.5021 935.2983,-526.5021 935.2983,-523.1962 960.7129,-520.5109 992,-520.5109 1023.2871,-520.5109 1048.7017,-523.1962 1048.7017,-526.5021 1048.7017,-526.5021 1048.7017,-580.4228 1048.7017,-580.4228"/>
-<path fill="none" stroke="#000000" d="M1048.7017,-580.4228C1048.7017,-577.117 1023.2871,-574.4316 992,-574.4316 960.7129,-574.4316 935.2983,-577.117 935.2983,-580.4228"/>
-<text text-anchor="middle" x="992" y="-563.3624" font-family="arial" font-size="11.00" fill="#000000">duplex connections,</text>
-<text text-anchor="middle" x="992" y="-550.1624" font-family="arial" font-size="11.00" fill="#000000">SMP queues,</text>
-<text text-anchor="middle" x="992" y="-536.9624" font-family="arial" font-size="11.00" fill="#000000">recent messages</text>
-</g>
-<!-- uSock -->
-<g id="node6" class="node">
-<title>uSock</title>
-<polygon fill="none" stroke="#006400" points="169.5337,-900.5624 16.4663,-900.5624 16.4663,-864.5624 169.5337,-864.5624 169.5337,-900.5624"/>
-<text text-anchor="middle" x="93" y="-879.2624" font-family="arial" font-size="11.00" fill="#000000">user connection TCP socket</text>
-</g>
-<!-- connectClnt&#45;&gt;uSock -->
-<g id="edge23" class="edge">
-<title>connectClnt&#45;&gt;uSock</title>
-<path fill="none" stroke="#006400" stroke-dasharray="5,2" d="M198.6778,-978.637C182.4066,-972.8176 163.7253,-964.4984 148.985,-953.3624 133.1431,-941.3941 119.2685,-923.9297 109.2945,-909.3413"/>
-<polygon fill="#006400" stroke="#006400" points="103.6056,-900.7046 112.8644,-906.5804 106.356,-904.8801 109.1064,-909.0557 109.1064,-909.0557 109.1064,-909.0557 106.356,-904.8801 105.3483,-911.5311 103.6056,-900.7046 103.6056,-900.7046"/>
-<text text-anchor="middle" x="165.5075" y="-944.3624" font-family="arial" font-size="10.00" fill="#006400">connect</text>
-</g>
-<!-- uRcv -->
-<g id="node7" class="node">
-<title>uRcv</title>
-<polygon fill="none" stroke="#ffa500" points="214.0134,-553.4624 193.0067,-581.6377 150.9933,-581.6377 129.9866,-553.4624 150.9933,-525.2872 193.0067,-525.2872 214.0134,-553.4624"/>
-<text text-anchor="middle" x="172" y="-556.7624" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="172" y="-543.5624" font-family="arial" font-size="11.00" fill="#000000">receive</text>
-</g>
-<!-- connectClnt&#45;&gt;uRcv -->
-<g id="edge24" class="edge">
-<title>connectClnt&#45;&gt;uRcv</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M237.1238,-971.0203C239.9206,-916.7089 244.541,-752.4513 208,-623.3874 204.8674,-612.323 199.8997,-600.9707 194.6434,-590.7174"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="189.7794,-581.6499 198.472,-588.3349 192.143,-586.056 194.5065,-590.4621 194.5065,-590.4621 194.5065,-590.4621 192.143,-586.056 190.541,-592.5893 189.7794,-581.6499 189.7794,-581.6499"/>
-<text text-anchor="middle" x="247.7235" y="-837.5624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- uSnd -->
-<g id="node8" class="node">
-<title>uSnd</title>
-<polygon fill="none" stroke="#ffa500" points="111.5662,-553.4624 95.2831,-581.6377 62.7169,-581.6377 46.4338,-553.4624 62.7169,-525.2872 95.2831,-525.2872 111.5662,-553.4624"/>
-<text text-anchor="middle" x="79" y="-556.7624" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="79" y="-543.5624" font-family="arial" font-size="11.00" fill="#000000">send</text>
-</g>
-<!-- connectClnt&#45;&gt;uSnd -->
-<g id="edge25" class="edge">
-<title>connectClnt&#45;&gt;uSnd</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M232.6954,-971.3264C227.2453,-941.3316 216.1632,-879.2768 208,-826.5624 201.0253,-781.5225 212.2627,-655.5799 180,-623.3874 161.268,-604.6963 143.493,-629.327 121,-615.3874 111.1934,-609.31 103.1361,-599.9964 96.7947,-590.4234"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="91.4524,-581.6443 100.4951,-587.8476 94.0516,-585.9157 96.6509,-590.187 96.6509,-590.187 96.6509,-590.187 94.0516,-585.9157 92.8067,-592.5263 91.4524,-581.6443 91.4524,-581.6443"/>
-<text text-anchor="middle" x="219.7235" y="-837.5624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- uAgent -->
-<g id="node11" class="node">
-<title>uAgent</title>
-<polygon fill="none" stroke="#ffa500" points="715.5622,-670.4749 697.7811,-698.6502 662.2189,-698.6502 644.4378,-670.4749 662.2189,-642.2997 697.7811,-642.2997 715.5622,-670.4749"/>
-<text text-anchor="middle" x="680" y="-673.7749" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="680" y="-660.5749" font-family="arial" font-size="11.00" fill="#000000">agent</text>
-</g>
-<!-- runClnt&#45;&gt;uAgent -->
-<g id="edge26" class="edge">
-<title>runClnt&#45;&gt;uAgent</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M363.0275,-971.304C418.9032,-918.2741 582.8091,-762.7159 650.3686,-698.5972"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="657.7387,-691.6025 653.5831,-701.7505 654.112,-695.0444 650.4853,-698.4864 650.4853,-698.4864 650.4853,-698.4864 654.112,-695.0444 647.3875,-695.2224 657.7387,-691.6025 657.7387,-691.6025"/>
-<text text-anchor="middle" x="482.7235" y="-879.5624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- uProcess -->
-<g id="node12" class="node">
-<title>uProcess</title>
-<polygon fill="none" stroke="#ffa500" points="849.4801,-670.4749 822.24,-698.6502 767.76,-698.6502 740.5199,-670.4749 767.76,-642.2997 822.24,-642.2997 849.4801,-670.4749"/>
-<text text-anchor="middle" x="795" y="-673.7749" font-family="arial" font-size="11.00" fill="#000000">process</text>
-<text text-anchor="middle" x="795" y="-660.5749" font-family="arial" font-size="11.00" fill="#000000">responses</text>
-</g>
-<!-- runClnt&#45;&gt;uProcess -->
-<g id="edge27" class="edge">
-<title>runClnt&#45;&gt;uProcess</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M375.4171,-984.2599C446.9624,-971.0733 623.6511,-929.4235 725,-826.5624 757.4412,-793.6372 776.3095,-743.0546 786.1177,-708.4539"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="788.7618,-698.7069 790.4867,-709.5363 787.4527,-703.5325 786.1436,-708.3581 786.1436,-708.3581 786.1436,-708.3581 787.4527,-703.5325 781.8006,-707.1799 788.7618,-698.7069 788.7618,-698.7069"/>
-<text text-anchor="middle" x="686.7235" y="-879.5624" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- uSock&#45;&gt;uRcv -->
-<g id="edge4" class="edge">
-<title>uSock&#45;&gt;uRcv</title>
-<path fill="none" stroke="#006400" d="M97.3599,-864.3998C109.8154,-812.5125 145.7537,-662.8 162.808,-591.7545"/>
-<polygon fill="#006400" stroke="#006400" points="165.1822,-581.8642 167.2236,-592.6383 164.0151,-586.7261 162.848,-591.5879 162.848,-591.5879 162.848,-591.5879 164.0151,-586.7261 158.4723,-590.5375 165.1822,-581.8642 165.1822,-581.8642"/>
-</g>
-<!-- uInq -->
-<g id="node9" class="node">
-<title>uInq</title>
-<polygon fill="none" stroke="#000000" points="392.5723,-449.7766 347.4277,-449.7766 347.4277,-414.5733 392.5723,-414.5733 392.5723,-408.5733 410.5723,-432.175 392.5723,-455.7766 392.5723,-449.7766"/>
-<text text-anchor="middle" x="379" y="-442.075" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="379" y="-428.875" font-family="arial" font-size="11.00" fill="#000000">receive</text>
-<text text-anchor="middle" x="379" y="-415.675" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- uRcv&#45;&gt;uInq -->
-<g id="edge6" class="edge">
-<title>uRcv&#45;&gt;uInq</title>
-<path fill="none" stroke="#006400" d="M207.752,-544.8492C243.6388,-534.9021 299.1678,-515.8485 339,-485.175 346.5794,-479.3383 353.4481,-471.7165 359.2704,-464.0802"/>
-<polygon fill="#006400" stroke="#006400" points="365.1617,-455.8721 362.9865,-466.6201 362.2462,-459.9341 359.3307,-463.9961 359.3307,-463.9961 359.3307,-463.9961 362.2462,-459.9341 355.6749,-461.3722 365.1617,-455.8721 365.1617,-455.8721"/>
-</g>
-<!-- uOutq -->
-<g id="node10" class="node">
-<title>uOutq</title>
-<polygon fill="none" stroke="#000000" points="329.5723,-449.7766 284.4277,-449.7766 284.4277,-455.7766 266.4277,-432.175 284.4277,-408.5733 284.4277,-414.5733 329.5723,-414.5733 329.5723,-449.7766"/>
-<text text-anchor="middle" x="298" y="-442.075" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="298" y="-428.875" font-family="arial" font-size="11.00" fill="#000000">send</text>
-<text text-anchor="middle" x="298" y="-415.675" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- uRcv&#45;&gt;uOutq -->
-<g id="edge10" class="edge">
-<title>uRcv&#45;&gt;uOutq</title>
-<path fill="none" stroke="#00ff00" d="M196.5932,-529.7891C216.4531,-510.6719 244.5472,-483.6285 266.1304,-462.8527"/>
-<polygon fill="#00ff00" stroke="#00ff00" points="273.4688,-455.7886 269.3851,-465.9658 269.8666,-459.2562 266.2643,-462.7237 266.2643,-462.7237 266.2643,-462.7237 269.8666,-459.2562 263.1435,-459.4817 273.4688,-455.7886 273.4688,-455.7886"/>
-</g>
-<!-- uSnd&#45;&gt;uSock -->
-<g id="edge5" class="edge">
-<title>uSnd&#45;&gt;uSock</title>
-<path fill="none" stroke="#006400" d="M80.2082,-581.8642C82.8558,-644.1008 89.1434,-791.9036 91.7913,-854.15"/>
-<polygon fill="#006400" stroke="#006400" points="92.2274,-864.3998 87.3063,-854.6001 92.0148,-859.4043 91.8022,-854.4088 91.8022,-854.4088 91.8022,-854.4088 92.0148,-859.4043 96.2982,-854.2175 92.2274,-864.3998 92.2274,-864.3998"/>
-</g>
-<!-- uInq&#45;&gt;uAgent -->
-<g id="edge7" class="edge">
-<title>uInq&#45;&gt;uAgent</title>
-<path fill="none" stroke="#006400" d="M396.6501,-455.9955C404.2553,-465.5484 413.5612,-476.3588 423,-485.175 495.6201,-553.0045 593.7284,-617.3782 645.1887,-649.3958"/>
-<polygon fill="#006400" stroke="#006400" points="653.9378,-654.8067 643.0659,-653.374 649.6853,-652.1767 645.4329,-649.5468 645.4329,-649.5468 645.4329,-649.5468 649.6853,-652.1767 647.7999,-645.7196 653.9378,-654.8067 653.9378,-654.8067"/>
-</g>
-<!-- uOutq&#45;&gt;uSnd -->
-<g id="edge9" class="edge">
-<title>uOutq&#45;&gt;uSnd</title>
-<path fill="none" stroke="#006400" d="M266.3235,-441.7172C229.3231,-453.7931 167.2864,-476.9926 121,-509.375 115.6566,-513.1132 110.4497,-517.6098 105.6237,-522.2822"/>
-<polygon fill="#006400" stroke="#006400" points="98.3887,-529.6856 102.1596,-519.3885 101.8833,-526.1096 105.378,-522.5337 105.378,-522.5337 105.378,-522.5337 101.8833,-526.1096 108.5964,-525.6789 98.3887,-529.6856 98.3887,-529.6856"/>
-</g>
-<!-- uAgent&#45;&gt;connectionsStore -->
-<g id="edge21" class="edge">
-<title>uAgent&#45;&gt;connectionsStore</title>
-<path fill="none" stroke="#880000" d="M711.4852,-644.5965C717.9336,-640.4916 724.9231,-636.8075 732,-634.3874 772.2162,-620.6351 884.2913,-641.9405 923,-624.3874 937.8878,-617.6364 951.2411,-606.1048 962.1439,-594.2794"/>
-<polygon fill="#880000" stroke="#880000" points="703.07,-650.3759 708.7656,-641.0051 707.1916,-647.5452 711.3132,-644.7146 711.3132,-644.7146 711.3132,-644.7146 707.1916,-647.5452 713.8608,-648.424 703.07,-650.3759 703.07,-650.3759"/>
-<polygon fill="#880000" stroke="#880000" points="968.9461,-586.5133 965.7424,-597.0007 965.6517,-590.2745 962.3573,-594.0358 962.3573,-594.0358 962.3573,-594.0358 965.6517,-590.2745 958.9722,-591.0708 968.9461,-586.5133 968.9461,-586.5133"/>
-</g>
-<!-- uAgent&#45;&gt;uOutq -->
-<g id="edge11" class="edge">
-<title>uAgent&#45;&gt;uOutq</title>
-<path fill="none" stroke="#00ff00" d="M647.3434,-665.3697C591.4951,-656.2129 480.4257,-636.0193 447,-615.3874 386.1848,-577.8496 339.1057,-506.4848 315.2537,-464.7649"/>
-<polygon fill="#00ff00" stroke="#00ff00" points="310.2445,-455.8352 319.0616,-462.3552 312.6907,-460.196 315.1369,-464.5567 315.1369,-464.5567 315.1369,-464.5567 312.6907,-460.196 311.2123,-466.7583 310.2445,-455.8352 310.2445,-455.8352"/>
-</g>
-<!-- runClient -->
-<g id="node14" class="node">
-<title>runClient</title>
-<polygon fill="none" stroke="#ffa500" points="722.7244,-432.175 701.3622,-450.175 658.6378,-450.175 637.2756,-432.175 658.6378,-414.175 701.3622,-414.175 722.7244,-432.175"/>
-<text text-anchor="middle" x="680" y="-428.875" font-family="arial" font-size="11.00" fill="#000000">runClient</text>
-</g>
-<!-- uAgent&#45;&gt;runClient -->
-<g id="edge30" class="edge">
-<title>uAgent&#45;&gt;runClient</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M680,-642.203C680,-596.3198 680,-506.1699 680,-460.3495"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="680,-450.2297 684.5001,-460.2297 680,-455.2297 680.0001,-460.2297 680.0001,-460.2297 680.0001,-460.2297 680,-455.2297 675.5001,-460.2298 680,-450.2297 680,-450.2297"/>
-<text text-anchor="middle" x="688.3335" y="-550.4624" font-family="arial" font-size="10.00" fill="#ffa500">fork</text>
-</g>
-<!-- sOutq -->
-<g id="node15" class="node">
-<title>sOutq</title>
-<polygon fill="none" stroke="#000000" points="785.5723,-444.175 740.4277,-444.175 740.4277,-420.175 785.5723,-420.175 785.5723,-414.175 803.5723,-432.175 785.5723,-450.175 785.5723,-444.175"/>
-<text text-anchor="middle" x="772" y="-435.475" font-family="arial" font-size="11.00" fill="#000000">srv send</text>
-<text text-anchor="middle" x="772" y="-422.275" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- uAgent&#45;&gt;sOutq -->
-<g id="edge14" class="edge">
-<title>uAgent&#45;&gt;sOutq</title>
-<path fill="none" stroke="#0000ff" d="M691.5879,-642.1215C694.8569,-633.6035 698.2645,-624.1836 701,-615.3874 716.6229,-565.151 708.4801,-548.8178 729,-500.375 735.1504,-485.8551 744.2149,-470.9073 752.4376,-458.7199"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="758.2226,-450.3792 756.2211,-461.1608 755.373,-454.4877 752.5234,-458.5962 752.5234,-458.5962 752.5234,-458.5962 755.373,-454.4877 748.8257,-456.0316 758.2226,-450.3792 758.2226,-450.3792"/>
-</g>
-<!-- userState -->
-<g id="node19" class="node">
-<title>userState</title>
-<polygon fill="none" stroke="#000000" points="890.7837,-482.5758 887.7837,-486.5758 866.7837,-486.5758 863.7837,-482.5758 821.2163,-482.5758 821.2163,-381.7742 890.7837,-381.7742 890.7837,-482.5758"/>
-<text text-anchor="middle" x="856" y="-468.475" font-family="arial" font-size="11.00" fill="#000000">connected</text>
-<text text-anchor="middle" x="856" y="-455.275" font-family="arial" font-size="11.00" fill="#000000">servers,</text>
-<text text-anchor="middle" x="856" y="-442.075" font-family="arial" font-size="11.00" fill="#000000">subscribed</text>
-<text text-anchor="middle" x="856" y="-428.875" font-family="arial" font-size="11.00" fill="#000000">queues,</text>
-<text text-anchor="middle" x="856" y="-415.675" font-family="arial" font-size="11.00" fill="#000000">sent</text>
-<text text-anchor="middle" x="856" y="-402.475" font-family="arial" font-size="11.00" fill="#000000">commands</text>
-<text text-anchor="middle" x="856" y="-389.275" font-family="arial" font-size="11.00" fill="#000000">(STM)</text>
-</g>
-<!-- uAgent&#45;&gt;userState -->
-<g id="edge19" class="edge">
-<title>uAgent&#45;&gt;userState</title>
-<path fill="none" stroke="#ff8888" d="M705.4839,-635.9704C734.1546,-597.1508 781.1323,-533.5442 814.9848,-487.7086"/>
-<polygon fill="#ff8888" stroke="#ff8888" points="699.5075,-644.0622 701.8288,-633.3448 702.478,-640.0402 705.4485,-636.0182 705.4485,-636.0182 705.4485,-636.0182 702.478,-640.0402 709.0683,-638.6917 699.5075,-644.0622 699.5075,-644.0622"/>
-<polygon fill="#ff8888" stroke="#ff8888" points="820.9337,-479.654 818.6124,-490.3714 817.9632,-483.6759 814.9927,-487.6979 814.9927,-487.6979 814.9927,-487.6979 817.9632,-483.6759 811.3729,-485.0245 820.9337,-479.654 820.9337,-479.654"/>
-</g>
-<!-- uProcess&#45;&gt;connectionsStore -->
-<g id="edge22" class="edge">
-<title>uProcess&#45;&gt;connectionsStore</title>
-<path fill="none" stroke="#880000" d="M851.5097,-660.0083C892.5279,-651.4468 943.5859,-638.4864 960,-624.3874 968.7086,-616.9071 975.1618,-606.5771 979.8973,-596.1137"/>
-<polygon fill="#880000" stroke="#880000" points="841.5933,-662.0345 850.49,-655.6236 846.4921,-661.0335 851.3909,-660.0325 851.3909,-660.0325 851.3909,-660.0325 846.4921,-661.0335 852.2918,-664.4414 841.5933,-662.0345 841.5933,-662.0345"/>
-<polygon fill="#880000" stroke="#880000" points="983.7787,-586.5449 984.1898,-597.5031 981.8992,-591.1782 980.0198,-595.8116 980.0198,-595.8116 980.0198,-595.8116 981.8992,-591.1782 975.8498,-594.12 983.7787,-586.5449 983.7787,-586.5449"/>
-</g>
-<!-- uProcess&#45;&gt;uOutq -->
-<g id="edge8" class="edge">
-<title>uProcess&#45;&gt;uOutq</title>
-<path fill="none" stroke="#006400" d="M782.4156,-642.109C763.1961,-600.1829 726.1195,-524.9349 701,-509.375 632.2716,-466.8022 409.1254,-523.6095 338,-485.175 329.0427,-480.3347 321.505,-472.5258 315.4734,-464.3728"/>
-<polygon fill="#006400" stroke="#006400" points="309.7367,-455.862 319.0575,-461.639 312.5314,-460.0081 315.326,-464.1542 315.326,-464.1542 315.326,-464.1542 312.5314,-460.0081 311.5946,-466.6694 309.7367,-455.862 309.7367,-455.862"/>
-</g>
-<!-- uProcess&#45;&gt;sOutq -->
-<g id="edge15" class="edge">
-<title>uProcess&#45;&gt;sOutq</title>
-<path fill="none" stroke="#0000ff" d="M792.2713,-642.203C787.8428,-596.3198 779.1418,-506.1699 774.7193,-460.3495"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="773.7426,-450.2297 779.1826,-459.7511 774.223,-455.2066 774.7034,-460.1835 774.7034,-460.1835 774.7034,-460.1835 774.223,-455.2066 770.2242,-460.6158 773.7426,-450.2297 773.7426,-450.2297"/>
-</g>
-<!-- uProcess&#45;&gt;userState -->
-<g id="edge20" class="edge">
-<title>uProcess&#45;&gt;userState</title>
-<path fill="none" stroke="#ff8888" d="M804.7422,-632.4164C814.4107,-594.6461 829.3748,-536.188 840.6433,-492.1666"/>
-<polygon fill="#ff8888" stroke="#ff8888" points="802.237,-642.203 800.3575,-631.3994 803.477,-637.3592 804.717,-632.5154 804.717,-632.5154 804.717,-632.5154 803.477,-637.3592 809.0764,-633.6313 802.237,-642.203 802.237,-642.203"/>
-<polygon fill="#ff8888" stroke="#ff8888" points="843.1328,-482.4415 845.0123,-493.2451 841.8928,-487.2854 840.6529,-492.1292 840.6529,-492.1292 840.6529,-492.1292 841.8928,-487.2854 836.2934,-491.0132 843.1328,-482.4415 843.1328,-482.4415"/>
-</g>
-<!-- uRespq -->
-<g id="node13" class="node">
-<title>uRespq</title>
-<polygon fill="none" stroke="#000000" points="744.5723,-57.4017 699.4277,-57.4017 699.4277,-22.1983 744.5723,-22.1983 744.5723,-16.1983 762.5723,-39.8 744.5723,-63.4017 744.5723,-57.4017"/>
-<text text-anchor="middle" x="731" y="-49.7" font-family="arial" font-size="11.00" fill="#000000">user</text>
-<text text-anchor="middle" x="731" y="-36.5" font-family="arial" font-size="11.00" fill="#000000">SMP</text>
-<text text-anchor="middle" x="731" y="-23.3" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- uRespq&#45;&gt;uProcess -->
-<g id="edge29" class="edge">
-<title>uRespq&#45;&gt;uProcess</title>
-<path fill="none" stroke="#000000" d="M762.5896,-44.0035C813.9769,-51.7359 910,-70.3048 910,-101.1 910,-553.4624 910,-553.4624 910,-553.4624 910,-594.8589 872.935,-626.9659 840.89,-646.9888"/>
-<polygon fill="#000000" stroke="#000000" points="832.0197,-652.3135 838.2775,-643.3085 836.3067,-649.7401 840.5936,-647.1667 840.5936,-647.1667 840.5936,-647.1667 836.3067,-649.7401 842.9097,-651.0249 832.0197,-652.3135 832.0197,-652.3135"/>
-</g>
-<!-- sAgent -->
-<g id="node17" class="node">
-<title>sAgent</title>
-<polygon fill="none" stroke="#ffa500" points="656.0134,-172.6875 635.0067,-200.8627 592.9933,-200.8627 571.9866,-172.6875 592.9933,-144.5122 635.0067,-144.5122 656.0134,-172.6875"/>
-<text text-anchor="middle" x="614" y="-175.9875" font-family="arial" font-size="11.00" fill="#000000">server</text>
-<text text-anchor="middle" x="614" y="-162.7875" font-family="arial" font-size="11.00" fill="#000000">receive</text>
-</g>
-<!-- runClient&#45;&gt;sAgent -->
-<g id="edge12" class="edge">
-<title>runClient&#45;&gt;sAgent</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M663.5617,-414.1714C650.0082,-397.4105 633,-371.0774 633,-344.475 633,-344.475 633,-344.475 633,-257.475 633,-242.0587 629.9721,-225.439 626.3339,-211.0334"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="623.6113,-200.9841 630.5697,-209.4594 624.9188,-205.8101 626.2263,-210.6361 626.2263,-210.6361 626.2263,-210.6361 624.9188,-205.8101 621.8829,-211.8129 623.6113,-200.9841 623.6113,-200.9841"/>
-<text text-anchor="middle" x="642.7235" y="-297.975" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- sSnd -->
-<g id="node18" class="node">
-<title>sSnd</title>
-<polygon fill="none" stroke="#ffa500" points="750.0217,-172.6875 731.0109,-200.8627 692.9891,-200.8627 673.9783,-172.6875 692.9891,-144.5122 731.0109,-144.5122 750.0217,-172.6875"/>
-<text text-anchor="middle" x="712" y="-175.9875" font-family="arial" font-size="11.00" fill="#000000">server</text>
-<text text-anchor="middle" x="712" y="-162.7875" font-family="arial" font-size="11.00" fill="#000000">send</text>
-</g>
-<!-- runClient&#45;&gt;sSnd -->
-<g id="edge13" class="edge">
-<title>runClient&#45;&gt;sSnd</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M684.2567,-414.1504C688.048,-396.5013 693,-368.7944 693,-344.475 693,-344.475 693,-344.475 693,-257.475 693,-242.0587 696.0279,-225.439 699.6661,-211.0334"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="702.3887,-200.9841 704.1171,-211.8129 701.0812,-205.8101 699.7737,-210.6361 699.7737,-210.6361 699.7737,-210.6361 701.0812,-205.8101 695.4303,-209.4594 702.3887,-200.9841 702.3887,-200.9841"/>
-<text text-anchor="middle" x="702.7235" y="-297.975" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- sOutq&#45;&gt;sSnd -->
-<g id="edge16" class="edge">
-<title>sOutq&#45;&gt;sSnd</title>
-<path fill="none" stroke="#0000ff" d="M767.4159,-414.1688C763.3329,-396.5332 758,-368.8362 758,-344.475 758,-344.475 758,-344.475 758,-257.475 758,-238.8558 749.3238,-220.4171 739.5075,-205.5139"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="733.653,-197.1731 743.0814,-202.7728 736.5256,-201.2656 739.3981,-205.3581 739.3981,-205.3581 739.3981,-205.3581 736.5256,-201.2656 735.7149,-207.9434 733.653,-197.1731 733.653,-197.1731"/>
-</g>
-<!-- sSock -->
-<g id="node16" class="node">
-<title>sSock</title>
-<polygon fill="none" stroke="#0000ff" points="619.2006,-450.175 434.7994,-450.175 434.7994,-414.175 619.2006,-414.175 619.2006,-450.175"/>
-<text text-anchor="middle" x="527" y="-428.875" font-family="arial" font-size="11.00" fill="#000000">SMP client connection TCP socket</text>
-</g>
-<!-- sSock&#45;&gt;sAgent -->
-<g id="edge18" class="edge">
-<title>sSock&#45;&gt;sAgent</title>
-<path fill="none" stroke="#0000ff" d="M533.3267,-413.9457C538.8538,-396.3776 546,-368.9339 546,-344.475 546,-344.475 546,-344.475 546,-257.475 546,-234.2863 561.6699,-213.8223 577.9653,-198.8106"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="585.9492,-191.8912 581.3395,-201.8412 582.1708,-195.1659 578.3923,-198.4406 578.3923,-198.4406 578.3923,-198.4406 582.1708,-195.1659 575.4451,-195.04 585.9492,-191.8912 585.9492,-191.8912"/>
-</g>
-<!-- sAgent&#45;&gt;uRespq -->
-<g id="edge28" class="edge">
-<title>sAgent&#45;&gt;uRespq</title>
-<path fill="none" stroke="#000000" d="M636.8365,-146.75C655.8728,-125.1288 683.0563,-94.254 703.3269,-71.2308"/>
-<polygon fill="#000000" stroke="#000000" points="710.1839,-63.4427 706.9532,-73.9219 706.8798,-67.1955 703.5757,-70.9482 703.5757,-70.9482 703.5757,-70.9482 706.8798,-67.1955 700.1982,-67.9746 710.1839,-63.4427 710.1839,-63.4427"/>
-</g>
-<!-- sSnd&#45;&gt;sSock -->
-<g id="edge17" class="edge">
-<title>sSnd&#45;&gt;sSock</title>
-<path fill="none" stroke="#0000ff" d="M693.7955,-200.8992C685.9738,-211.2174 676.0767,-222.2439 665,-229.975 634.5137,-251.2531 586,-220.2974 586,-257.475 586,-344.475 586,-344.475 586,-344.475 586,-368.2876 570.8403,-390.4932 555.8897,-406.6024"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="548.6344,-414.0012 552.4229,-403.7105 552.1352,-410.4312 555.6359,-406.8612 555.6359,-406.8612 555.6359,-406.8612 552.1352,-410.4312 558.8489,-410.0118 548.6344,-414.0012 548.6344,-414.0012"/>
-</g>
-</g>
-</svg>
diff --git a/source/design/server.gv b/source/design/server.gv
deleted file mode 100644
index e178363..0000000
--- a/source/design/server.gv
+++ /dev/null
@@ -1,57 +0,0 @@
-digraph SMPServer {
-  graph [fontname=arial]
-  node [fontname=arial fontsize=11 shape=box]
-  edge [fontname=arial fontsize=10 arrowhead=open arrowtail=open]
-
-  subgraph clusterPersistence {
-    label="persistence (STM)"
-    msgQueues [shape=cylinder label="Message\nqueues"]
-    queueStore [shape=cylinder label="SMP queue\nrecords"]
-  }
-
-  subgraph clusterServer {
-    label="server threads" 
-    main [shape=hexagon color=orange label="main\nthread"]
-    ss [label="server TCP socket" color=blue]
-    subgraph clusterThreads {
-      label="" 
-      node [shape=hexagon color=orange]
-      runClient [label="runClient\nthread"]
-      server [label="server\nthread"]
-    }
-    subscribedQ [shape="larrow" label="subscribed\nTBQueue"]
-    main -> {server runClient} [style=dashed label=race color=orange fontcolor=orange]
-    ss -> runClient [color=blue]
-    subscribedQ -> server
-  }
-
-  subgraph clusterConnection {
-    label="1 group per client connection"
-    cs [label="client connection TCP socket" color=blue]
-
-    subgraph clusterThreads {
-      node [shape=hexagon, color=orange]
-      label=""
-      receive [label="receive\nthread"]
-      client [label="client\nthread"]
-      send [label="send\nthread"]
-    }
-
-    runClient -> cs [style=dashed label="connect" color=blue fontcolor=blue]
-    runClient -> {client receive send} [style=dashed label=race color=orange fontcolor=orange]
-    server -> inq [label="END"]
-
-    subscriber [shape=hexagon color=orange label="subscriber\nthread"]
-
-    inq [shape=rarrow label="receive\nTBQueue"]
-    outq [shape=larrow label="send\nTBQueue"]
-    cs -> receive -> inq -> client [color=blue]
-    msgQueues -> subscriber [label="Message" color=green fontcolor=green]
-    subscriber -> outq [label="MSG" color=blue fontcolor=blue constraint=false]
-    client -> queueStore [dir=both]
-    client -> subscriber [style=dashed label="1 fork per\nSMP queue" color=orange]
-    client -> msgQueues [dir="both" label="SEND,\nSUB,\nACK" color=green]
-    client -> outq -> send -> cs [color=blue]
-    client -> subscribedQ [label="(rId, Client)"]
-  }
-}
diff --git a/source/design/server.svg b/source/design/server.svg
deleted file mode 100644
index ba90fff..0000000
--- a/source/design/server.svg
+++ /dev/null
@@ -1,277 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
- "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
-<!-- Generated by graphviz version 2.40.1 (20161225.0304)
- -->
-<!-- Title: SMPServer Pages: 1 -->
-<svg width="855pt" height="677pt"
- viewBox="0.00 0.00 855.00 677.40" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
-<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 673.3999)">
-<title>SMPServer</title>
-<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-673.3999 851,-673.3999 851,4 -4,4"/>
-<g id="clust1" class="cluster">
-<title>clusterPersistence</title>
-<polygon fill="none" stroke="#000000" points="671,-112.175 671,-200.275 839,-200.275 839,-112.175 671,-112.175"/>
-<text text-anchor="middle" x="755" y="-183.675" font-family="arial" font-size="14.00" fill="#000000">persistence (STM)</text>
-</g>
-<g id="clust2" class="cluster">
-<title>clusterServer</title>
-<polygon fill="none" stroke="#000000" points="8,-356.4499 8,-661.3999 314,-661.3999 314,-356.4499 8,-356.4499"/>
-<text text-anchor="middle" x="161" y="-644.7999" font-family="arial" font-size="14.00" fill="#000000">server threads</text>
-</g>
-<g id="clust3" class="cluster">
-<title>clusterThreads</title>
-<polygon fill="none" stroke="#000000" points="96,-364.4499 96,-436.6249 306,-436.6249 306,-364.4499 96,-364.4499"/>
-</g>
-<g id="clust5" class="cluster">
-<title>clusterConnection</title>
-<polygon fill="none" stroke="#000000" points="322,-8 322,-545.4249 663,-545.4249 663,-8 322,-8"/>
-<text text-anchor="middle" x="492.5" y="-528.8249" font-family="arial" font-size="14.00" fill="#000000">1 group per client connection</text>
-</g>
-<g id="clust6" class="cluster">
-<title>clusterThreads</title>
-<polygon fill="none" stroke="#000000" points="330,-254.275 330,-326.4499 621,-326.4499 621,-254.275 330,-254.275"/>
-</g>
-<!-- msgQueues -->
-<g id="node1" class="node">
-<title>msgQueues</title>
-<path fill="none" stroke="#000000" d="M831.1227,-163.2985C831.1227,-165.6863 817.6212,-167.6259 801,-167.6259 784.3788,-167.6259 770.8773,-165.6863 770.8773,-163.2985 770.8773,-163.2985 770.8773,-124.3515 770.8773,-124.3515 770.8773,-121.9636 784.3788,-120.024 801,-120.024 817.6212,-120.024 831.1227,-121.9636 831.1227,-124.3515 831.1227,-124.3515 831.1227,-163.2985 831.1227,-163.2985"/>
-<path fill="none" stroke="#000000" d="M831.1227,-163.2985C831.1227,-160.9107 817.6212,-158.971 801,-158.971 784.3788,-158.971 770.8773,-160.9107 770.8773,-163.2985"/>
-<text text-anchor="middle" x="801" y="-147.125" font-family="arial" font-size="11.00" fill="#000000">Message</text>
-<text text-anchor="middle" x="801" y="-133.925" font-family="arial" font-size="11.00" fill="#000000">queues</text>
-</g>
-<!-- subscriber -->
-<g id="node13" class="node">
-<title>subscriber</title>
-<polygon fill="none" stroke="#ffa500" points="655.4603,-44.0875 628.2302,-72.2627 573.7698,-72.2627 546.5397,-44.0875 573.7698,-15.9122 628.2302,-15.9122 655.4603,-44.0875"/>
-<text text-anchor="middle" x="601" y="-47.3875" font-family="arial" font-size="11.00" fill="#000000">subscriber</text>
-<text text-anchor="middle" x="601" y="-34.1875" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- msgQueues&#45;&gt;subscriber -->
-<g id="edge13" class="edge">
-<title>msgQueues&#45;&gt;subscriber</title>
-<path fill="none" stroke="#00ff00" d="M775.3099,-121.3134C771.01,-118.0388 766.485,-114.869 762,-112.175 727.1066,-91.2154 684.5821,-73.5284 652.0009,-61.4383"/>
-<polygon fill="#00ff00" stroke="#00ff00" points="642.2282,-57.8684 653.1652,-57.0728 646.9247,-59.584 651.6211,-61.2996 651.6211,-61.2996 651.6211,-61.2996 646.9247,-59.584 650.0771,-65.5264 642.2282,-57.8684 642.2282,-57.8684"/>
-<text text-anchor="middle" x="761.2825" y="-93.175" font-family="arial" font-size="10.00" fill="#00ff00">Message</text>
-</g>
-<!-- queueStore -->
-<g id="node2" class="node">
-<title>queueStore</title>
-<path fill="none" stroke="#000000" d="M752.9666,-163.2985C752.9666,-165.6863 736.3976,-167.6259 716,-167.6259 695.6024,-167.6259 679.0334,-165.6863 679.0334,-163.2985 679.0334,-163.2985 679.0334,-124.3515 679.0334,-124.3515 679.0334,-121.9636 695.6024,-120.024 716,-120.024 736.3976,-120.024 752.9666,-121.9636 752.9666,-124.3515 752.9666,-124.3515 752.9666,-163.2985 752.9666,-163.2985"/>
-<path fill="none" stroke="#000000" d="M752.9666,-163.2985C752.9666,-160.9107 736.3976,-158.971 716,-158.971 695.6024,-158.971 679.0334,-160.9107 679.0334,-163.2985"/>
-<text text-anchor="middle" x="716" y="-147.125" font-family="arial" font-size="11.00" fill="#000000">SMP queue</text>
-<text text-anchor="middle" x="716" y="-133.925" font-family="arial" font-size="11.00" fill="#000000">records</text>
-</g>
-<!-- main -->
-<g id="node3" class="node">
-<title>main</title>
-<polygon fill="none" stroke="#ffa500" points="93.542,-600.5124 74.271,-628.6876 35.729,-628.6876 16.458,-600.5124 35.729,-572.3371 74.271,-572.3371 93.542,-600.5124"/>
-<text text-anchor="middle" x="55" y="-603.8124" font-family="arial" font-size="11.00" fill="#000000">main</text>
-<text text-anchor="middle" x="55" y="-590.6124" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- runClient -->
-<g id="node5" class="node">
-<title>runClient</title>
-<polygon fill="none" stroke="#ffa500" points="297.9814,-400.5374 273.4907,-428.7127 224.5093,-428.7127 200.0186,-400.5374 224.5093,-372.3622 273.4907,-372.3622 297.9814,-400.5374"/>
-<text text-anchor="middle" x="249" y="-403.8374" font-family="arial" font-size="11.00" fill="#000000">runClient</text>
-<text text-anchor="middle" x="249" y="-390.6374" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- main&#45;&gt;runClient -->
-<g id="edge1" class="edge">
-<title>main&#45;&gt;runClient</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M82.4126,-583.8786C98.0501,-573.7433 117.5501,-559.9715 133,-545.4249 168.3831,-512.1106 202.3371,-467.7613 224.2648,-436.9423"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="230.1218,-428.629 228.041,-439.3957 227.2421,-432.7164 224.3623,-436.8039 224.3623,-436.8039 224.3623,-436.8039 227.2421,-432.7164 220.6836,-434.2121 230.1218,-428.629 230.1218,-428.629"/>
-<text text-anchor="middle" x="203.7235" y="-491.6249" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- server -->
-<g id="node6" class="node">
-<title>server</title>
-<polygon fill="none" stroke="#ffa500" points="181.542,-400.5374 162.271,-428.7127 123.729,-428.7127 104.458,-400.5374 123.729,-372.3622 162.271,-372.3622 181.542,-400.5374"/>
-<text text-anchor="middle" x="143" y="-403.8374" font-family="arial" font-size="11.00" fill="#000000">server</text>
-<text text-anchor="middle" x="143" y="-390.6374" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- main&#45;&gt;server -->
-<g id="edge2" class="edge">
-<title>main&#45;&gt;server</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M67.4216,-572.285C82.8393,-537.2492 109.19,-477.3686 126.3476,-438.379"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="130.4994,-428.9443 130.5904,-439.9098 128.4855,-433.5208 126.4715,-438.0972 126.4715,-438.0972 126.4715,-438.0972 128.4855,-433.5208 122.3527,-436.2847 130.4994,-428.9443 130.4994,-428.9443"/>
-<text text-anchor="middle" x="119.7235" y="-491.6249" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- ss -->
-<g id="node4" class="node">
-<title>ss</title>
-<polygon fill="none" stroke="#0000ff" points="218.4518,-618.5124 111.5482,-618.5124 111.5482,-582.5124 218.4518,-582.5124 218.4518,-618.5124"/>
-<text text-anchor="middle" x="165" y="-597.2124" font-family="arial" font-size="11.00" fill="#000000">server TCP socket</text>
-</g>
-<!-- ss&#45;&gt;runClient -->
-<g id="edge3" class="edge">
-<title>ss&#45;&gt;runClient</title>
-<path fill="none" stroke="#0000ff" d="M190.6135,-582.3228C202.2946,-572.6811 215.2249,-559.8501 223,-545.4249 240.8424,-512.3216 246.7634,-469.4031 248.5729,-438.8905"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="249.0542,-428.6517 253.0796,-438.852 248.8194,-433.6461 248.5845,-438.6406 248.5845,-438.6406 248.5845,-438.6406 248.8194,-433.6461 244.0895,-438.4293 249.0542,-428.6517 249.0542,-428.6517"/>
-</g>
-<!-- cs -->
-<g id="node8" class="node">
-<title>cs</title>
-<polygon fill="none" stroke="#0000ff" points="552.8099,-512.6249 395.1901,-512.6249 395.1901,-476.6249 552.8099,-476.6249 552.8099,-512.6249"/>
-<text text-anchor="middle" x="474" y="-491.3249" font-family="arial" font-size="11.00" fill="#000000">client connection TCP socket</text>
-</g>
-<!-- runClient&#45;&gt;cs -->
-<g id="edge5" class="edge">
-<title>runClient&#45;&gt;cs</title>
-<path fill="none" stroke="#0000ff" stroke-dasharray="5,2" d="M272.5995,-428.901C283.0081,-439.7165 296.0409,-451.2129 309.985,-458.6249 332.9376,-470.8253 359.7984,-478.8942 385.0605,-484.2295"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="395.0232,-486.2129 384.337,-488.6737 390.1195,-485.2366 385.2157,-484.2603 385.2157,-484.2603 385.2157,-484.2603 390.1195,-485.2366 386.0944,-479.8469 395.0232,-486.2129 395.0232,-486.2129"/>
-<text text-anchor="middle" x="326.5075" y="-449.6249" font-family="arial" font-size="10.00" fill="#0000ff">connect</text>
-</g>
-<!-- receive -->
-<g id="node9" class="node">
-<title>receive</title>
-<polygon fill="none" stroke="#ffa500" points="422.0134,-290.3624 401.0067,-318.5377 358.9933,-318.5377 337.9866,-290.3624 358.9933,-262.1872 401.0067,-262.1872 422.0134,-290.3624"/>
-<text text-anchor="middle" x="380" y="-293.6624" font-family="arial" font-size="11.00" fill="#000000">receive</text>
-<text text-anchor="middle" x="380" y="-280.4624" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- runClient&#45;&gt;receive -->
-<g id="edge6" class="edge">
-<title>runClient&#45;&gt;receive</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M242.4559,-372.1449C241.3023,-360.1277 242.3132,-346.5931 249.553,-336.4499 259.7013,-322.232 300.429,-309.2925 333.711,-300.7686"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="343.7588,-298.2684 335.1413,-305.05 338.9067,-299.4758 334.0547,-300.6831 334.0547,-300.6831 334.0547,-300.6831 338.9067,-299.4758 332.9681,-296.3163 343.7588,-298.2684 343.7588,-298.2684"/>
-<text text-anchor="middle" x="258.7235" y="-339.4499" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- client -->
-<g id="node10" class="node">
-<title>client</title>
-<polygon fill="none" stroke="#ffa500" points="612.542,-290.3624 593.271,-318.5377 554.729,-318.5377 535.458,-290.3624 554.729,-262.1872 593.271,-262.1872 612.542,-290.3624"/>
-<text text-anchor="middle" x="574" y="-293.6624" font-family="arial" font-size="11.00" fill="#000000">client</text>
-<text text-anchor="middle" x="574" y="-280.4624" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- runClient&#45;&gt;client -->
-<g id="edge7" class="edge">
-<title>runClient&#45;&gt;client</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M277.06,-376.3985C296.597,-360.1633 321.2685,-340.9357 333.553,-336.4499 414.4215,-306.9205 446.2239,-356.2313 527,-326.4499 532.1882,-324.5371 537.2696,-321.8366 542.0605,-318.7636"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="550.3305,-312.9195 544.7608,-322.3656 546.2472,-315.8051 542.1638,-318.6906 542.1638,-318.6906 542.1638,-318.6906 546.2472,-315.8051 539.5668,-315.0156 550.3305,-312.9195 550.3305,-312.9195"/>
-<text text-anchor="middle" x="342.7235" y="-339.4499" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- send -->
-<g id="node11" class="node">
-<title>send</title>
-<polygon fill="none" stroke="#ffa500" points="517.542,-290.3624 498.271,-318.5377 459.729,-318.5377 440.458,-290.3624 459.729,-262.1872 498.271,-262.1872 517.542,-290.3624"/>
-<text text-anchor="middle" x="479" y="-293.6624" font-family="arial" font-size="11.00" fill="#000000">send</text>
-<text text-anchor="middle" x="479" y="-280.4624" font-family="arial" font-size="11.00" fill="#000000">thread</text>
-</g>
-<!-- runClient&#45;&gt;send -->
-<g id="edge8" class="edge">
-<title>runClient&#45;&gt;send</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M260.5478,-372.3313C267.4946,-359.1125 277.7098,-344.526 291.553,-336.4499 318.388,-320.7945 401.9033,-337.3399 431,-326.4499 436.5046,-324.3897 441.9126,-321.4869 446.9995,-318.2123"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="455.2178,-312.4339 449.6258,-321.8669 451.1276,-315.3098 447.0375,-318.1857 447.0375,-318.1857 447.0375,-318.1857 451.1276,-315.3098 444.4492,-314.5046 455.2178,-312.4339 455.2178,-312.4339"/>
-<text text-anchor="middle" x="300.7235" y="-339.4499" font-family="arial" font-size="10.00" fill="#ffa500">race</text>
-</g>
-<!-- inq -->
-<g id="node12" class="node">
-<title>inq</title>
-<polygon fill="none" stroke="#000000" points="375.5723,-56.0875 330.4277,-56.0875 330.4277,-32.0875 375.5723,-32.0875 375.5723,-26.0875 393.5723,-44.0875 375.5723,-62.0875 375.5723,-56.0875"/>
-<text text-anchor="middle" x="362" y="-47.3875" font-family="arial" font-size="11.00" fill="#000000">receive</text>
-<text text-anchor="middle" x="362" y="-34.1875" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- server&#45;&gt;inq -->
-<g id="edge9" class="edge">
-<title>server&#45;&gt;inq</title>
-<path fill="none" stroke="#000000" d="M160.3676,-372.2694C201.6259,-305.1164 305.0826,-136.7276 345.4771,-70.9806"/>
-<polygon fill="#000000" stroke="#000000" points="350.7453,-62.4059 349.3446,-73.2819 348.1279,-66.6661 345.5104,-70.9262 345.5104,-70.9262 345.5104,-70.9262 348.1279,-66.6661 341.6763,-68.5705 350.7453,-62.4059 350.7453,-62.4059"/>
-<text text-anchor="middle" x="270.5535" y="-223.275" font-family="arial" font-size="10.00" fill="#000000">END</text>
-</g>
-<!-- subscribedQ -->
-<g id="node7" class="node">
-<title>subscribedQ</title>
-<polygon fill="none" stroke="#000000" points="305.6775,-612.5124 254.3225,-612.5124 254.3225,-618.5124 236.3225,-600.5124 254.3225,-582.5124 254.3225,-588.5124 305.6775,-588.5124 305.6775,-612.5124"/>
-<text text-anchor="middle" x="271" y="-603.8124" font-family="arial" font-size="11.00" fill="#000000">subscribed</text>
-<text text-anchor="middle" x="271" y="-590.6124" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- subscribedQ&#45;&gt;server -->
-<g id="edge4" class="edge">
-<title>subscribedQ&#45;&gt;server</title>
-<path fill="none" stroke="#000000" d="M266.5979,-582.0921C259.9663,-556.7857 245.7163,-510.5487 223,-476.6249 210.3763,-457.773 192.3233,-440.0878 176.5604,-426.5205"/>
-<polygon fill="#000000" stroke="#000000" points="168.5671,-419.8168 179.1209,-422.7948 172.3982,-423.0298 176.2292,-426.2428 176.2292,-426.2428 176.2292,-426.2428 172.3982,-423.0298 173.3375,-429.6907 168.5671,-419.8168 168.5671,-419.8168"/>
-</g>
-<!-- cs&#45;&gt;receive -->
-<g id="edge10" class="edge">
-<title>cs&#45;&gt;receive</title>
-<path fill="none" stroke="#0000ff" d="M465.6581,-476.498C450.379,-443.2963 417.6111,-372.0915 397.3247,-328.0092"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="393.0726,-318.7693 401.3411,-325.9723 395.1629,-323.3114 397.2532,-327.8535 397.2532,-327.8535 397.2532,-327.8535 395.1629,-323.3114 393.1653,-329.7348 393.0726,-318.7693 393.0726,-318.7693"/>
-</g>
-<!-- receive&#45;&gt;inq -->
-<g id="edge11" class="edge">
-<title>receive&#45;&gt;inq</title>
-<path fill="none" stroke="#0000ff" d="M377.9352,-262.1116C374.4741,-214.757 367.5409,-119.8979 364.0738,-72.4613"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="363.33,-62.2842 368.547,-71.9295 363.6945,-67.2709 364.059,-72.2576 364.059,-72.2576 364.059,-72.2576 363.6945,-67.2709 359.571,-72.5856 363.33,-62.2842 363.33,-62.2842"/>
-</g>
-<!-- client&#45;&gt;msgQueues -->
-<g id="edge17" class="edge">
-<title>client&#45;&gt;msgQueues</title>
-<path fill="none" stroke="#00ff00" d="M615.7447,-277.4263C656.3868,-263.3055 718.2574,-237.6106 762,-200.275 769.9504,-193.4891 777.0327,-184.7227 782.9078,-176.1309"/>
-<polygon fill="#00ff00" stroke="#00ff00" points="606.1466,-280.6832 614.1703,-273.2085 610.8815,-279.0765 615.6163,-277.4699 615.6163,-277.4699 615.6163,-277.4699 610.8815,-279.0765 617.0623,-281.7312 606.1466,-280.6832 606.1466,-280.6832"/>
-<polygon fill="#00ff00" stroke="#00ff00" points="788.3681,-167.6771 786.7225,-178.5188 785.6553,-171.8771 782.9424,-176.0772 782.9424,-176.0772 782.9424,-176.0772 785.6553,-171.8771 779.1624,-173.6357 788.3681,-167.6771 788.3681,-167.6771"/>
-<text text-anchor="middle" x="763.2775" y="-235.275" font-family="arial" font-size="10.00" fill="#000000">SEND,</text>
-<text text-anchor="middle" x="763.2775" y="-223.275" font-family="arial" font-size="10.00" fill="#000000">SUB,</text>
-<text text-anchor="middle" x="763.2775" y="-211.275" font-family="arial" font-size="10.00" fill="#000000">ACK</text>
-</g>
-<!-- client&#45;&gt;queueStore -->
-<g id="edge15" class="edge">
-<title>client&#45;&gt;queueStore</title>
-<path fill="none" stroke="#000000" d="M609.8863,-268.3247C620.1282,-261.2548 630.9539,-252.9826 640,-244.275 661.2301,-223.8393 681.1673,-197.0861 695.2906,-176.3279"/>
-<polygon fill="#000000" stroke="#000000" points="601.4722,-273.9638 607.2738,-264.6583 605.6257,-271.1801 609.7791,-268.3964 609.7791,-268.3964 609.7791,-268.3964 605.6257,-271.1801 612.2844,-272.1346 601.4722,-273.9638 601.4722,-273.9638"/>
-<polygon fill="#000000" stroke="#000000" points="700.9743,-167.8345 699.1526,-178.648 698.1935,-171.9899 695.4127,-176.1453 695.4127,-176.1453 695.4127,-176.1453 698.1935,-171.9899 691.6729,-173.6426 700.9743,-167.8345 700.9743,-167.8345"/>
-</g>
-<!-- client&#45;&gt;subscribedQ -->
-<g id="edge21" class="edge">
-<title>client&#45;&gt;subscribedQ</title>
-<path fill="none" stroke="#000000" d="M548.6699,-309.8896C541.6619,-315.2708 534.0458,-321.0992 527,-326.4499 456.1732,-380.2374 427.111,-381.0795 367,-446.6249 330.9316,-485.954 300.5471,-540.6501 284.1272,-573.1325"/>
-<polygon fill="#000000" stroke="#000000" points="279.4889,-582.4585 279.9129,-571.5008 281.7155,-577.9816 283.9421,-573.5048 283.9421,-573.5048 283.9421,-573.5048 281.7155,-577.9816 287.9713,-575.5087 279.4889,-582.4585 279.4889,-582.4585"/>
-<text text-anchor="middle" x="391.7185" y="-449.6249" font-family="arial" font-size="10.00" fill="#000000">(rId, Client)</text>
-</g>
-<!-- client&#45;&gt;subscriber -->
-<g id="edge16" class="edge">
-<title>client&#45;&gt;subscriber</title>
-<path fill="none" stroke="#ffa500" stroke-dasharray="5,2" d="M577.0972,-262.1116C581.9467,-217.8786 591.3402,-132.1977 596.796,-82.4333"/>
-<polygon fill="#ffa500" stroke="#ffa500" points="597.8974,-72.3872 601.2807,-82.818 597.3525,-77.3574 596.8075,-82.3276 596.8075,-82.3276 596.8075,-82.3276 597.3525,-77.3574 592.3343,-81.8371 597.8974,-72.3872 597.8974,-72.3872"/>
-<text text-anchor="middle" x="619.1205" y="-146.825" font-family="arial" font-size="10.00" fill="#000000">1 fork per</text>
-<text text-anchor="middle" x="619.1205" y="-134.825" font-family="arial" font-size="10.00" fill="#000000">SMP queue</text>
-</g>
-<!-- outq -->
-<g id="node14" class="node">
-<title>outq</title>
-<polygon fill="none" stroke="#000000" points="474.5723,-56.0875 429.4277,-56.0875 429.4277,-62.0875 411.4277,-44.0875 429.4277,-26.0875 429.4277,-32.0875 474.5723,-32.0875 474.5723,-56.0875"/>
-<text text-anchor="middle" x="443" y="-47.3875" font-family="arial" font-size="11.00" fill="#000000">send</text>
-<text text-anchor="middle" x="443" y="-34.1875" font-family="arial" font-size="11.00" fill="#000000">TBQueue</text>
-</g>
-<!-- client&#45;&gt;outq -->
-<g id="edge18" class="edge">
-<title>client&#45;&gt;outq</title>
-<path fill="none" stroke="#0000ff" d="M569.0363,-262.148C560.7382,-221.1225 540.9769,-144.0325 502,-90.175 496.236,-82.2103 488.7272,-74.9287 481.0081,-68.6219"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="472.622,-62.1747 483.2926,-64.7021 476.5859,-65.2222 480.5499,-68.2697 480.5499,-68.2697 480.5499,-68.2697 476.5859,-65.2222 477.8071,-71.8372 472.622,-62.1747 472.622,-62.1747"/>
-</g>
-<!-- send&#45;&gt;cs -->
-<g id="edge20" class="edge">
-<title>send&#45;&gt;cs</title>
-<path fill="none" stroke="#0000ff" d="M478.3046,-318.7693C477.35,-357.7707 475.6436,-427.4808 474.6911,-466.3911"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="474.4437,-476.498 470.1899,-466.3908 474.5661,-471.4995 474.6885,-466.501 474.6885,-466.501 474.6885,-466.501 474.5661,-471.4995 479.1872,-466.6111 474.4437,-476.498 474.4437,-476.498"/>
-</g>
-<!-- inq&#45;&gt;client -->
-<g id="edge12" class="edge">
-<title>inq&#45;&gt;client</title>
-<path fill="none" stroke="#0000ff" d="M377.6198,-62.2326C413.1933,-103.5575 500.6514,-205.1552 545.8859,-257.703"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="552.5056,-265.393 542.5712,-260.75 549.2436,-261.6036 545.9816,-257.8142 545.9816,-257.8142 545.9816,-257.8142 549.2436,-261.6036 549.3921,-254.8784 552.5056,-265.393 552.5056,-265.393"/>
-</g>
-<!-- subscriber&#45;&gt;outq -->
-<g id="edge14" class="edge">
-<title>subscriber&#45;&gt;outq</title>
-<path fill="none" stroke="#0000ff" d="M546.4214,-44.0875C526.1863,-44.0875 503.5804,-44.0875 484.6766,-44.0875"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="474.5939,-44.0875 484.594,-39.5876 479.5939,-44.0875 484.5939,-44.0876 484.5939,-44.0876 484.5939,-44.0876 479.5939,-44.0875 484.5939,-48.5876 474.5939,-44.0875 474.5939,-44.0875"/>
-<text text-anchor="middle" x="510.528" y="-50.0875" font-family="arial" font-size="10.00" fill="#0000ff">MSG</text>
-</g>
-<!-- outq&#45;&gt;send -->
-<g id="edge19" class="edge">
-<title>outq&#45;&gt;send</title>
-<path fill="none" stroke="#0000ff" d="M445.66,-62.2842C451.4907,-102.1724 465.5041,-198.0375 473.381,-251.9232"/>
-<polygon fill="#0000ff" stroke="#0000ff" points="474.8703,-262.1116 468.9712,-252.8677 474.1471,-257.1642 473.4239,-252.2167 473.4239,-252.2167 473.4239,-252.2167 474.1471,-257.1642 477.8765,-251.5658 474.8703,-262.1116 474.8703,-262.1116"/>
-</g>
-</g>
-</svg>
diff --git a/source/download.Dockerfile b/source/download.Dockerfile
deleted file mode 100644
index 48344c3..0000000
--- a/source/download.Dockerfile
+++ /dev/null
@@ -1,20 +0,0 @@
-FROM ubuntu:focal
-
-# Install curl
-RUN apt-get update && apt-get install -y curl
-
-# Download latest smp-server release and assign executable permission
-RUN curl -L https://github.com/simplex-chat/simplexmq/releases/latest/download/smp-server-ubuntu-20_04-x86-64 -o /usr/bin/smp-server && \
-	chmod +x /usr/bin/smp-server
-
-# Copy our helper script
-COPY ./scripts/docker/entrypoint /usr/bin/entrypoint
-
-# Open smp-server listening port
-EXPOSE 5223
-
-# SimpleX requires using SIGINT to correctly preserve undelivered messages and restore them on restart
-STOPSIGNAL SIGINT
-
-# Finally, execute helper script
-ENTRYPOINT [ "/usr/bin/entrypoint" ]
diff --git a/source/img/digitalocean.png b/source/img/digitalocean.png
deleted file mode 100644
index 1eada09..0000000
Binary files a/source/img/digitalocean.png and /dev/null differ
diff --git a/source/img/linode.svg b/source/img/linode.svg
deleted file mode 100644
index b99cd41..0000000
--- a/source/img/linode.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 506.94 131.5"><path d="m109.65 58.21-18.21-10.07-15.37 9.38-.19 9.59-7.47-4.92-10.16 6.19-.44-10.48-10.48-7 10-5.17c-.08 0 0 1-1.48-34.34l-23.65-11.39-32.2 10 7.19 34.63 10.81 8.37-8.22 3.9 5.37 26.1 7.55 7.09-5.4 3.29 4.19 20.18 16.94 17.94c.08-.1 1.78-1.41 21.79-17.32l-.58-13.71 8.58 7.28c.12-.12 1.84-1.39 17.56-13.89l.61-10.14 6.48 4.5c.13-.12 1.58-1.22 14.26-11.33z" fill="#231f20"/><path d="m94.54 69 15.11-10.79-18.21-10.07-15.37 9.38z"/><path d="m92.87 88.2 1.67-19.2-18.47-11.48-.38 18.75z" fill="#004b16"/><path d="m68.22 107.73v-19.89l-18.66-14.15 1.47 19.54z" fill="#004b16"/><path d="m68.22 87.84 18.74-13.43-18.55-12.22-18.85 11.5z"/><path d="m38.43 131.48-2.98-20.32-18.15-17.8 4.19 20.18z" fill="#004b16"/><path d="m35.45 111.16 23.91-17.06-18.53-15.09-23.53 14.35z"/><path d="m33.9 100.6-3.94-26.88-20.22-16.81 5.41 26.07z" fill="#004b16"/><path d="m29.96 73.72 27.85-15.82-20.8-13.94-27.27 12.95z"/><path d="m28.07 60.88-5.4-36.81-22.67-14.06 7.19 34.62z" fill="#004b16"/><path d="m22.67 24.07 33.14-12.7-23.61-11.37-32.2 10.01z"/><g fill="#1cb35c"><path d="m107.13 76.87c-14.02 11.13-14.33 11.33-14.26 11.33 1.74-20.1 1.59-19.2 1.67-19.2 16-11.45 15-10.79 15.11-10.79z"/><path d="m85.78 93.84c-17.35 13.8-17.63 13.89-17.56 13.89-.17-20.82-.07-19.89 0-19.89 20-14.3 18.67-13.43 18.74-13.43z"/><path d="m60.22 114.16c-21.66 17.22-21.86 17.32-21.79 17.32-3.07-20.94-3-20.32-3-20.32 25.47-18.16 23.86-17.06 23.93-17.06z"/><path d="m55.81 11.37c1.52 35.37 1.4 34.34 1.48 34.34-28.66 14.89-29.29 15.17-29.22 15.17-5.52-37.63-5.47-36.81-5.4-36.81z"/><path d="m57.81 57.9c1.15 26.81 1 25.88 1.11 25.88-24.81 16.67-25.09 16.82-25 16.82-4-27.58-4-26.88-3.94-26.88z"/></g><path xmlns="http://www.w3.org/2000/svg" d="m151.61 14.24 16.58-4v79.88q0 13.13 7.83 15.65-3.84 7.31-13.13 7.3-11.28 0-11.28-15.66z"/><path d="m186.66 111.72v-57.42h-9.08v-13.6h25.86v71zm8.56-98.54a9.62 9.62 0 1 1 -9.62 9.62 9.63 9.63 0 0 1 9.62-9.62z"/><path d="m262.94 111.74v-41.06c0-6.05-1.16-10.48-3.48-13.26s-6.11-4.18-11.37-4.18a17.74 17.74 0 0 0 -7.8 2.06 18 18 0 0 0 -6.46 5.1v51.34h-16.59v-71h11.94l3 6.64q6.76-8 20-8 12.66 0 20 7.59t7.33 21.19v43.58z"/><path d="m288.42 76.06q0-16.26 9.38-26.47t24.77-10.21q16.19 0 25.14 9.82t9 26.86q0 17-9.12 27t-25 10q-16.18 0-25.17-10.12t-9-26.88zm17.24 0q0 23.47 16.91 23.48a14.54 14.54 0 0 0 12.31-6.11q4.55-6.09 4.54-17.37 0-23.14-16.85-23.15a14.61 14.61 0 0 0 -12.33 6.09q-4.58 6.11-4.58 17.06z"/><path d="m412.37 111.74v-4.31c-1.37 1.5-3.71 2.82-7 3.95a31.33 31.33 0 0 1 -10.15 1.69q-14.87 0-23.38-9.42t-8.52-26.27q0-16.84 9.78-27.42a32 32 0 0 1 24.51-10.58 32.37 32.37 0 0 1 14.72 3.32v-28.46l16.58-4v101.5zm0-54.06a17.6 17.6 0 0 0 -11.07-4.24q-10 0-15.33 6.07t-5.37 17.41q0 22.15 21.36 22.15a16.11 16.11 0 0 0 5.87-1.42c2.32-1 3.83-1.92 4.54-2.89z"/><path d="m505.55 81.3h-50.74q.46 8.49 5.83 13.2t14.46 4.7q11.34 0 17.25-5.9l6.43 12.7q-8.75 7.09-26.13 7.1-16.25 0-25.7-9.52t-9.45-26.58q0-16.78 10.38-27.2a33.91 33.91 0 0 1 24.9-10.41q15.45 0 24.81 9.22t9.35 23.48a46.28 46.28 0 0 1 -1.39 9.21zm-50.15-12.47h34.89q-1.73-15.58-17.24-15.59-14.2 0-17.65 15.59z"/></svg>
diff --git a/simplified/lowarn-version-simplexmq-v305.cabal b/simplified/lowarn-version-simplexmq-v305.cabal
new file mode 100644
index 0000000..249bab0
--- /dev/null
+++ b/simplified/lowarn-version-simplexmq-v305.cabal
@@ -0,0 +1,154 @@
+cabal-version: 1.12
+
+-- This file has been generated from package.yaml by hpack version 0.35.2.
+--
+-- see: https://github.com/sol/hpack
+
+name:           lowarn-version-simplexmq-v305
+version:        4.0.0
+synopsis:       SimpleXMQ message broker
+description:    This package includes <./docs/Simplex-Messaging-Server.html server>,
+                <./docs/Simplex-Messaging-Client.html client> and
+                <./docs/Simplex-Messaging-Agent.html agent> for SMP protocols:
+                .
+                * <https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md SMP protocol>
+                * <https://github.com/simplex-chat/simplexmq/blob/master/protocol/agent-protocol.md SMP agent protocol>
+                .
+                See <https://github.com/simplex-chat/simplex-chat terminal chat prototype> built with SimpleXMQ broker.
+category:       Chat, Network, Web, System, Cryptography
+homepage:       https://github.com/simplex-chat/simplexmq#readme
+author:         simplex.chat
+maintainer:     chat@simplex.chat
+copyright:      2020-2022 simplex.chat
+license:        AGPL-3
+license-file:   LICENSE
+build-type:     Simple
+
+flag swift
+  description: Enable swift JSON format
+  manual: True
+  default: False
+
+library
+  exposed-modules:
+      Simplex.Messaging.Agent
+      Simplex.Messaging.Agent.Client
+      Simplex.Messaging.Agent.Env.SQLite
+      Simplex.Messaging.Agent.Lock
+      Simplex.Messaging.Agent.NtfSubSupervisor
+      Simplex.Messaging.Agent.Protocol
+      Simplex.Messaging.Agent.QueryString
+      Simplex.Messaging.Agent.RetryInterval
+      Simplex.Messaging.Agent.Server
+      Simplex.Messaging.Agent.Store
+      Simplex.Messaging.Agent.Store.SQLite
+      Simplex.Messaging.Agent.Store.SQLite.Migrations
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220101_initial
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220301_snd_queue_keys
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220322_notifications
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220608_v2
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220625_v2_ntf_mode
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220811_onion_hosts
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220817_connection_ntfs
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220905_commands
+      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220915_connection_queues
+      Simplex.Messaging.Agent.TRcvQueues
+      Simplex.Messaging.Client
+      Simplex.Messaging.Client.Agent
+      Simplex.Messaging.Crypto
+      Simplex.Messaging.Crypto.Ratchet
+      Simplex.Messaging.Encoding
+      Simplex.Messaging.Encoding.String
+      Simplex.Messaging.Notifications.Client
+      Simplex.Messaging.Notifications.Protocol
+      Simplex.Messaging.Notifications.Server
+      Simplex.Messaging.Notifications.Server.Env
+      Simplex.Messaging.Notifications.Server.Main
+      Simplex.Messaging.Notifications.Server.Push.APNS
+      Simplex.Messaging.Notifications.Server.Stats
+      Simplex.Messaging.Notifications.Server.Store
+      Simplex.Messaging.Notifications.Server.StoreLog
+      Simplex.Messaging.Notifications.Transport
+      Simplex.Messaging.Notifications.Types
+      Simplex.Messaging.Parsers
+      Simplex.Messaging.Protocol
+      Simplex.Messaging.Server
+      Simplex.Messaging.Server.CLI
+      Simplex.Messaging.Server.Env.STM
+      Simplex.Messaging.Server.Expiration
+      Simplex.Messaging.Server.Main
+      Simplex.Messaging.Server.MsgStore
+      Simplex.Messaging.Server.MsgStore.STM
+      Simplex.Messaging.Server.QueueStore
+      Simplex.Messaging.Server.QueueStore.STM
+      Simplex.Messaging.Server.Stats
+      Simplex.Messaging.Server.StoreLog
+      Simplex.Messaging.TMap
+      Simplex.Messaging.Transport
+      Simplex.Messaging.Transport.Client
+      Simplex.Messaging.Transport.HTTP2
+      Simplex.Messaging.Transport.HTTP2.Client
+      Simplex.Messaging.Transport.HTTP2.Server
+      Simplex.Messaging.Transport.KeepAlive
+      Simplex.Messaging.Transport.Server
+      Simplex.Messaging.Transport.WebSockets
+      Simplex.Messaging.Util
+      Simplex.Messaging.Version
+  other-modules:
+      Paths_lowarn_version_simplexmq_v305
+  hs-source-dirs:
+      src
+  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns
+  build-depends:
+      QuickCheck ==2.14.*
+    , aeson ==2.1.*
+    , ansi-terminal >=0.10 && <0.12
+    , asn1-encoding ==0.9.*
+    , asn1-types ==0.3.*
+    , async ==2.2.*
+    , attoparsec ==0.14.*
+    , base >=4.14 && <5
+    , base64-bytestring >=1.0 && <1.3
+    , bytestring ==0.11.*
+    , case-insensitive ==1.2.*
+    , composition ==1.0.*
+    , constraints >=0.12 && <0.14
+    , containers ==0.6.*
+    , cryptonite >=0.27 && <=0.30
+    , cryptostore ==0.2.*
+    , data-default ==0.7.*
+    , direct-sqlcipher ==2.3.*
+    , directory ==1.3.*
+    , filepath ==1.4.*
+    , generic-random >=1.3 && <1.5.1
+    , http-types ==0.12.*
+    , http2 ==4.1.*
+    , ini ==0.4.1
+    , iso8601-time ==0.1.*
+    , memory ==0.18.*
+    , mtl ==2.2.*
+    , network >=3.1.2.7 && <3.2
+    , network-transport ==0.5.6
+    , optparse-applicative >=0.15 && <0.18
+    , process ==1.6.*
+    , random >=1.1 && <1.3
+    , simple-logger ==0.1.*
+    , socks ==0.6.*
+    , sqlcipher-simple ==0.4.*
+    , stm ==2.5.*
+    , template-haskell ==2.18.*
+    , text ==1.2.*
+    , time ==1.11.*
+    , time-compat ==1.9.*
+    , time-manager ==0.0.*
+    , tls >=1.6.0 && <1.7
+    , transformers ==0.5.*
+    , unliftio ==0.2.*
+    , unliftio-core ==0.2.*
+    , websockets ==0.12.*
+    , x509 ==1.7.*
+    , x509-store ==1.6.*
+    , x509-validation ==1.6.*
+  default-language: Haskell2010
+  if flag(swift)
+    cpp-options: -DswiftJSON
diff --git a/source/package.yaml b/simplified/package.yaml
index e74fac7..be5c795 100644
--- a/source/package.yaml
+++ b/simplified/package.yaml
@@ -1,4 +1,4 @@
-name: simplexmq
+name: lowarn-version-simplexmq-v305
 version: 4.0.0
 synopsis: SimpleXMQ message broker
 description: |
@@ -17,12 +17,9 @@ author: simplex.chat
 maintainer: chat@simplex.chat
 copyright: 2020-2022 simplex.chat
 category: Chat, Network, Web, System, Cryptography
-extra-source-files:
-  - README.md
-  - CHANGELOG.md
 
 dependencies:
-  - aeson == 2.0.*
+  - aeson == 2.1.*
   - ansi-terminal >= 0.10 && < 0.12
   - asn1-encoding == 0.9.*
   - asn1-types == 0.3.*
@@ -30,27 +27,27 @@ dependencies:
   - attoparsec == 0.14.*
   - base >= 4.14 && < 5
   - base64-bytestring >= 1.0 && < 1.3
-  - bytestring == 0.10.*
+  - bytestring == 0.11.*
   - case-insensitive == 1.2.*
   - composition == 1.0.*
   - constraints >= 0.12 && < 0.14
   - containers == 0.6.*
-  - cryptonite >= 0.27 && < 0.30
+  - cryptonite >= 0.27 && <= 0.30
   - cryptostore == 0.2.*
   - data-default == 0.7.*
   - direct-sqlcipher == 2.3.*
   - directory == 1.3.*
   - filepath == 1.4.*
   - http-types == 0.12.*
-  - http2 == 3.0.*
-  - generic-random >= 1.3 && < 1.5
+  - http2 == 4.1.*
+  - generic-random >= 1.3 && < 1.5.1
   - ini == 0.4.1
   - iso8601-time == 0.1.*
-  - memory == 0.15.*
+  - memory == 0.18.*
   - mtl == 2.2.*
   - network >= 3.1.2.7 && < 3.2
-  - network-transport == 0.5.4
-  - optparse-applicative >= 0.15 && < 0.17
+  - network-transport == 0.5.6
+  - optparse-applicative >= 0.15 && < 0.18
   - QuickCheck == 2.14.*
   - process == 1.6.*
   - random >= 1.1 && < 1.3
@@ -58,9 +55,9 @@ dependencies:
   - socks == 0.6.*
   - sqlcipher-simple == 0.4.*
   - stm == 2.5.*
-  - template-haskell == 2.16.*
+  - template-haskell == 2.18.*
   - text == 1.2.*
-  - time == 1.9.*
+  - time == 1.11.*
   - time-compat == 1.9.*
   - time-manager == 0.0.*
   - tls >= 1.6.0 && < 1.7
@@ -86,45 +83,6 @@ when:
 library:
   source-dirs: src
 
-executables:
-  smp-server:
-    source-dirs: apps/smp-server
-    main: Main.hs
-    dependencies:
-      - simplexmq
-    ghc-options:
-      - -threaded
-
-  ntf-server:
-    source-dirs: apps/ntf-server
-    main: Main.hs
-    dependencies:
-      - simplexmq
-    ghc-options:
-      - -threaded
-
-  smp-agent:
-    source-dirs: apps/smp-agent
-    main: Main.hs
-    dependencies:
-      - simplexmq
-    ghc-options:
-      - -threaded
-
-tests:
-  smp-server-test:
-    source-dirs: tests
-    main: Test.hs
-    dependencies:
-      - simplexmq
-      - hspec == 2.7.*
-      - hspec-core == 2.7.*
-      - HUnit == 1.6.*
-      - QuickCheck == 2.14.*
-      - silently == 1.2.*
-      - main-tester == 0.2.*
-      - timeit == 2.0.*
-
 ghc-options:
   # - -haddock
   - -Wall
diff --git a/source/protocol/agent-protocol.md b/source/protocol/agent-protocol.md
deleted file mode 100644
index 0da8af8..0000000
--- a/source/protocol/agent-protocol.md
+++ /dev/null
@@ -1,419 +0,0 @@
-# SMP agent protocol - duplex communication over SMP protocol
-
-## Table of contents
-
-- [Abstract](#abstract)
-- [SMP agent](#smp-agent)
-- [SMP servers management](#smp-servers-management)
-- [SMP agent protocol components](#smp-agent-protocol-components)
-- [Duplex connection procedure](#duplex-connection-procedure)
-- [Communication between SMP agents](#communication-between-smp-agents)
-  - [Message syntax](#messages-between-smp-agents)
-    - [HELLO message](#hello-message)
-    - [REPLY message](#reply-message)
-    - [MSG message](#msg-message)
-    - [INV message](#inv-message)
-    - [ACK message](#ack-message)
-    - [NEW message](#new-message)
-    - [DEL message](#del-message)
-- [SMP agent commands](#smp-agent-commands)
-  - [Client commands and server responses](#client-commands-and-server-responses)
-    - [NEW command and INV response](#new-command-and-inv-response)
-    - [JOIN command](#join-command)
-    - [CONF notification and LET command](#conf-notification-and-let-command)
-    - [REQ notification and ACPT command](#req-notification-and-acpt-command)
-    - [INFO and CON notifications](#info-and-con-notifications)
-    - [SUB command](#sub-command)
-    - [SEND command and MID, SENT and MERR responses](#send-command-and-mid-sent-and-merr-responses)
-    - [MSG notification](#msg-notification)
-    - [END notification](#end-notification)
-    - [OFF command](#off-command)
-    - [DEL command](#del-command)
-- [Connection request](#connection-request)
-
-## Abstract
-
-The purpose of SMP agent protocol is to define the syntax and the semantics of communications between the client and the agent that connects to [SMP](./simplex-messaging.md) servers.
-
-It provides:
-- protocol to create and manage bi-directional (duplex) connections between the users of SMP agents consisting of two (or more) separate unidirectional (simplex) SMP queues, abstracting away multiple steps required to establish bi-directional connections and any information about the servers location from the users of the agent protocol.
-- management of E2E encryption between SMP agents, generating ephemeral asymmetric keys for each connection.
-- SMP command authentication on SMP servers, generating ephemeral keys for each SMP queue.
-- TCP/TLS transport handshake with SMP servers.
-- validation of message integrity.
-
-SMP agent protocol provides no encryption or security on the client side - it is assumed that the agent is executed in the trusted and secure environment, in one of three ways:
-- via TCP network using secure connection.
-- via local port (when the agent runs on the same device as a separate process).
-- via agent library, when the agent logic is included directly into the client application - [SimpleX Chat for terminal](https://github.com/simplex-chat/simplex-chat) uses this approach.
-
-## SMP agent
-
-SMP agents communicate with each other via SMP servers using [simplex messaging protocol (SMP)](./simplex-messaging.md) according to the commands received from its users. This protocol is a middle layer in SimpleX protocols (above SMP protocol but below any application level protocol) - it is intended to be used by client-side applications that need secure asynchronous bi-directional communication channels ("connections").
-
-The agent must have a persistent storage to manage the states of known connections and of the client-side information of SMP queues that each connection consists of, and also the buffer of the most recent sent and received messages. The number of the messages that should be stored is implementation specific, depending on the error management approach that the agent implements; at the very least the agent must store the hashes and IDs of the last received and sent messages.
-
-## SMP servers management
-
-SMP agent protocol commands do not contain the addresses of the SMP servers that the agent will use to create and use the connections (excluding the server address in queue URIs used in JOIN command). The list of the servers is a part of the agent configuration and can be dynamically changed by the agent implementation:
-- by the client applications via any API that is outside of scope of this protocol.
-- by the agents themselves based on availability and latency of the configured servers.
-
-## SMP agent protocol components
-
-SMP agent protocol has 3 main parts:
-
-- the syntax and semantics of the messages that SMP agents exchange with each other in order to:
-  - negotiate establishing unidirectional (simplex) encrypted queues on SMP servers.
-  - exchange client messages and delivery notifications, providing sequential message IDs and message integrity (by including the hash of the previous message).
-- the syntax and semantics of the commands that are sent by the agent clients to the agents. This protocol allows to create and manage multiple connections, each consisting of two or more SMP queues.
-- the syntax and semantics of the message that the clients of SMP agents should send out-of-band (as pre-shared "invitation" including queue URIs) to protect [E2E encryption][1] from active attacks ([MITM attacks][2]).
-
-## Duplex connection procedure
-
-![Duplex connection procedure](./diagrams/duplex-messaging/duplex-creating.svg)
-
-The procedure of establishing a duplex connection is explained on the example of Alice and Bob creating a bi-directional connection consisting of two unidirectional (simplex) queues, using SMP agents (A and B) to facilitate it, and two different SMP servers (which could be the same server). It is shown on the diagram above and has these steps:
-
-1. Alice requests the new connection from the SMP agent A using SMP NEW command.
-2. Agent A creates an SMP connection on the server (using [SMP protocol](./simplex-messaging.md)) and responds to Alice with the invitation that contains queue information and the encryption key Bob's agent B should use. The invitation format is described in [Connection request](#connection-request).
-3. Alice sends the [connection request](#connection-request) to Bob via any secure channel (out-of-band message).
-4. Bob sends `JOIN` command with the connection request as a parameter to agent B to accept the connection.
-5. Establishing Alice's SMP queue (with SMP protocol commands):
-  - Agent B sends an "SMP confirmation" with SMP SEND command to the SMP queue specified in the connection request - SMP confirmation is an unauthenticated message with an ephemeral key that will be used to authenticate Bob's commands to the queue, as described in SMP protocol, and Bob's info (profile, public key for E2E encryption, etc.). This message is encrypted using key passed in the connection request (or with the derived key, in which case public key for key derivation should be sent in clear text).
-  - Agent A receives the SMP confirmation containing Bob's key and info as SMP MSG.
-  - Agent A notifies Alice sending REQ notification with Bob's info.
-  - Alice accepts connection request with ACPT command.
-  - Agent A secures the queue with SMP KEY command.
-  - Agent B tries sending authenticated SMP SEND command with agent `HELLO` message until it succeeds. Once it succeeds, Bob's agent "knows" the queue is secured.
-6. Agent B creates a new SMP queue on the server.
-7. Establish Bob's SMP queue:
-  - Agent B sends `REPLY` message (SMP SEND command) with the connection request to this 2nd queue to Alice's agent (via the 1st queue) - this connection request SHOULD use "simplex" URI scheme.
-  - Agent A, having received `REPLY` message, sends unauthenticated message (SMP SEND) to SMP queue with Alice agent's ephemeral key that will be used to authenticate Alice's commands to the queue, as described in SMP protocol, and Alice's info.
-  - Bob's agent receives the key and Alice's information and secures the queue (SMP KEY).
-  - Bob's agent sends the notification `INFO` with Alice's information to Bob.
-  - Alice's agent keeps sending `HELLO` message until it succeeds.
-8. Agents A and B notify Alice and Bob that connection is established.
-  - Once sending `HELLO` succeeds, Alice's agent sends to Alice `CON` notification that confirms that now both parties can communicate.
-  - Once Bob's agent receives `HELLO` from Alice's agent, it sends to Bob `CON` notification as well.
-
-At this point the duplex connection between Alice and Bob is established, they can use `SEND` command to send messages. The diagram also shows how the connection status changes for both parties, where the first part is the status of the SMP queue to receive messages, and the second part - the status of the queue to send messages.
-
-The most communication happens between the agents and servers, from the point of view of Alice and Bob there are 4 steps (not including notifications):
-
-1. Alice requests a new connection with `NEW` command and receives the invitation.
-2. Alice passes connection request out-of-band to Bob.
-3. Bob accepts the connection with `JOIN` command with the connection request to his agent.
-4. Alice accepts the connection with `ACPT` command.
-5. Both parties receive `CON` notification once duplex connection is established.
-
-Clients SHOULD support establishing duplex connection asynchronously (when parties are intermittently offline) by persisting intermediate states and resuming SMP queue subscriptions.
-
-## Communication between SMP agents
-
-To establish duplex connections and to send messages on behalf of their clients, SMP agents communicate via SMP servers.
-
-Agents use SMP message client body (the part of the SMP message after header - see [SMP protocol](./simplex-messaging.md)) to transmit agent client messages and exchange messages between each other.
-
-Each SMP message client body, once decrypted, contains 3 parts (one of them may include binary message body), as defined by `decryptedSmpMessageBody` syntax:
-
-- `agentMsgHeader` - agent message header that contains sequential agent message ID for a particular SMP queue, agent timestamp (ISO8601) and the hash of the previous message.
-- `agentMessage` - a command/message to the other SMP agent:
-  - to establish the connection with two SMP queues (`helloMsg`, `replyQueueMsg`)
-  - to send and to acknowledge user messages (`clientMsg`, `acknowledgeMsg`)
-  - to manage SMP queue rotation (`newQueueMessage`, `deleteQueueMsg`)
-  - to manage encryption key rotation (TODO)
-- `msgPadding` - an optional message padding to make all SMP messages have constant size, to prevent servers from observing the actual message size. The only case the message padding can be absent is when the message has exactly the maximum size, in all other cases the message MUST be padded to a fixed size.
-
-### Messages between SMP agents
-
-Message syntax below uses [ABNF][3] with [case-sensitive strings extension][4].
-
-```abnf
-decryptedSmpMessageBody = agentMsgHeader CRLF agentMessage CRLF msgPadding
-agentMsgHeader = agentMsgId SP previousMsgHash ; here `agentMsgId` is sequential ID set by the sending agent
-agentMsgId = 1*DIGIT
-previousMsgHash = encoded
-encoded = <base64 encoded>
-
-agentMessage = helloMsg / replyQueueMsg /
-               clientMsg / invitationMsg /
-               newQueueMessage / deleteQueueMsg 
-
-msgPadding = *OCTET ; optional random bytes to get messages to the same size (as defined in SMP message size)
-
-helloMsg = %s"H"
-
-replyQueueMsg = %s"R" connectionRequest ; `connectionRequest` is defined below
-; this message can only be sent by the second connection party
-
-clientMsg = %s"M" clientMsgBody
-clientMsgBody = *OCTET
-
-; TODO remove and move to "public" header
-invitationMsg = %s"INV" SP connReqInvitation SP connInfo
-; `connReqInvitation` and `connInfo` are defined below
-
-newQueueMsg = %s"N" queueURI
-; this message can be sent by any party to add SMP queue to the connection.
-; NOT SUPPORTED in the current implementation
-
-deleteQueueMsg = %s"D" queueURI
-; notification that the queue with passed URI will be deleted
-; no need to notify the other party about suspending queue separately, as suspended and deleted queues are indistinguishable to the sender
-; NOT SUPPORTED in the current implementation
-```
-
-#### HELLO message
-
-This is the first message that both agents send after the respective SMP queue is secured by the receiving agent (see diagram). It MAY contain the public key that the recipient would use to verify messages signed by the sender.
-
-Sending agent might need to retry sending HELLO message, as it would not have any other confirmation that the queue is secured other than the success of sending this message with the signed SMP SEND command.
-
-#### REPLY message
-
-This is the message that is sent by the agent that received an out-of-band connection request to pass the connection request for the reply SMP queues to the agent that originated the connection (see diagram).
-
-#### MSG message
-
-This is the agent envelope used to send client messages once the connection is established. Do not confuse it with the MSG response from SMP server to the agent and MSG response from SMP agent to the client that are sent in different contexts.
-
-#### INV message
-
-This message is sent to the SMP queue(s) in `connReqContact`, to establish a new connection via existing unsecured queue, that acts as a permanent connection link of a user.
-
-#### ACK message
-
-This message is sent to confirm the client message reception. It includes received message number, message hash and the reception status.
-
-#### NEW message
-
-This message is sent to add an additional SMP queue to the connection. Unlike REPLY message it can be sent at any time.
-
-#### DEL message 
-
-This message is sent to notify that the queue with passed URI will be deleted - having received this message, the receiving agent should no longer send messages to this queue. In case it was the last remaining send queue in the duplex connection, the agent MAY also delete the reply queue(s) in the connection.
-
-## SMP agent commands
-
-This part describes the transmissions between users and client-side SMP agents: commands that the users send to create and operate duplex connections and SMP agent responses and messages they deliver.
-
-Commands syntax below is provided using [ABNF][3] with [case-sensitive strings extension][4].
-
-Each transmission between the user and SMP agent must have this format/syntax:
-
-```abnf
-agentTransmission = [corrId] CRLF [connId] CRLF agentCommand
-
-corrId = 1*(%x21-7F) ; any characters other than control/whitespace
-
-connId = encoded
-
-agentCommand = (userCmd / agentMsg) CRLF
-userCmd = newCmd / joinCmd / letCmd / acceptCmd / subscribeCmd / sendCmd / acknowledgeCmd / suspendCmd / deleteCmd
-agentMsg = invitation / confMsg / connReqMsg / connInfo / connected / unsubscribed / connDown / connUp / messageId / sent / messageError / message / received / ok / error
-
-newCmd = %s"NEW" SP connectionMode [SP %s"NO_ACK"] ; response is `invitation` or `error`
-; NO_ACK parameter currently not supported
-
-connectionMode = %s"INV" / %s"CON"
-
-invitation = %s"INV" SP connectionRequest ; `connectionRequest` is defined below
-
-confMsg = %s"CONF" SP confirmationId SP msgBody
-; msgBody here is any binary information identifying connection request
-
-letCmd = %s"LET" SP confirmationId SP msgBody
-; msgBody here is any binary information identifying connecting party
-
-confirmationId = 1*DIGIT
-
-connReqMsg = %s"REQ" SP invitationId SP msgBody
-; msgBody here is any binary information identifying connection request
-
-acceptCmd = %s"ACPT" SP invitationId SP msgBody
-; msgBody here is any binary information identifying connecting party
-
-invitationId = 1*DIGIT
-
-connInfo = %s"INFO" SP msgBody
-; msgBody here is any binary information identifying connecting party
-
-connected = %s"CON"
-
-subscribeCmd = %s"SUB" ; response is `ok` or `error`
-
-unsubscribed = %s"END"
-; when another agent (or another client of the same agent)
-; subscribes to the same SMP queue on the server
-
-connDown = %s"DOWN"
-; lost connection (e.g. because of Internet connectivity or server is down)
-
-connUp = %s"UP"
-; restored connection
-
-joinCmd = %s"JOIN" SP connectionRequest SP connInfo [SP %s"NO_REPLY"] [SP %s"NO_ACK"]
-; `connectionRequest` and `connInfo` are defined below
-; response is `connected` or `error`
-; parameters NO_REPLY and NO_ACK are currently not supported
-
-suspendCmd = %s"OFF" ; can be sent by either party, response `ok` or `error`
-
-deleteCmd = %s"DEL" ; can be sent by either party, response `ok` or `error`
-
-sendCmd = %s"SEND" SP msgBody
-; send syntax is similar to that of SMP protocol, but it is wrapped in SMP message
-msgBody = stringMsg | binaryMsg
-stringMsg = ":" string ; until CRLF in the transmission
-string = *(%x01-09 / %x0B-0C / %x0E-FF %) ; any characters other than NUL, CR and LF
-binaryMsg = size CRLF msgBody CRLF ; the last CRLF is in addition to CRLF in the transmission
-size = 1*DIGIT ; size in bytes
-msgBody = *OCTET ; any content of specified size - safe for binary
-
-messageId = %s"MID" SP agentMsgId
-
-sent = %s"SENT" SP agentMsgId
-
-messageError = %s"MERR" SP agentMsgId SP <errorType>
-
-message = %s"MSG" SP msgIntegrity SP recipientMeta SP brokerMeta SP senderMeta SP binaryMsg
-recipientMeta = %s"R=" agentMsgId "," agentTimestamp ; receiving agent message metadata 
-brokerMeta = %s"B=" brokerMsgId "," brokerTimestamp ; broker (server) message metadata
-senderMeta = %s"S=" agentMsgId ; sending agent message ID 
-brokerMsgId = encoded
-brokerTimestamp = <date-time>
-msgIntegrity = ok / msgIntegrityError
-
-msgIntegrityError = %s"ERR" SP msgIntegrityErrorType
-msgIntegrityErrorType = skippedMsgErr / badMsgIdErr / badHashErr
-
-skippedMsgErr = %s"NO_ID" SP missingFromMsgId SP missingToMsgId
-badMsgIdErr = %s"ID" SP previousMsgId ; ID is lower than the previous
-badHashErr = %s"HASH"
-
-missingFromMsgId = agentMsgId
-missingToMsgId = agentMsgId
-previousMsgId = agentMsgId
-
-acknowledgeCmd = %s"ACK" SP agentMsgId ; ID assigned by receiving agent (in MSG "R")
-
-received = %s"RCVD" SP agentMsgId SP msgIntegrity
-; ID assigned by sending agent (in SENT response)
-; currently not implemented
-
-msgStatus = ok | error
-
-ok = %s"OK"
-
-error = %s"ERR" SP <errorType>
-```
-
-### Client commands and server responses
-
-#### NEW command and INV response
-
-`NEW` command is used to create a connection and a connection request to be sent out-of-band to another protocol user (the joining party). It should be used by the client of the agent that initiates creating a duplex connection (the initiating party).
-
-`INV` response is sent by the agent to the client of the initiating party.
-
-`NEW` command has `connectionMode` parameter to define the connection mode - to be used to communicate with a single contact (invitation mode, `connectionMode` is `INV`) or to accept connection requests from anybody (contact mode, `connectionMode` is `CON`). The type of connection request is determined by `connectionMode` parameter.
-
-#### JOIN command
-
-It is used to create a connection and accept the connection request received out-of-band. It should be used by the client of the agent that accepts the connection (the joining party).
-
-#### CONF notification and LET command
-
-When the joining party uses `JOIN` command to accept connection invitation created with `NEW INV` command, the initiating party will receive `CONF` notification with some numeric identifier and an additional binary information, that can be used to identify the joining party or for any other purpose.
-
-To continue with the connection the initiating party should use `LET` command.
-
-#### REQ notification and ACPT command
-
-When the joining party uses `JOIN` command to connect to the contact created with `NEW CON` command, the initiating party will receive `REQ` notification with some numeric identifier and an additional binary information, that can be used to identify the joining party or for any other purpose.
-
-To continue with the connection the party that created the contact should use `ACPT` command.
-
-#### INFO and CON notifications
-
-After the initiating party proceeds with the connection using `ACPT` command, the joining party will receive `INFO` notification that can be used to identify the initiating party or for any other purpose.
-
-Once the connection is established and ready to accept client messages, both agents will send `CON` notification to their clients.
-
-#### SUB command
-
-This command can be used by the client to resume receiving messages from the connection that was created in another TCP/client session. Agent response to this command can be `OK` or `ERR` in case connection does not exist (or can only be used to send connections - e.g. when the reply queue was not created).
-
-#### SEND command and MID, SENT, RCVD and MERR responses
-
-`SEND` command is used by the client to send messages.
-
-`MID` response with the message ID (the sequential message number that includes both sent and received messages in the connection) is sent to the client to confirm that the message is accepted by the agent, before it is sent to the SMP server.
-
-`SENT` notification is sent by the agent to confirm that the message was delivered to at least one of SMP servers. This notification contains the same message ID as `MID` notification. `SENT` notification, depending on network availability, can be sent at any time later, potentially in the next client session.
-
-`RCVD` notification is sent by the agent when it receives `ACK` message from the receiving agent. This notification contains reception status, only one successful notification will be sent, and multiple error notifications will be sent in case `ACK` had error status.
-
-In case of the failure to send the message for any other reason than network connection or message queue quota - e.g. authentication error (`ERR AUTH`) or syntax error (`ERR CMD error`), the agent will send to the client `MERR` notification with the message ID, and this message delivery will no longer be attempted to this SMP queue.
-
-#### MSG notification
-
-It is sent by the agent to the client when agent receives the message from the SMP server. It has message ID and timestamp from both the receiving and sending agents and from SMP server:
-- recipient agent ID is intended to be used to refer to the message in the future.
-- sender agent ID is intended to be used to identify any missed / skipped message(s)
-- broker ID should be used to detect duplicate deliveries (it would happen if TCP connection is lost before the message is acknowledged by the agent - see [SMP protocol](./simplex-messaging.md))
-
-#### END notification
-
-It is sent by the agent to the client when agent receives SMP protocol `END` notification from SMP server. It indicates that another agent has subscribed to the same SMP queue on the server and the server terminated the subscription of the current agent.
-
-#### DOWN and UP notifications
-
-These notifications are sent when server or network connection is, respectively, `DOWN` or back `UP`.
-
-All the subscriptions made in the current client session will be automatically resumed when `UP` notification is received.
-
-#### OFF command
-
-It is used to suspend the receiving SMP queue - sender will no longer be able to send the messages to the connection, but the recipient can retrieve the remaining messages. Agent response to this command can be `OK` or `ERR`. This command is irreversible.
-
-#### DEL command
-
-It is used to delete the connection and all messages in it, as well as the receiving SMP queue and all messages in it that were remaining on the server. Agent response to this command can be `OK` or `ERR`. This command is irreversible.
-
-## Connection request
-
-Connection request `connectionRequest` is generated by SMP agent in response to `newCmd` command (`"NEW"`), used by another party user with `joinCmd` command (`"JOIN"`), and then another connection request is sent by the agent in `replyQueueMsg` and used by the first party agent to connect to the reply queue (the second part of the process is invisible to the users).
-
-Connection request syntax:
-
-```
-connectionRequest = connectionScheme "/" connReqType "#/?smp=" smpQueues "&e2e=" e2eEncryption
-connReqType = %s"invitation" / %s"contact"
-; this parameter has the same meaning as connectionMode in agent commands
-; `NEW INV` creates `invitation` connection request, `NEW CON` - `contact`
-connectionScheme = (%s"https://" clientAppServer) | %s"simplex:"
-clientAppServer = hostname [ ":" port ]
-; client app server, e.g. simplex.chat
-e2eEncryption = encryptionScheme ":" publicKey
-encryptionScheme = %s"rsa" ; end-to-end encryption and key exchange protocols,
-                           ; the current hybrid encryption scheme (RSA-OAEP/AES-256-GCM-SHA256)
-                           ; will be replaced with double ratchet protocol and DH key exchange.
-publicKey = <base64url X509 SPKI key encoding>
-smpQueues = smpQueue [ "," 1*smpQueue ] ; SMP queues for the connection
-smpQueue = <URL-encoded queueURI defined in SMP protocol>
-```
-
-All parameters are passed via URI hash to avoid sending them to the server (in case "https" scheme is used) - they can be used by the client-side code and processed by the client application. Parameters `smp` and `e2e` can be present in any order, any unknown additional parameters SHOULD be ignored.
-
-`clientAppServer` is not an SMP server - it is a server that shows the instruction on how to download the client app that will connect using this connection request. This server can also host a mobile or desktop app manifest so that this link is opened directly in the app if it is installed on the device.
-
-"simplex" URI scheme in `connectionProtocol` can be used instead of client app server, to connect without creating any web traffic. Client apps MUST support this URI scheme.
-
-See SMP protocol [out-of-band messages](./simplex-messaging.md#out-of-band-messages) for syntax of `queueURI`.
-
-[1]: https://en.wikipedia.org/wiki/End-to-end_encryption
-[2]: https://en.wikipedia.org/wiki/Man-in-the-middle_attack
-[3]: https://tools.ietf.org/html/rfc5234
-[4]: https://tools.ietf.org/html/rfc7405
diff --git a/source/protocol/diagrams/duplex-messaging/duplex-creating-v2.mmd b/source/protocol/diagrams/duplex-messaging/duplex-creating-v2.mmd
deleted file mode 100644
index 09ee913..0000000
--- a/source/protocol/diagrams/duplex-messaging/duplex-creating-v2.mmd
+++ /dev/null
@@ -1,71 +0,0 @@
-sequenceDiagram
-  participant A as Alice
-  participant AA as Alice's<br>agent
-  participant AS as Alice's<br>server
-  participant BS as Bob's<br>server
-  participant BA as Bob's<br>agent
-  participant B as Bob
-
-  note over AA, BA: status (receive/send): NONE/NONE
-
-  note over A, AA: 1. request connection<br>from agent
-  A ->> AA: NEW: create<br>duplex connection
- 
-  note over AA, AS: 2. create Alice's SMP queue
-  AA ->> AS: NEW: create SMP queue
-  AS ->> AA: IDS: SMP queue IDs
-  note over AA: status: NEW/NONE
-
-  AA ->> A: INV: invitation<br>to connect
-
-  note over A, B: 3. out-of-band invitation
-  A ->> B: OOB: invitation to connect
-
-  note over BA, B: 4. accept connection
-  B ->> BA: JOIN:<br>via invitation info
-  note over BA: status: NONE/NEW
-
-  note over BA, BS: 5. create Bob's SMP queue
-  BA ->> BS: NEW: create SMP queue
-  BS ->> BA: IDS: SMP queue IDs
-  note over BA: status: NEW/NEW
-
-  note over BA, AA: 6. establish Alice's SMP queue
-  BA ->> AS: SEND: Bob's info and sender server key (SMP confirmation with reply queues)
-  note over BA: status: NEW/CONFIRMED
-
-  AS ->> AA: MSG: Bob's info and<br>sender server key
-  note over AA: status: CONFIRMED/NONE
-  AA ->> AS: ACK: confirm message
-  AA ->> A: CONF: connection request ID<br>and Bob's info
-  A ->> AA: LET: accept connection request,<br>send Alice's info
-  AA ->> AS: KEY: secure queue
-  note over AA: status: SECURED/NONE
-
-  AA ->> BS: SEND: Alice's info and sender's server key (SMP confirmation without reply queues)
-  note over AA: status: SECURED/CONFIRMED
-
-  BS ->> BA: MSG: Alice's info and<br>sender's server key
-  note over BA: status: CONFIRMED/CONFIRMED
-  BA ->> B: INFO: Alice's info
-  BA ->> BS: ACK: confirm message
-  BA ->> BS: KEY: secure queue
-  note over BA: status: SECURED/CONFIRMED
-
-  BA ->> AS: SEND: HELLO: only needs to be sent once in v2
-
-  note over BA: status: SECURED/ACTIVE
-  note over BA, B: 7a. notify Bob<br>about connection success
-  BA ->> B: CON: connected
-
-  AS ->> AA: MSG: HELLO: Alice's agent<br>knows Bob can send
-  note over AA: status: SECURED/ACTIVE
-  AA ->> AS: ACK: confirm message
-  note over A, AA: 7a. notify Alice<br>about connection success
-  AA ->> A: CON: connected
-
-  AA ->> BS: SEND: HELLO: only needs to be sent once in v2
-  note over AA: status: ACTIVE/ACTIVE
-  BS ->> BA: MSG: HELLO: Bob's agent<br>knows Alice can send
-  note over BA: status: ACTIVE/ACTIVE
-  BA ->> BS: ACK: confirm message
diff --git a/source/protocol/diagrams/duplex-messaging/duplex-creating.mmd b/source/protocol/diagrams/duplex-messaging/duplex-creating.mmd
deleted file mode 100644
index 738bad3..0000000
--- a/source/protocol/diagrams/duplex-messaging/duplex-creating.mmd
+++ /dev/null
@@ -1,79 +0,0 @@
-sequenceDiagram
-  participant A as Alice
-  participant AA as Alice's<br>agent
-  participant AS as Alice's<br>server
-  participant BS as Bob's<br>server
-  participant BA as Bob's<br>agent
-  participant B as Bob
-
-  note over AA, BA: status (receive/send): NONE/NONE
-
-  note over A, AA: 1. request connection from agent
-  A ->> AA: NEW: create<br>duplex connection
- 
-  note over AA, AS: 2. create Alice's SMP queue
-  AA ->> AS: NEW: create SMP queue
-  AS ->> AA: IDS: SMP queue IDs
-  note over AA: status: NEW/NONE
-
-  AA ->> A: INV: invitation<br>to connect
-  note over AA: status: PENDING/NONE
-
-  note over A, B: 3. out-of-band invitation
-  A ->> B: OOB: invitation to connect
-
-  note over BA, B: 4. accept connection
-  B ->> BA: JOIN:<br>via invitation info
-  note over BA: status: NONE/NEW
-
-  note over BA, AA: 5. establish Alice's SMP queue
-  BA ->> AS: SEND: Bob's info and sender server key (SMP confirmation)
-  note over BA: status: NONE/CONFIRMED
-  activate BA
-  AS ->> AA: MSG: Bob's info and<br>sender server key
-  note over AA: status: CONFIRMED/NONE
-  AA ->> AS: ACK: confirm message
-  AA ->> A: CONF: connection request ID<br>and Bob's info
-  A ->> AA: LET: accept connection request,<br>send Alice's info
-  AA ->> AS: KEY: secure queue
-  note over AA: status: SECURED/NONE
-
-  BA ->> AS: SEND: HELLO: try sending until successful
-  deactivate BA
-  note over BA: status: NONE/ACTIVE
-  AS ->> AA: MSG: HELLO: Alice's agent<br>knows Bob can send
-  note over AA: status: ACTIVE/NONE
-  AA ->> AS: ACK: confirm message
-
-  note over BA, BS: 6. create Bob's SMP queue
-  BA ->> BS: NEW: create SMP queue
-  BS ->> BA: IDS: SMP queue IDs
-  note over BA: status: NEW/ACTIVE
-
-  note over AA, BA: 7. establish Bob's SMP queue
-  BA ->> AS: SEND: REPLY: invitation to the connect
-  note over BA: status: PENDING/ACTIVE
-  AS ->> AA: MSG: REPLY: invitation<br>to connect
-  note over AA: status: ACTIVE/NEW
-  AA ->> AS: ACK: confirm message
-
-  AA ->> BS: SEND: Alice's info and sender's server key
-  note over AA: status: ACTIVE/CONFIRMED
-  activate AA
-  BS ->> BA: MSG: Alice's info and<br>sender's server key
-  note over BA: status: CONFIRMED/ACTIVE
-  BA ->> B: INFO: Alice's info
-  BA ->> BS: ACK: confirm message
-  BA ->> BS: KEY: secure queue
-  note over BA: status: SECURED/ACTIVE
-
-  AA ->> BS: SEND: HELLO: try sending until successful
-  deactivate AA
-  note over AA: status: ACTIVE/ACTIVE
-  BS ->> BA: MSG: HELLO: Bob's agent<br>knows Alice can send
-  note over BA: status: ACTIVE/ACTIVE
-  BA ->> BS: ACK: confirm message
-
-  note over A, B: 8. notify users about connection success
-  AA ->> A: CON: connected
-  BA ->> B: CON: connected
diff --git a/source/protocol/diagrams/duplex-messaging/duplex-creating.svg b/source/protocol/diagrams/duplex-messaging/duplex-creating.svg
deleted file mode 100644
index 138935d..0000000
--- a/source/protocol/diagrams/duplex-messaging/duplex-creating.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg id="graph-div" width="100%" xmlns="http://www.w3.org/2000/svg" height="2941" style="max-width: 1470px;" viewBox="-50 -10 1470 2941"><style>#graph-div {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#graph-div .error-icon{fill:#552222;}#graph-div .error-text{fill:#552222;stroke:#552222;}#graph-div .edge-thickness-normal{stroke-width:2px;}#graph-div .edge-thickness-thick{stroke-width:3.5px;}#graph-div .edge-pattern-solid{stroke-dasharray:0;}#graph-div .edge-pattern-dashed{stroke-dasharray:3;}#graph-div .edge-pattern-dotted{stroke-dasharray:2;}#graph-div .marker{fill:#333333;stroke:#333333;}#graph-div .marker.cross{stroke:#333333;}#graph-div svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#graph-div .actor{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#graph-div text.actor&gt;tspan{fill:black;stroke:none;}#graph-div .actor-line{stroke:grey;}#graph-div .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#graph-div .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#graph-div #arrowhead path{fill:#333;stroke:#333;}#graph-div .sequenceNumber{fill:white;}#graph-div #sequencenumber{fill:#333;}#graph-div #crosshead path{fill:#333;stroke:#333;}#graph-div .messageText{fill:#333;stroke:#333;}#graph-div .labelBox{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#graph-div .labelText,#graph-div .labelText&gt;tspan{fill:black;stroke:none;}#graph-div .loopText,#graph-div .loopText&gt;tspan{fill:black;stroke:none;}#graph-div .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);}#graph-div .note{stroke:#aaaa33;fill:#fff5ad;}#graph-div .noteText,#graph-div .noteText&gt;tspan{fill:black;stroke:none;}#graph-div .activation0{fill:#f4f4f4;stroke:#666;}#graph-div .activation1{fill:#f4f4f4;stroke:#666;}#graph-div .activation2{fill:#f4f4f4;stroke:#666;}#graph-div :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g></g><g><line id="actor1659" x1="75" y1="5" x2="75" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Alice</tspan></text></g><g><line id="actor1660" x1="390" y1="5" x2="390" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="315" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="390" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="390" dy="-7">Alice's</tspan></text><text x="390" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="390" dy="7">agent</tspan></text></g><g><line id="actor1661" x1="647" y1="5" x2="647" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="572" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="647" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="647" dy="-7">Alice's</tspan></text><text x="647" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="647" dy="7">server</tspan></text></g><g><line id="actor1662" x1="847" y1="5" x2="847" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="772" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="847" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="847" dy="-7">Bob's</tspan></text><text x="847" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="847" dy="7">server</tspan></text></g><g><line id="actor1663" x1="1095" y1="5" x2="1095" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="1020" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="1095" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1095" dy="-7">Bob's</tspan></text><text x="1095" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1095" dy="7">agent</tspan></text></g><g><line id="actor1664" x1="1295" y1="5" x2="1295" y2="2930" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="1220" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="1295" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1295" dy="0">Bob</tspan></text></g><defs><marker id="arrowhead" refX="9" refY="5" markerUnits="userSpaceOnUse" markerWidth="12" markerHeight="12" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><defs><marker id="filled-head" refX="18" refY="7" markerWidth="20" markerHeight="28" orient="auto"><path d="M 18,7 L9,13 L14,7 L9,1 Z"></path></marker></defs><defs><marker id="sequencenumber" refX="15" refY="15" markerWidth="60" markerHeight="40" orient="auto"><circle cx="15" cy="15" r="6"></circle></marker></defs><g><rect x="365" y="75" fill="#EDF2AE" stroke="#666" width="755" height="36" rx="0" ry="0" class="note"></rect><text x="743" y="80" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="743">status (receive/send): NONE/NONE</tspan></text></g><g><rect x="50" y="121" fill="#EDF2AE" stroke="#666" width="365" height="36" rx="0" ry="0" class="note"></rect><text x="233" y="126" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="233">1. request connection from agent</tspan></text></g><text x="233" y="172" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">NEW: create</text><text x="233" y="191" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">duplex connection</text><line x1="75" y1="224" x2="390" y2="224" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="365" y="234" fill="#EDF2AE" stroke="#666" width="307" height="36" rx="0" ry="0" class="note"></rect><text x="519" y="239" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="519">2. create Alice's SMP queue</tspan></text></g><text x="519" y="285" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">NEW: create SMP queue</text><line x1="390" y1="318" x2="647" y2="318" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="519" y="333" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">IDS: SMP queue IDs</text><line x1="647" y1="366" x2="390" y2="366" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="315" y="376" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="381" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: NEW/NONE</tspan></text></g><text x="233" y="427" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">INV: invitation</text><text x="233" y="446" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">to connect</text><line x1="390" y1="479" x2="75" y2="479" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="308" y="489" fill="#EDF2AE" stroke="#666" width="164" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="494" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: PENDING/NONE</tspan></text></g><g><rect x="50" y="535" fill="#EDF2AE" stroke="#666" width="1270" height="36" rx="0" ry="0" class="note"></rect><text x="685" y="540" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="685">3. out-of-band invitation</tspan></text></g><text x="685" y="586" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">OOB: invitation to connect</text><line x1="75" y1="619" x2="1295" y2="619" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1070" y="629" fill="#EDF2AE" stroke="#666" width="250" height="36" rx="0" ry="0" class="note"></rect><text x="1195" y="634" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1195">4. accept connection</tspan></text></g><text x="1195" y="680" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">JOIN:</text><text x="1195" y="699" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">via invitation info</text><line x1="1295" y1="732" x2="1095" y2="732" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1020" y="742" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="747" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: NONE/NEW</tspan></text></g><g><rect x="365" y="788" fill="#EDF2AE" stroke="#666" width="755" height="36" rx="0" ry="0" class="note"></rect><text x="743" y="793" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="743">5. establish Alice's SMP queue</tspan></text></g><text x="871" y="839" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">SEND: Bob's info and sender server key (SMP confirmation)</text><line x1="1095" y1="872" x2="647" y2="872" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1004.5" y="882" fill="#EDF2AE" stroke="#666" width="181" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="887" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: NONE/CONFIRMED</tspan></text></g><g><rect x="1090" y="918" fill="#EDF2AE" stroke="#666" width="10" height="437" rx="0" ry="0" class="activation0"></rect></g><text x="519" y="933" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">MSG: Bob's info and</text><text x="519" y="952" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">sender server key</text><line x1="647" y1="985" x2="390" y2="985" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="299.5" y="995" fill="#EDF2AE" stroke="#666" width="181" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="1000" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: CONFIRMED/NONE</tspan></text></g><text x="519" y="1046" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACK: confirm message</text><line x1="390" y1="1079" x2="647" y2="1079" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="233" y="1094" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">REQ: connection request ID</text><text x="233" y="1113" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">and Bob's info</text><line x1="390" y1="1146" x2="75" y2="1146" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="233" y="1161" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACPT: accept connection request,</text><text x="233" y="1180" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">send Alice's info</text><line x1="75" y1="1213" x2="390" y2="1213" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="519" y="1228" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">KEY: secure queue</text><line x1="390" y1="1261" x2="647" y2="1261" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="307.5" y="1271" fill="#EDF2AE" stroke="#666" width="165" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="1276" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: SECURED/NONE</tspan></text></g><text x="869" y="1322" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">SEND: HELLO: try sending until successful</text><line x1="1090" y1="1355" x2="647" y2="1355" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1018.5" y="1365" fill="#EDF2AE" stroke="#666" width="153" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="1370" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: NONE/ACTIVE</tspan></text></g><text x="519" y="1416" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">MSG: HELLO: Alice's agent</text><text x="519" y="1435" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">knows Bob can send</text><line x1="647" y1="1468" x2="390" y2="1468" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="313.5" y="1478" fill="#EDF2AE" stroke="#666" width="153" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="1483" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: ACTIVE/NONE</tspan></text></g><text x="519" y="1529" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACK: confirm message</text><line x1="390" y1="1562" x2="647" y2="1562" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="822" y="1572" fill="#EDF2AE" stroke="#666" width="298" height="36" rx="0" ry="0" class="note"></rect><text x="971" y="1577" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="971">6. create Bob's SMP queue</tspan></text></g><text x="971" y="1623" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">NEW: create SMP queue</text><line x1="1095" y1="1656" x2="847" y2="1656" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="971" y="1671" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">IDS: SMP queue IDs</text><line x1="847" y1="1704" x2="1095" y2="1704" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1020" y="1714" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="1719" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: NEW/ACTIVE</tspan></text></g><g><rect x="365" y="1760" fill="#EDF2AE" stroke="#666" width="755" height="36" rx="0" ry="0" class="note"></rect><text x="743" y="1765" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="743">7. establish Bob's SMP queue</tspan></text></g><text x="871" y="1811" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">SEND: REPLY: invitation to the connect</text><line x1="1095" y1="1844" x2="647" y2="1844" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1008" y="1854" fill="#EDF2AE" stroke="#666" width="174" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="1859" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: PENDING/ACTIVE</tspan></text></g><text x="519" y="1905" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">MSG: REPLY: invitation</text><text x="519" y="1924" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">to connect</text><line x1="647" y1="1957" x2="390" y2="1957" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="315" y="1967" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="1972" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: ACTIVE/NEW</tspan></text></g><text x="519" y="2018" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACK: confirm message</text><line x1="390" y1="2051" x2="647" y2="2051" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="619" y="2066" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">SEND: Alice's info and sender's server key</text><line x1="390" y1="2099" x2="847" y2="2099" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="294.5" y="2109" fill="#EDF2AE" stroke="#666" width="191" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="2114" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: ACTIVE/CONFIRMED</tspan></text></g><g><rect x="385" y="2145" fill="#EDF2AE" stroke="#666" width="10" height="351" rx="0" ry="0" class="activation0"></rect></g><text x="971" y="2160" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">MSG: Alice's info and</text><text x="971" y="2179" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">sender's server key</text><line x1="847" y1="2212" x2="1095" y2="2212" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="999.5" y="2222" fill="#EDF2AE" stroke="#666" width="191" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="2227" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: CONFIRMED/ACTIVE</tspan></text></g><text x="1195" y="2273" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">INFO: Alice's info</text><line x1="1095" y1="2306" x2="1295" y2="2306" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="971" y="2321" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACK: confirm message</text><line x1="1095" y1="2354" x2="847" y2="2354" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="971" y="2369" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">KEY: secure queue</text><line x1="1095" y1="2402" x2="847" y2="2402" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1008" y="2412" fill="#EDF2AE" stroke="#666" width="174" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="2417" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: SECURED/ACTIVE</tspan></text></g><text x="621" y="2463" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">SEND: HELLO: try sending until successful</text><line x1="395" y1="2496" x2="847" y2="2496" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="308.5" y="2506" fill="#EDF2AE" stroke="#666" width="163" height="36" rx="0" ry="0" class="note"></rect><text x="390" y="2511" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="390">status: ACTIVE/ACTIVE</tspan></text></g><text x="971" y="2557" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">MSG: HELLO: Bob's agent</text><text x="971" y="2576" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">knows Alice can send</text><line x1="847" y1="2609" x2="1095" y2="2609" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="1013.5" y="2619" fill="#EDF2AE" stroke="#666" width="163" height="36" rx="0" ry="0" class="note"></rect><text x="1095" y="2624" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="1095">status: ACTIVE/ACTIVE</tspan></text></g><text x="971" y="2670" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">ACK: confirm message</text><line x1="1095" y1="2703" x2="847" y2="2703" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="50" y="2713" fill="#EDF2AE" stroke="#666" width="1270" height="36" rx="0" ry="0" class="note"></rect><text x="685" y="2718" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 14px; font-weight: 400;"><tspan x="685">8. notify users about connection success</tspan></text></g><text x="233" y="2764" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">CON: connected</text><line x1="390" y1="2797" x2="75" y2="2797" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="1195" y="2812" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial, sans-serif; font-size: 16px; font-weight: 400;">CON: connected</text><line x1="1095" y1="2845" x2="1295" y2="2845" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="0" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Alice</tspan></text></g><g><rect x="315" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="390" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="390" dy="-7">Alice's</tspan></text><text x="390" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="390" dy="7">agent</tspan></text></g><g><rect x="572" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="647" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="647" dy="-7">Alice's</tspan></text><text x="647" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="647" dy="7">server</tspan></text></g><g><rect x="772" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="847" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="847" dy="-7">Bob's</tspan></text><text x="847" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="847" dy="7">server</tspan></text></g><g><rect x="1020" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="1095" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1095" dy="-7">Bob's</tspan></text><text x="1095" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1095" dy="7">agent</tspan></text></g><g><rect x="1220" y="2865" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="1295" y="2897.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="1295" dy="0">Bob</tspan></text></g></svg>
\ No newline at end of file
diff --git a/source/protocol/diagrams/notifications/register-token.mmd b/source/protocol/diagrams/notifications/register-token.mmd
deleted file mode 100644
index bceef29..0000000
--- a/source/protocol/diagrams/notifications/register-token.mmd
+++ /dev/null
@@ -1,30 +0,0 @@
-sequenceDiagram
-  participant M as mobile app
-  participant C as chat core
-  participant A as agent
-  participant P as push server
-  participant APN as APN
-
-  note over M, APN: get device token
-  M ->> APN: registerForRemoteNotifications()
-  APN ->> M: device token
-
-  note over M, P: register device token with push server
-  M ->> C: /_ntf register <token>
-  C ->> A: registerNtfToken(<token>)
-  A ->> P: TNEW
-  P ->> A: ID (tokenId)
-  A ->> C: registered
-  C ->> M: registered
-
-  note over M, APN: verify device token
-  P ->> APN: E2E encrypted code<br>in background<br>notification
-  APN ->> M: deliver background notification with e2ee verification token
-  M ->> C: /_ntf verify <e2ee code>
-  C ->> A: verifyNtfToken(<e2ee code>)
-  A ->> P: TVFY code
-  P ->> A: OK / ERR
-  A ->> C: verified
-  C ->> M: verified
-
-  note over M, APN: now token ID can be used
diff --git a/source/protocol/diagrams/notifications/subscription.mmd b/source/protocol/diagrams/notifications/subscription.mmd
deleted file mode 100644
index 0db7cd7..0000000
--- a/source/protocol/diagrams/notifications/subscription.mmd
+++ /dev/null
@@ -1,40 +0,0 @@
-sequenceDiagram
-  participant M as mobile app
-  participant C as chat core
-  participant A as agent
-  participant S as SMP server
-  participant N as NTF server
-  participant APN as APN
-
-  note over M, APN: register subscription
-
-  alt register existing
-    M -->> A: on /_ntf register, for subscribed queues
-  else create new connection
-    A -->> S: NEW / JOIN
-    note over A, S: ...<br>Connection handshake<br>...
-    S -->> A: CON
-  end
-  A ->> S: NKEY nKey
-  S ->> A: NID nId
-  A ->> N: SNEW tknId dhKey (smpServer, nId, nKey)
-  N ->> A: ID subId dhKey
-  N ->> S: NSUB nId
-  S ->> N: OK [/ NMSG]
-
-  note over M, APN: notify about message
-
-  S ->> N: NMSG
-  N ->> APN: APNSMutableContent<br>ntfQueue, nonce
-  APN ->> M: UNMutableNotificationContent
-  note over M, S: ...<br>Client awaken, message is received<br>...
-  S ->> M: message
-  note over M: mutate notification
-
-  note over M, APN: change APN token
-
-  APN ->> M: new device token
-  M -->> C: /_ntf_sub update tkn
-  C -->> A: updateNtfToken()
-  A -->> N: TUPD tknId newDeviceToken
-  note over M, N: ...<br>Verify token<br>...
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-creating.mmd b/source/protocol/diagrams/simplex-messaging/simplex-creating.mmd
deleted file mode 100644
index 5116c3b..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-creating.mmd
+++ /dev/null
@@ -1,20 +0,0 @@
-sequenceDiagram
-  participant B as Bob (sender)
-  participant S as server (queue RID)
-  participant A as Alice (recipient)
-
-  note over A: creating queue<br>("public" key RK<br>for msg retrieval)
-  A ->> S: 1. create queue ("NEW")
-  S ->> A: respond with queue RID and SID ("IDS")
-
-  note over A: out-of-band msg<br>(sender's queue SID<br>and "public" key EK<br>to encrypt msgs)
-  A -->> B: 2. send out-of-band message
-
-  note over B: confirm queue<br>("public" key SK for<br>sending messages<br>and any optional<br>info encrypted with<br>"public" key EK)
-  B ->>¬†S: 3. confirm queue ("SEND" command not signed)
-
-  S ->> A: 4. deliver Bob's message
-  note over A: decrypt message<br>("private" key EK)
-  A ->> S: 5. secure queue ("KEY", RK-signed)
-
-  note over S: 6. simplex<br>queue RID<br>is ready to use!
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-creating.svg b/source/protocol/diagrams/simplex-messaging/simplex-creating.svg
deleted file mode 100644
index 325fbb6..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-creating.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg id="mermaid-1603362111631" width="100%" xmlns="http://www.w3.org/2000/svg" height="875" style="max-width: 1006px;" viewBox="-50 -10 1006 875"><style>#mermaid-1603362111631{font-family:"trebuchet ms",verdana,arial;font-size:16px;fill:#333;}#mermaid-1603362111631 .error-icon{fill:#552222;}#mermaid-1603362111631 .error-text{fill:#552222;stroke:#552222;}#mermaid-1603362111631 .edge-thickness-normal{stroke-width:2px;}#mermaid-1603362111631 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1603362111631 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1603362111631 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1603362111631 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1603362111631 .marker{fill:#333333;}#mermaid-1603362111631 .marker.cross{stroke:#333333;}#mermaid-1603362111631 svg{font-family:"trebuchet ms",verdana,arial;font-size:16px;}#mermaid-1603362111631 .actor{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1603362111631 text.actor &gt; tspan{fill:black;stroke:none;}#mermaid-1603362111631 .actor-line{stroke:grey;}#mermaid-1603362111631 .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid-1603362111631 .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid-1603362111631 #arrowhead path{fill:#333;stroke:#333;}#mermaid-1603362111631 .sequenceNumber{fill:white;}#mermaid-1603362111631 #sequencenumber{fill:#333;}#mermaid-1603362111631 #crosshead path{fill:#333;stroke:#333;}#mermaid-1603362111631 .messageText{fill:#333;stroke:#333;}#mermaid-1603362111631 .labelBox{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1603362111631 .labelText,#mermaid-1603362111631 .labelText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362111631 .loopText,#mermaid-1603362111631 .loopText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362111631 .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:hsl(259.6261682243,59.7765363128%,87.9019607843%);}#mermaid-1603362111631 .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-1603362111631 .noteText,#mermaid-1603362111631 .noteText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362111631 .activation0{fill:#f4f4f4;stroke:#666;}#mermaid-1603362111631 .activation1{fill:#f4f4f4;stroke:#666;}#mermaid-1603362111631 .activation2{fill:#f4f4f4;stroke:#666;}#mermaid-1603362111631:root{--mermaid-font-family:"trebuchet ms",verdana,arial;}#mermaid-1603362111631 sequence{fill:apa;}</style><g></g><g><line id="actor612" x1="75" y1="5" x2="75" y2="864" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Bob (sender)</tspan></text></g><g><line id="actor613" x1="484" y1="5" x2="484" y2="864" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="409" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="484" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="484" dy="0">server (queue RID)</tspan></text></g><g><line id="actor614" x1="831" y1="5" x2="831" y2="864" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="756" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="831" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="831" dy="0">Alice (recipient)</tspan></text></g><defs><marker id="arrowhead" refX="5" refY="2" markerWidth="6" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><defs><marker id="sequencenumber" refX="15" refY="15" markerWidth="60" markerHeight="40" orient="auto"><circle cx="15" cy="15" r="6"></circle></marker></defs><g><rect x="756" y="75" fill="#EDF2AE" stroke="#666" width="150" height="68" rx="0" ry="0" class="note"></rect><text x="831" y="80" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">creating queue</tspan></text><text x="831" y="96" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">("public" key RK</tspan></text><text x="831" y="112" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">for msg retrieval)</tspan></text></g><text x="658" y="158" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">1. create queue ("NEW")</text><line x1="831" y1="189" x2="484" y2="189" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="658" y="204" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">respond with queue RID and SID ("IDS")</text><line x1="484" y1="235" x2="831" y2="235" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="756" y="245" fill="#EDF2AE" stroke="#666" width="150" height="84" rx="0" ry="0" class="note"></rect><text x="831" y="250" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">out-of-band msg</tspan></text><text x="831" y="266" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">(sender's queue SID</tspan></text><text x="831" y="282" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">and "public" key EK</tspan></text><text x="831" y="298" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">to encrypt msgs)</tspan></text></g><text x="453" y="344" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">2. send out-of-band message</text><line x1="831" y1="375" x2="75" y2="375" class="messageLine1" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="stroke-dasharray: 3, 3; fill: none;"></line><g><rect x="0" y="385" fill="#EDF2AE" stroke="#666" width="150" height="116" rx="0" ry="0" class="note"></rect><text x="75" y="390" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">confirm queue</tspan></text><text x="75" y="406" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">("public" key SK for</tspan></text><text x="75" y="422" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">sending messages</tspan></text><text x="75" y="438" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">and any optional</tspan></text><text x="75" y="454" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">info encrypted with</tspan></text><text x="75" y="470" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">"public" key EK)</tspan></text></g><text x="280" y="516" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">3. confirm queue ("SEND" command not signed)</text><line x1="75" y1="547" x2="484" y2="547" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="658" y="562" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">4. deliver Bob's message</text><line x1="484" y1="593" x2="831" y2="593" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="756" y="603" fill="#EDF2AE" stroke="#666" width="150" height="52" rx="0" ry="0" class="note"></rect><text x="831" y="608" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">decrypt message</tspan></text><text x="831" y="624" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="831">("private" key EK)</tspan></text></g><text x="658" y="670" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">5. secure queue ("KEY", RK-signed)</text><line x1="831" y1="701" x2="484" y2="701" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="409" y="711" fill="#EDF2AE" stroke="#666" width="150" height="68" rx="0" ry="0" class="note"></rect><text x="484" y="716" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="484">6. simplex</tspan></text><text x="484" y="732" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="484">queue RID</tspan></text><text x="484" y="748" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="484">is ready to use!</tspan></text></g><g><rect x="0" y="799" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="831.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Bob (sender)</tspan></text></g><g><rect x="409" y="799" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="484" y="831.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="484" dy="0">server (queue RID)</tspan></text></g><g><rect x="756" y="799" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="831" y="831.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="831" dy="0">Alice (recipient)</tspan></text></g></svg>
\ No newline at end of file
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-op.mmd b/source/protocol/diagrams/simplex-messaging/simplex-op.mmd
deleted file mode 100644
index cacdaa3..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-op.mmd
+++ /dev/null
@@ -1,26 +0,0 @@
-sequenceDiagram
-  participant S as sender (client)
-  participant A as transport
-  participant Q as pubsub
-  participant P as transport
-  participant R as receiver (client)
-  note over R: sign subscription (1)
-  R ->> P: subscribe to messages
-  note over P: verify subscriber (1)
-  alt subscriber verified?
-    P -->> Q: subscribe
-  else
-    P ->> R: reject subscription
-  end
-  note over S: sign message (2)
-  S ->> A: send message
-  note over A: verify sender (2)
-  alt sender verified?
-    A -->> Q: queue message
-    activate Q
-  else
-    A ->> S: reject message
-  end
-  Q -->> P: take message
-  deactivate Q
-  P ->> R: deliver message
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-op.svg b/source/protocol/diagrams/simplex-messaging/simplex-op.svg
deleted file mode 100644
index 1d69dad..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-op.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg id="mermaid-svg" width="100%" xmlns="http://www.w3.org/2000/svg" height="100%" style="max-width:1083px;" viewBox="-50 -10 1083 857"><style>#mermaid-svg{font-family:"trebuchet ms",verdana,arial;font-size:16px;fill:#333;}#mermaid-svg .error-icon{fill:#552222;}#mermaid-svg .error-text{fill:#552222;stroke:#552222;}#mermaid-svg .edge-thickness-normal{stroke-width:2px;}#mermaid-svg .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg .marker{fill:#333333;}#mermaid-svg .marker.cross{stroke:#333333;}#mermaid-svg svg{font-family:"trebuchet ms",verdana,arial;font-size:16px;}#mermaid-svg .actor{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-svg text.actor &gt; tspan{fill:black;stroke:none;}#mermaid-svg .actor-line{stroke:grey;}#mermaid-svg .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid-svg .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid-svg #arrowhead path{fill:#333;stroke:#333;}#mermaid-svg .sequenceNumber{fill:white;}#mermaid-svg #sequencenumber{fill:#333;}#mermaid-svg #crosshead path{fill:#333;stroke:#333;}#mermaid-svg .messageText{fill:#333;stroke:#333;}#mermaid-svg .labelBox{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-svg .labelText,#mermaid-svg .labelText &gt; tspan{fill:black;stroke:none;}#mermaid-svg .loopText,#mermaid-svg .loopText &gt; tspan{fill:black;stroke:none;}#mermaid-svg .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:hsl(259.6261682243,59.7765363128%,87.9019607843%);}#mermaid-svg .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-svg .noteText,#mermaid-svg .noteText &gt; tspan{fill:black;stroke:none;}#mermaid-svg .activation0{fill:#f4f4f4;stroke:#666;}#mermaid-svg .activation1{fill:#f4f4f4;stroke:#666;}#mermaid-svg .activation2{fill:#f4f4f4;stroke:#666;}#mermaid-svg:root{--mermaid-font-family:"trebuchet ms",verdana,arial;}#mermaid-svg sequence{fill:apa;}</style><g></g><g><line id="actor0" x1="75" y1="5" x2="75" y2="846" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">sender (client)</tspan></text></g><g><line id="actor1" x1="275" y1="5" x2="275" y2="846" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="200" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="275" dy="0">transport</tspan></text></g><g><line id="actor2" x1="475" y1="5" x2="475" y2="846" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="400" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="475" dy="0">pubsub</tspan></text></g><g><line id="actor3" x1="675" y1="5" x2="675" y2="846" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="600" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="675" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="675" dy="0">transport</tspan></text></g><g><line id="actor4" x1="908" y1="5" x2="908" y2="846" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="833" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="908" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="908" dy="0">receiver (client)</tspan></text></g><defs><marker id="arrowhead" refX="5" refY="2" markerWidth="6" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><defs><marker id="sequencenumber" refX="15" refY="15" markerWidth="60" markerHeight="40" orient="auto"><circle cx="15" cy="15" r="6"></circle></marker></defs><g><rect x="833" y="75" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="908" y="80" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="908">sign subscription (1)</tspan></text></g><text x="792" y="126" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">subscribe to messages</text><line x1="908" y1="155" x2="675" y2="155" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="600" y="165" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="675" y="170" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="675">verify subscriber (1)</tspan></text></g><text x="575" y="261" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">subscribe</text><line x1="675" y1="290" x2="475" y2="290" class="messageLine1" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="stroke-dasharray: 3, 3; fill: none;"></line><text x="792" y="330" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">reject subscription</text><line x1="675" y1="359" x2="908" y2="359" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><line x1="465" y1="211" x2="918" y2="211" class="loopLine"></line><line x1="918" y1="211" x2="918" y2="369" class="loopLine"></line><line x1="465" y1="369" x2="918" y2="369" class="loopLine"></line><line x1="465" y1="211" x2="465" y2="369" class="loopLine"></line><line x1="465" y1="305" x2="918" y2="305" class="loopLine" style="stroke-dasharray: 3, 3;"></line><polygon points="465,211 515,211 515,224 506.6,231 465,231" class="labelBox"></polygon><text x="490" y="224" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="labelText" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">alt</text><text x="716.5" y="229" text-anchor="middle" class="loopText" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;"><tspan x="716.5">[subscriber verified?]</tspan></text></g><g><rect x="0" y="379" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="75" y="384" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">sign message (2)</tspan></text></g><text x="175" y="430" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">send message</text><line x1="75" y1="459" x2="275" y2="459" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="200" y="469" fill="#EDF2AE" stroke="#666" width="150" height="36" rx="0" ry="0" class="note"></rect><text x="275" y="474" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="275">verify sender (2)</tspan></text></g><text x="375" y="565" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">queue message</text><line x1="275" y1="594" x2="475" y2="594" class="messageLine1" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="stroke-dasharray: 3, 3; fill: none;"></line><g><rect x="470" y="596" fill="#EDF2AE" stroke="#666" width="10" height="121" rx="0" ry="0" class="activation0"></rect></g><text x="175" y="634" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">reject message</text><line x1="275" y1="663" x2="75" y2="663" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><line x1="65" y1="515" x2="485" y2="515" class="loopLine"></line><line x1="485" y1="515" x2="485" y2="673" class="loopLine"></line><line x1="65" y1="673" x2="485" y2="673" class="loopLine"></line><line x1="65" y1="515" x2="65" y2="673" class="loopLine"></line><line x1="65" y1="609" x2="485" y2="609" class="loopLine" style="stroke-dasharray: 3, 3;"></line><polygon points="65,515 115,515 115,528 106.6,535 65,535" class="labelBox"></polygon><text x="90" y="528" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="labelText" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">alt</text><text x="300" y="533" text-anchor="middle" class="loopText" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;"><tspan x="300">[sender verified?]</tspan></text></g><text x="578" y="688" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">take message</text><line x1="480" y1="717" x2="675" y2="717" class="messageLine1" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="stroke-dasharray: 3, 3; fill: none;"></line><text x="792" y="732" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">deliver message</text><line x1="675" y1="761" x2="908" y2="761" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="0" y="781" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="813.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">sender (client)</tspan></text></g><g><rect x="200" y="781" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="275" y="813.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="275" dy="0">transport</tspan></text></g><g><rect x="400" y="781" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="475" y="813.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="475" dy="0">pubsub</tspan></text></g><g><rect x="600" y="781" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="675" y="813.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="675" dy="0">transport</tspan></text></g><g><rect x="833" y="781" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="908" y="813.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="908" dy="0">receiver (client)</tspan></text></g></svg>
\ No newline at end of file
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-using.mmd b/source/protocol/diagrams/simplex-messaging/simplex-using.mmd
deleted file mode 100644
index 3bf0e40..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-using.mmd
+++ /dev/null
@@ -1,10 +0,0 @@
-sequenceDiagram
-  participant B as Bob (sender)
-  participant S as server (queue RID)
-  participant A as Alice (recipient)
-
-  note over B: encrypt message<br>("public" key EK)
-  B ->> S: 1. send message to SID (SK-signed command)
-
-  S ->> A: 2. receive messages from RID (RK-signed subscription)
-  note over A: decrypt message<br>("private" key EK)
diff --git a/source/protocol/diagrams/simplex-messaging/simplex-using.svg b/source/protocol/diagrams/simplex-messaging/simplex-using.svg
deleted file mode 100644
index 3cb04dd..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex-using.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg id="mermaid-1603362302206" width="100%" xmlns="http://www.w3.org/2000/svg" height="377" style="max-width: 1100px;" viewBox="-50 -10 1100 377"><style>#mermaid-1603362302206{font-family:"trebuchet ms",verdana,arial;font-size:16px;fill:#333;}#mermaid-1603362302206 .error-icon{fill:#552222;}#mermaid-1603362302206 .error-text{fill:#552222;stroke:#552222;}#mermaid-1603362302206 .edge-thickness-normal{stroke-width:2px;}#mermaid-1603362302206 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1603362302206 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1603362302206 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1603362302206 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1603362302206 .marker{fill:#333333;}#mermaid-1603362302206 .marker.cross{stroke:#333333;}#mermaid-1603362302206 svg{font-family:"trebuchet ms",verdana,arial;font-size:16px;}#mermaid-1603362302206 .actor{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1603362302206 text.actor &gt; tspan{fill:black;stroke:none;}#mermaid-1603362302206 .actor-line{stroke:grey;}#mermaid-1603362302206 .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid-1603362302206 .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid-1603362302206 #arrowhead path{fill:#333;stroke:#333;}#mermaid-1603362302206 .sequenceNumber{fill:white;}#mermaid-1603362302206 #sequencenumber{fill:#333;}#mermaid-1603362302206 #crosshead path{fill:#333;stroke:#333;}#mermaid-1603362302206 .messageText{fill:#333;stroke:#333;}#mermaid-1603362302206 .labelBox{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1603362302206 .labelText,#mermaid-1603362302206 .labelText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362302206 .loopText,#mermaid-1603362302206 .loopText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362302206 .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:hsl(259.6261682243,59.7765363128%,87.9019607843%);}#mermaid-1603362302206 .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-1603362302206 .noteText,#mermaid-1603362302206 .noteText &gt; tspan{fill:black;stroke:none;}#mermaid-1603362302206 .activation0{fill:#f4f4f4;stroke:#666;}#mermaid-1603362302206 .activation1{fill:#f4f4f4;stroke:#666;}#mermaid-1603362302206 .activation2{fill:#f4f4f4;stroke:#666;}#mermaid-1603362302206:root{--mermaid-font-family:"trebuchet ms",verdana,arial;}#mermaid-1603362302206 sequence{fill:apa;}</style><g></g><g><line id="actor706" x1="75" y1="5" x2="75" y2="366" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="0" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Bob (sender)</tspan></text></g><g><line id="actor707" x1="467" y1="5" x2="467" y2="366" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="392" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="467" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="467" dy="0">server (queue RID)</tspan></text></g><g><line id="actor708" x1="925" y1="5" x2="925" y2="366" class="actor-line" stroke-width="0.5px" stroke="#999"></line><rect x="850" y="0" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="925" y="32.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="925" dy="0">Alice (recipient)</tspan></text></g><defs><marker id="arrowhead" refX="5" refY="2" markerWidth="6" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker></defs><defs><marker id="crosshead" markerWidth="15" markerHeight="8" orient="auto" refX="16" refY="4"><path fill="black" stroke="#000000" stroke-width="1px" d="M 9,2 V 6 L16,4 Z" style="stroke-dasharray: 0, 0;"></path><path fill="none" stroke="#000000" stroke-width="1px" d="M 0,1 L 6,7 M 6,1 L 0,7" style="stroke-dasharray: 0, 0;"></path></marker></defs><defs><marker id="sequencenumber" refX="15" refY="15" markerWidth="60" markerHeight="40" orient="auto"><circle cx="15" cy="15" r="6"></circle></marker></defs><g><rect x="0" y="75" fill="#EDF2AE" stroke="#666" width="150" height="52" rx="0" ry="0" class="note"></rect><text x="75" y="80" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">encrypt message</tspan></text><text x="75" y="96" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="75">("public" key EK)</tspan></text></g><text x="271" y="142" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">1. send message to SID (SK-signed command)</text><line x1="75" y1="173" x2="467" y2="173" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><text x="696" y="188" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="messageText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 16px; font-weight: 400;">2. receive messages from RID (RK-signed subscription)</text><line x1="467" y1="219" x2="925" y2="219" class="messageLine0" stroke-width="2" stroke="none" marker-end="url(#arrowhead)" style="fill: none;"></line><g><rect x="850" y="229" fill="#EDF2AE" stroke="#666" width="150" height="52" rx="0" ry="0" class="note"></rect><text x="925" y="234" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="925">decrypt message</tspan></text><text x="925" y="250" text-anchor="middle" dominant-baseline="middle" alignment-baseline="middle" class="noteText" dy="1em" style="font-family: &quot;trebuchet ms&quot;, verdana, arial; font-size: 14px; font-weight: 400;"><tspan x="925">("private" key EK)</tspan></text></g><g><rect x="0" y="301" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="75" y="333.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="75" dy="0">Bob (sender)</tspan></text></g><g><rect x="392" y="301" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="467" y="333.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="467" dy="0">server (queue RID)</tspan></text></g><g><rect x="850" y="301" fill="#eaeaea" stroke="#666" width="150" height="65" rx="3" ry="3" class="actor"></rect><text x="925" y="333.5" dominant-baseline="central" alignment-baseline="central" class="actor" style="text-anchor: middle; font-size: 14px; font-weight: 400; font-family: Open-Sans, sans-serif;"><tspan x="925" dy="0">Alice (recipient)</tspan></text></g></svg>
\ No newline at end of file
diff --git a/source/protocol/diagrams/simplex-messaging/simplex.mmd b/source/protocol/diagrams/simplex-messaging/simplex.mmd
deleted file mode 100644
index ca951f1..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex.mmd
+++ /dev/null
@@ -1,11 +0,0 @@
-graph LR
-  VS{{"verify sender (SK)"}}
-  VR{{"verify recipient (RK)"}}
-
-  S(sender) -->|msg| VS
-  subgraph "server (queue RID, SID)"
-    VS --> DB[("storage")]
-    DB --> VR
-  end
-  R(recipient) -->|"1) sub"| VR
-  VR -->|"2) msg"| R
diff --git a/source/protocol/diagrams/simplex-messaging/simplex.svg b/source/protocol/diagrams/simplex-messaging/simplex.svg
deleted file mode 100644
index 8673417..0000000
--- a/source/protocol/diagrams/simplex-messaging/simplex.svg
+++ /dev/null
@@ -1 +0,0 @@
-<svg id="mermaid-1619098539359" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="157.2029266357422" style="max-width: 917.600830078125px;" viewBox="0 0 917.600830078125 157.2029266357422"><style>#mermaid-1619098539359{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1619098539359 .error-icon{fill:#552222;}#mermaid-1619098539359 .error-text{fill:#552222;stroke:#552222;}#mermaid-1619098539359 .edge-thickness-normal{stroke-width:2px;}#mermaid-1619098539359 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1619098539359 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1619098539359 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1619098539359 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1619098539359 .marker{fill:#333333;stroke:#333333;}#mermaid-1619098539359 .marker.cross{stroke:#333333;}#mermaid-1619098539359 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1619098539359 .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-1619098539359 .cluster-label text{fill:#333;}#mermaid-1619098539359 .cluster-label span{color:#333;}#mermaid-1619098539359 .label text,#mermaid-1619098539359 span{fill:#333;color:#333;}#mermaid-1619098539359 .node rect,#mermaid-1619098539359 .node circle,#mermaid-1619098539359 .node ellipse,#mermaid-1619098539359 .node polygon,#mermaid-1619098539359 .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-1619098539359 .node .label{text-align:center;}#mermaid-1619098539359 .node.clickable{cursor:pointer;}#mermaid-1619098539359 .arrowheadPath{fill:#333333;}#mermaid-1619098539359 .edgePath .path{stroke:#333333;stroke-width:1.5px;}#mermaid-1619098539359 .flowchart-link{stroke:#333333;fill:none;}#mermaid-1619098539359 .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-1619098539359 .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-1619098539359 .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-1619098539359 .cluster text{fill:#333;}#mermaid-1619098539359 .cluster span{color:#333;}#mermaid-1619098539359 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80,100%,96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-1619098539359:root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-1619098539359 flowchart{fill:apa;}</style><g><g class="output"><g class="clusters"><g class="cluster" id="flowchart-subGraph0-403" style="opacity: 1;" transform="translate(440.8004150390625,78.6014633178711)"><rect width="574.3341369628906" height="141.2029266357422" x="-287.1670684814453" y="-70.6014633178711"></rect><g class="label" transform="translate(0, -56.601463317871094)" id="mermaid-1619098539359Text"><g transform="translate(-82.875,-9.199996948242188)"><foreignObject width="165.75" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">server (queue RID, SID)</div></foreignObject></g></g></g></g><g class="edgePaths"><g class="edgePath LS-S LE-VS" style="opacity: 1;" id="L-S-VS"><path class="path" d="M75.83334350585938,81.20097351074219L114.73334503173828,81.20097351074219L153.6333465576172,81.20097351074219L179.13334655761716,81.70097351074219" marker-end="url(#arrowhead482)" style="fill:none"></path><defs><marker id="arrowhead482" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1px; stroke-dasharray: 1px, 0px;"></path></marker></defs></g><g class="edgePath LS-VS LE-DB" style="opacity: 1;" id="L-VS-DB"><path class="path" d="M345.6333465576172,81.70097351074219L370.1333465576172,81.20097351074219L395.1333465576172,81.20097351074219" marker-end="url(#arrowhead483)" style="fill:none"></path><defs><marker id="arrowhead483" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1px; stroke-dasharray: 1px, 0px;"></path></marker></defs></g><g class="edgePath LS-DB LE-VR" style="opacity: 1;" id="L-DB-VR"><path class="path" d="M467.9341278076172,81.20097351074219L492.9341278076172,81.20097351074219L518.4341278076172,81.70097351074219" marker-end="url(#arrowhead484)" style="fill:none"></path><defs><marker id="arrowhead484" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1px; stroke-dasharray: 1px, 0px;"></path></marker></defs></g><g class="edgePath LS-R LE-VR" style="opacity: 1;" id="L-R-VR"><path class="path" d="M824.8508148193359,92.39981432441061L776.4091491699219,105.20195007324219L727.9674835205078,105.20195007324219L694.8952831342032,98.84534376577363" marker-end="url(#arrowhead485)" style="fill:none"></path><defs><marker id="arrowhead485" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1px; stroke-dasharray: 1px, 0px;"></path></marker></defs></g><g class="edgePath LS-VR LE-R" style="opacity: 1;" id="L-VR-R"><path class="path" d="M696.4805028579143,67.72704270313326L727.9674835205078,62.0009765625L776.4091491699219,62.0009765625L824.8508148193359,72.24226681452237" marker-end="url(#arrowhead486)" style="fill:none"></path><defs><marker id="arrowhead486" viewBox="0 0 10 10" refX="9" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowheadPath" style="stroke-width: 1px; stroke-dasharray: 1px, 0px;"></path></marker></defs></g></g><g class="edgeLabels"><g class="edgeLabel" style="opacity: 1;" transform="translate(114.73334503173828,81.20097351074219)"><g transform="translate(-13.900001525878906,-9.199996948242188)" class="label"><rect rx="0" ry="0" width="27.800003051757812" height="18.399993896484375"></rect><foreignObject width="27.800003051757812" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-S-VS" class="edgeLabel L-LS-S' L-LE-VS">msg</span></div></foreignObject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-VS-DB" class="edgeLabel L-LS-VS' L-LE-DB"></span></div></foreignObject></g></g><g class="edgeLabel" style="opacity: 1;" transform=""><g transform="translate(0,0)" class="label"><rect rx="0" ry="0" width="0" height="0"></rect><foreignObject width="0" height="0"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-DB-VR" class="edgeLabel L-LS-DB' L-LE-VR"></span></div></foreignObject></g></g><g class="edgeLabel" style="opacity: 1;" transform="translate(776.4091491699219,105.20195007324219)"><g transform="translate(-21.616661071777344,-9.199996948242188)" class="label"><rect rx="0" ry="0" width="43.23332214355469" height="18.399993896484375"></rect><foreignObject width="43.23332214355469" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-R-VR" class="edgeLabel L-LS-R' L-LE-VR">1) sub</span></div></foreignObject></g></g><g class="edgeLabel" style="opacity: 1;" transform="translate(776.4091491699219,62.0009765625)"><g transform="translate(-23.441665649414062,-9.199996948242188)" class="label"><rect rx="0" ry="0" width="46.883331298828125" height="18.399993896484375"></rect><foreignObject width="46.883331298828125" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;"><span id="L-L-VR-R" class="edgeLabel L-LS-VR' L-LE-R">2) msg</span></div></foreignObject></g></g></g><g class="nodes"><g class="node default" style="opacity: 1;" id="flowchart-DB-396" label-offset-y="9.201213590566582" transform="translate(431.5337371826172,81.20097351074219)"><path d="M 0,9.201213590566582 a 36.400001525878906,9.201213590566582 0,0,0 72.80000305175781 0 a 36.400001525878906,9.201213590566582 0,0,0 -72.80000305175781 0 l 0,47.60120748705096 a 36.400001525878906,9.201213590566582 0,0,0 72.80000305175781 0 l 0,-47.60120748705096" transform="translate(-36.400001525878906,-33.00181733409206)" class="label-container"></path><g class="label" transform="translate(0,0)"><g transform="translate(-26.400001525878906,-9.199996948242188)"><foreignObject width="52.80000305175781" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">storage</div></foreignObject></g></g></g><g class="node default" style="opacity: 1;" id="flowchart-VS-391" transform="translate(261.8833465576172,81.20097351074219)"><polygon points="9.599998474121094,0 156.9000015258789,0 166.5,-19.199996948242188 156.9000015258789,-38.399993896484375 9.599998474121094,-38.399993896484375 0,-19.199996948242188" transform="translate(-83.25,19.199996948242188)" class="label-container"></polygon><g class="label" transform="translate(0,0)"><g transform="translate(-63.650001525878906,-9.199996948242188)"><foreignObject width="127.30000305175781" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">verify sender (SK)</div></foreignObject></g></g></g><g class="node default" style="opacity: 1;" id="flowchart-VR-392" transform="translate(610.4508056640625,81.20097351074219)"><polygon points="9.599998474121094,0 175.43334197998047,0 185.03334045410156,-19.199996948242188 175.43334197998047,-38.399993896484375 9.599998474121094,-38.399993896484375 0,-19.199996948242188" transform="translate(-92.51667022705078,19.199996948242188)" class="label-container"></polygon><g class="label" transform="translate(0,0)"><g transform="translate(-72.91667175292969,-9.199996948242188)"><foreignObject width="145.83334350585938" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">verify recipient (RK)</div></foreignObject></g></g></g><g class="node default" style="opacity: 1;" id="flowchart-S-393" transform="translate(41.91667175292969,81.20097351074219)"><rect rx="5" ry="5" x="-33.91667175292969" y="-19.199996948242188" width="67.83334350585938" height="38.399993896484375" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-23.916671752929688,-9.199996948242188)"><foreignObject width="47.833343505859375" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">sender</div></foreignObject></g></g></g><g class="node default" style="opacity: 1;" id="flowchart-R-399" transform="translate(867.2258148193359,81.20097351074219)"><rect rx="5" ry="5" x="-42.375" y="-19.199996948242188" width="84.75" height="38.399993896484375" class="label-container"></rect><g class="label" transform="translate(0,0)"><g transform="translate(-32.375,-9.199996948242188)"><foreignObject width="64.75" height="18.399993896484375"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; white-space: nowrap;">recipient</div></foreignObject></g></g></g></g></g></g></svg>
\ No newline at end of file
diff --git a/source/protocol/overview-tjr.md b/source/protocol/overview-tjr.md
deleted file mode 100644
index 7f1e727..0000000
--- a/source/protocol/overview-tjr.md
+++ /dev/null
@@ -1,313 +0,0 @@
-Revision 1, 2022-01-01
-
-Evgeny Poberezkin
-
-# SimpleX: messaging and application platform
-
-## Table of contents
-
-- [Introduction](#introduction)
-  - [What is SimpleX](#what-is-simplex)
-  - [SimpleX objectives](#simplex-objectives)
-  - [In Comparison](#in-comparison)
-- [Technical Details](#technical-details)
-  - [Trust in Servers](#trust-in-servers)
-  - [Client -> Server Communication](#client---server-communication)
-  - [SimpleX Messaging Protocol](#simplex-messaging-protocol)
-  - [SimpleX Agents](#simplex-agents)
-  - [Encryption Primitives Used](#encryption-primitives-used)
-- [Threat model](#threat-model)
-- [Acknowledgements](#acknowledgements)
-
-## Introduction
-
-#### What is SimpleX
-
-SimpleX as a whole is a platform upon which applications can be built. [SimpleX Chat](https://github.com/simplex-chat/simplex-chat) is one such application that also serves as an example and reference application.
-
- - [SimpleX Messaging Protocol](https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md) (SMP) is a protocol to send messages in one direction to a recipient, relying on a server in-between. The messages are delivered via uni-directional queues created by recipients.
-
- - SMP runs over a transport protocol (shown below as TLS) that provides integrity, server authentication, confidentiality, and transport channel binding.
-
- - A SimpleX Server is one of those servers.
-
- - The SimpleX Network is the term used for the collective of SimpleX Servers that facilitate SMP.
-
- - SimpleX Client libraries speak SMP to SimpleX Servers and provide a low-level API not generally intended to be used by applications.
-
- - SimpleX Agents interface with SimpleX Clients to provide a more high-level API intended to be used by applications. Typically they are embedded as libraries, but are designed so they can also be abstracted into local services.
-
-
-*Diagram showing the SimpleX Chat app, with logical layers of the chat application interfacing with a SimpleX Agent library, which in turn interfaces with a SimpleX Client library. The Client library in turn speaks the Messaging Protocol to a SimpleX Server.*
-
-```
-  User's Computer                 Internet                    Third-Party Server
-------------------     |   ----------------------     |   -------------------------
-                       |                              |
-   SimpleX Chat        |                              |
-                       |                              |
-+----------------+     |                              |
-|    Chat App    |     |                              |
-+----------------+     |                              |
-|  SimpleX Agent |     |                              |
-+----------------+    -------------- TLS ----------------    +----------------+
-| SimpleX Client | ------ SimpleX Messaging Protocol ------> | SimpleX Server |
-+----------------+    -----------------------------------    +----------------+
-                       |                              |
-```
-
-#### SimpleX objectives
-
-1. Provide messaging infrastructure for distributed applications. This infrastructure needs to have the following qualities:
-
-   - Security against passive and active (man-in-the-middle) attacks: the parties should have reliable end-to-end encryption and be able to detect the presence of an active attacker who modified, deleted or added messages.
-
-   - Privacy: protect against traffic correlation attacks to determine the contacts that the users communicate with.
-
-   - Reliability: the messages should be delivered even if some participating network servers or receiving clients fail, with ‚Äúat least once‚Äù delivery guarantee.
-
-   - Integrity: the messages sent in one direction are ordered in a way that sender and recipient agree on; the recipient can detect when a message was removed or changed.
-
-   - Asynchronous delivery: it should not be required that both communicating parties (client devices, services or applications) are online for reliable message delivery.
-
-   - Low latency: the delay introduced by the network should not be higher than 100ms-1s in addition to the underlying TCP network latency.
-
-2. Provide better communication security and privacy than the alternative instant messaging solutions.  In particular SimpleX provides better privacy of metadata (who talks to whom and when) and better security against active network attackers and malicious servers.
-
-3. Balance user experience with privacy requirements, prioritizing experience of mobile device users.
-
-#### In Comparison
-
-SimpleX network has a design similar to P2P networks, but unlike most P2P networks it consists of clients and servers without depending on any centralized component.
-In comparison to more traditional messaging applications (e.g. WhatsApp, Signal, Telegram) the key differences of SimpleX network are:
-
-- participants do not need to have globally unique addresses to communicate, instead they use redundant unidirectional (simplex) messaging queues, with a separate set of queues for each contact.
-
-- connection requests are passed out-of-band, non-optionally protecting key exchange against man-in-the-middle attack.
-
-- simple message queues provided by network servers are used by the clients to create more complex communication scenarios, such as duplex one-to-one communication, transmitting files, group communication without central servers, and content/communication channels.
-
-- servers do not store any user information (no user profiles or contacts, or messages once they are delivered), and primarily use in-memory persistence.
-
-- users can change servers with minimal disruption - even after an in-use server disappears, simply by changing the configuration on which servers the new queues are created.
-
-## Technical Details
-
-#### Trust in Servers
-
-Clients communicate directly with servers (but not with other clients) using SimpleX Messaging Protocol (SMP) running over some transport protocol that provides integrity, server authentication, confidentiality, and transport channel binding. By default, we assume this transport protocol is TLS.
-
-Users use multiple servers, and choose where to receive their messages. Accordingly, they send messages to their communication partners' chosen servers.
-
-Although end-to-end encryption is always present, users place a degree of trust in servers. This trust decision is very similar to a user's choice of email provider; however the trust placed in a SimpleX server is significantly less. Notably, there is no re-used identifier or credential between queues on the same (or different) servers. While a user *may* re-use a connection to fetch from multiple queues, or connect to a server from the same IP address, both are choices a user may opt into to break the promise of un-correlatable queues.
-
-Users may trust a server because:
-
-- They deploy and control the servers themselves from the available open-source code. This has the trade-offs of strong trust in the server but limited metadata obfuscation to a passive network observer. Techniques such as noise traffic, traffic mixing (incurring latency), and using an onion routing transport protocol can mitigate that latter.
-
-- They use servers from a trusted commercial provider. The more clients the provider has, the less metadata about the communication times is leaked to the network observers.
-
-- Users trust their contacts and the servers they chose.
-
-By default, servers do not retain access logs, and permanently delete messages and queues when requested.  Messages persist only in memory until they cross a threshold of time, typically on the order of days.[0] There is still a risk that a server maliciously records all queues and messages (even though encrypted) sent via the same transport connection to gain a partial knowledge of the user‚Äôs communications graph and other meta-data.
-
-SimpleX supports measures (managed transparently to the user at the agent level) to mitigate the trust placed in servers.  These include rotating the queues in use between users, noise traffic, and supporting overlay networks such as Tor.
-
-[0] While configurable by servers, a minimum value is enforced by the default software. SimpleX Agents provide redundant routing over queues to mitigate against message loss.
-
-
-#### Client -> Server Communication
-
-Utilizing TLS grants the SimpleX Messaging Protocol (SMP) server authentication and metadata protection to a passive network observer. But SMP does not rely on the transport protocol for message confidentiality or client authentication. The SMP protocol itself provides end-to-end confidentiality, authentication, and integrity of messages between communicating parties.
-
-Servers have long-lived, self-signed, offline certificates whose hash is pre-shared with clients over secure channels - either provided with the client library or provided in the secure introduction between clients.  The offline certificate signs an online certificate used in the transport protocol handshake. [0]
-
-If the transport protocol's confidentiality is broken, incoming and outgoing messages to the server cannot be correlated by message contents. Additionally, because of encryption at the SMP layer, impersonating the server is not sufficient to pass (and therefore correlate) a message from a sender to recipient - the only attack possible is to drop the messages. Only by additionally *compromising* the server can one pass and correlate messages.
-
-It's important to note that the SMP protocol does not do server authentication. Instead we rely upon the fact that an attacker who tricks the transport protocol into authenticating the server incorrectly cannot do anything with the SMP messages except drop them.
-
-After the connection is established, the client sends blocks of a fixed size 16Kb, and the server replies with the blocks of the same size to reduce metadata observable to a network adversary. The protocol has been designed to make traffic correlation attacks difficult, adapting ideas from Tor, remailers, and more general onion and mix networks. It does not try to replace Tor though - SimpleX servers can be deployed as onion services and SimpleX clients can communicate with servers over Tor to further improve participants privacy.
-
-By using fixed-size blocks, oversized for the expected content, the vast majority of traffic is uniform in nature. When enough traffic is transiting a server simultaneously, the server acts as a (very) low-latency mix node.  We can't rely on this behavior to make a security claim, but we have engineered to take advantage of it when we can. As mentioned, this holds true even if the transport connection is compromised.
-
-The protocol does not protect against attacks targeted at particular users with known identities - e.g., if the attacker wants to prove that two known users are communicating, they can achieve it. At the same time, it substantially complicates large-scale traffic correlation, making determining the real user identities much less effective.
-
-[0] Future versions of SMP may add support for revocation lists of certificates, presently this risk is mitigated by the SMP protocol itself.
-
-
-#### SimpleX Messaging Protocol
-
-SMP is initialized with an in-person or out-of-band introduction message, where Alice provides Bob with details of a server (including IP, port, and hash of the long-lived offline certificate), a queue ID, and Alice's public key for her receiving queue. These introductions are similar to the PANDA key-exchange, in that if observed, the adversary can race to establish the communication channel instead of the intended participant. [0]
-
-Because queues are uni-directional, Bob provides an identically-formatted introduction message to Alice over Alice's now-established receiving queue.
-
-When setting up a queue, the server will create separate sender and recipient queue IDs (provided to Alice during set-up and Bob during initial connection). Additionally, during set-up Alice will perform a DH exchange with the server to agree upon a shared secret. This secret will be used to re-encrypt Bob's incoming message before Alice receives it, creating the anti-correlation property earlier-described should the transport encryption be compromised.
-
-[0] Users can additionally create public 'contact queues' that are only used to receive connection requests.  
-
-#### SimpleX Agents
-
-SimpleX agents provide higher-level operations compared to SimpleX Clients, who are primarily concerned with creating queues and communicating with servers using SMP.  Agent operations include:
-
-- Managing sets of bi-directional, redundant queues for communication partners
-
-- Providing end-to-end encryption of messages
-
-- Rotating queues periodically with communication partners
-
-- Noise traffic
-
-#### Encryption Primitives Used
-
-- Ed448 to sign/verify commands to SMP servers (Ed25519 is also supported via client/server configuration).
-- Curve25519 for DH exchange to agree:
-  - the shared secret between server and recipient (to encrypt message bodies - it avoids shared cipher-text in sender and recipient traffic)
-  - the shared secret between sender and recipient (to encrypt messages end-to-end in each queue - it avoids shared cipher-text in redundant queues).
-- [NaCl crypto_box](https://nacl.cr.yp.to/box.html) encryption scheme (curve25519xsalsa20poly1305) for message body encryption between server and recipient and for E2E per-queue encryption.
-- SHA256 to validate server offline certificates.
-- [double ratchet](https://signal.org/docs/specifications/doubleratchet/) protocol for end-to-end message encryption between the agents:
-  - Curve448 keys to agree shared secrets required for double ratchet initialization (using [X3DH](https://signal.org/docs/specifications/x3dh/) key agreement with 2 ephemeral keys for each side),
-  - AES-GCM AEAD cipher,
-  - SHA512-based HKDF for key derivation.
-
-## Threat Model
-
-#### Global Assumptions
-
- - A user protects their local database and key material
- - The user's application is authentic, and no local malware is running
- - The cryptographic primitives in use are not broken
- - A user's choice of servers is not directly tied to their identity or otherwise represents distinguishing information about the user.
-
-#### A passive adversary able to monitor the traffic of one user
-
-*can:*
-
- - identify that and when a user is using SimpleX
-
- - block SimpleX traffic
-
- - determine which servers the user communicates with
-
- - observe how much traffic is being sent, and make guesses as to its purpose.
-
-*cannot:*
-
- - see who sends messages to the user and who the user sends the messages to
-
-#### A passive adversary able to monitor a set of senders and recipients
-
- *can:*
-
- - identify who and when is using SimpleX
-
- - learn which SimpleX Messaging Protocol servers are used as receive queues for which users
-
- - learn when messages are sent and received
-
- - perform traffic correlation attacks against senders and recipients and correlate senders and recipients within the monitored set, frustrated by the number of users on the servers
-
- - observe how much traffic is being sent, and make guesses as to its purpose
-
-*cannot, even in case of a compromised transport protocol:*
-
- - perform traffic correlation attacks with any increase in efficiency over a non-compromised transport protocol
-
-#### SimpleX Messaging Protocol server
-
-*can:*
-
-- learn when a queue recipient or sender is online
-
-- know how many messages are sent via the queue (although some may be noise)
-
-- perform queue correlation (matching multiple queues to a single user) via either a re-used transport connection, user's IP Address, or connection timing regularities
-
-- learn a user's IP address, track them through other IP addresses they use to access the same queue, and infer information (e.g. employer) based on the IP addresses, as long as Tor is not used.
-
-- drop all future messages inserted into a queue, detectable only over other, redundant queues
-
-- lie about the state of a queue to the recipient and/or to the sender  (e.g. suspended or deleted when it is not).
-
-- spam a user with invalid messages
-
-*cannot:*
-
-- undetectably add, duplicate, or corrupt individual messages
-
-- undetectably drop individual messages, so long as a subsequent message is delivered
-
-- learn the contents of messages
-
-- distinguish noise messages from regular messages except via timing regularities
-
-- compromise the user's end-to-end encryption with an active attack
-
-#### An attacker who obtained Alice's (decrypted) chat database
-
-*can:*
-
-- see the history of all messages exchanged by Alice with her communication partners
-
-- see shared profiles of contacts and groups
-
-- surreptitiously receive new messages sent to Alice via existing queues; until communication queues are rotated or the Double-Ratchet advances forward
-
-- prevent Alice from receiving all new messages sent to her - either surreptitiously by emptying the queues regularly or overtly by deleting them
-
-- send messages from the user to their contacts; recipients will detect it as soon as the user sends the next message, because the previous message hash won‚Äôt match (and potentially won‚Äôt be able to decrypt them in case they don‚Äôt keep the previous ratchet keys).
-
-*cannot:*
-
-- impersonate a sender and send messages to the user whose database was stolen. Doing so requires also compromising the server (to place the message in the queue, that is possible until the Double-Ratchet advances forward) or the user's device at a subsequent time (to place the message in the database).
-
-- undetectably communicate at the same time as Alice with her contacts. Doing so would result in the contact getting different messages with repeated IDs.
-
-- undetectably monitor message queues in realtime without alerting the user they are doing so, as a second subscription request unsubscribes the first and notifies the second.
-
-#### A user‚Äôs contact
-
-*can:*
-
-- spam the user with messages
-
-- forever retain messages from the user
-
-*cannot:*
-
-- cryptographically prove to a third-party that a message came from a user (assuming the user‚Äôs device is not seized)
-
-- prove that two contacts they have is the same user
-
-- cannot collaborate with another of the user's contacts to confirm they are communicating with the same user
-
-#### An attacker who observes Alice showing an introduction message to Bob
-
-*can:*
-
- - Impersonate Bob to Alice
-
-*cannot:*
-
- - Impersonate Alice to Bob
-
-#### An attacker with Internet access
-
-*can:*
-
-- Denial of Service SimpleX messaging servers
-
-- spam a user's public ‚Äúcontact queue‚Äù with connection requests
-
-*cannot:*
-
-- send messages to a user who they are not connected with
-
-- enumerate queues on a SimpleX server
-
-
-## Acknowledgements
-
-Efim Poberezkin contributed to the design and implementation of [SimpleX Messaging Protocol](https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md) and [SimpleX Agent Protocol](https://github.com/simplex-chat/simplexmq/blob/master/protocol/agent-protocol.md) since 2019.
-
-Adam Langley's [Pond](https://github.com/agl/pond) inspired some of the recent improvements and the structure of this document.
diff --git a/source/protocol/simplex-messaging.md b/source/protocol/simplex-messaging.md
deleted file mode 100644
index 1c53fe5..0000000
--- a/source/protocol/simplex-messaging.md
+++ /dev/null
@@ -1,908 +0,0 @@
-# Simplex Messaging Protocol (SMP)
-
-## Table of contents
-
-- [Abstract](#abstract)
-- [Introduction](#introduction)
-- [SMP Model](#smp-model)
-- [Out-of-band messages](#out-of-band-messages)
-- [Simplex queue](#simplex-queue)
-- [SMP queue URI](#smp-queue-uri)
-- [SMP procedure](#smp-procedure)
-- [SMP qualities and features](#smp-qualities-and-features)
-- [Cryptographic algorithms](#cryptographic-algorithms)
-- [Simplex queue IDs](#simplex-queue-ids)
-- [Server security requirements](#server-security-requirements)
-- [Message delivery notifications](#message-delivery-notifications)
-- [SMP Transmission structure](#smp-transmission-structure)
-- [SMP commands](#smp-commands)
-  - [Correlating responses with commands](#correlating-responses-with-commands)
-  - [Command authentication](#command-authentication)
-  - [Keep-alive command](#keep-alive-command)
-  - [Recipient commands](#recipient-commands)
-    - [Create queue command](#create-queue-command)
-    - [Subscribe to queue](#subscribe-to-queue)
-    - [Secure queue command](#secure-queue-command)
-    - [Enable notifications command](#enable-notifications-command)
-    - [Disable notifications command](#disable-notifications-command)
-    - [Acknowledge message delivery](#acknowledge-message-delivery)
-    - [Suspend queue](#suspend-queue)
-    - [Delete queue](#delete-queue)
-  - [Sender commands](#sender-commands)
-    - [Send message](#send-message)
-  - [Notifier commands](#notifier-commands)
-    - [Subscribe to queue notifications](#subscribe-to-queue-notifications)
-  - [Server messages](#server-messages)
-    - [Queue IDs response](#queue-ids-response)
-    - [Deliver queue message](#deliver-queue-message)
-    - [Notifier queue ID response](#notifier-queue-id-response)
-    - [Deliver message notification](#deliver-message-notification)
-    - [Subscription END notification](#subscription-end-notification)
-    - [Error responses](#error-responses)
-    - [OK response](#ok-response)
-- [Appendices](#appendices)
-  - [Appendix A. Transport connection with the SMP server](#appendix-a)
-
-## Abstract
-
-Simplex Messaging Protocol is a transport agnostic client-server protocol for asynchronous distributed secure unidirectional message transmission via persistent simplex message queues.
-
-It's designed with the focus on communication security and integrity, under the assumption that any part of the message transmission network can be compromised.
-
-It is designed as a low level protocol for other application protocols to solve the problem of secure and private message transmission, making [MITM attack][1] very difficult at any part of the message transmission system.
-
-This document describes SMP protocol versions 3 and 4, the previous versions are discontinued.
-
-## Introduction
-
-The objective of Simplex Messaging Protocol (SMP) is to facilitate the secure and private unidirectional transfer of messages from senders to recipients via persistent simplex queues managed by the message broker (server).
-
-SMP is independent of any particular transmission system and requires only a reliable ordered data stream channel. While this document describes transport over TCP, other transports are also possible.
-
-The protocol describes the set of commands that recipients and senders can exchange with SMP servers to create and to operate unidirectional "queues" (a data abstraction identifying one of many communication channels managed by the server) and to send messages from the sender to the recipient via the SMP server.
-
-More complex communication scenarios can be designed using multiple queues - for example, a duplex communication channel can be made of 2 simplex queues.
-
-The protocol is designed with the focus on privacy and security, to some extent deprioritizing reliability by requiring that SMP servers only store messages until they are acknowledged by the recipients and, in any case, for a limited period of time. For communication scenarios requiring more reliable transmission the users should use several SMP servers to pass each message and implement some additional protocol to ensure that messages are not removed, inserted or changed - this is out of scope of this document.
-
-SMP does not use any form of participants' identities and provides [E2EE][2] without the possibility of [MITM attack][1] relying on two pre-requisites:
-
-- the users can establish a secure encrypted transport connection with the SMP server. [Appendix A](#appendix-a) describes SMP transport protocol of such connection over TCP, but any other transport connection protocol can be used.
-
-- the recipient can pass a single message to the sender via a pre-existing secure and private communication channel (out-of-band message) - the information in this message is used to encrypt messages and to establish connection with SMP server.
-
-## SMP Model
-
-The SMP model has three communication participants: the recipient, the message broker (SMP server) that is chosen and, possibly, controlled by the recipient, and the sender.
-
-SMP server manages multiple "simplex queues" - data records on the server that identify communication channels from the senders to the recipients. The same communicating party that is the sender in one queue, can be the recipient in another - without exposing this fact to the server.
-
-The queue record consists of 2 unique random IDs generated by the server, one for the recipient and another for the sender, and 2 keys to authenticate the recipient and the sender respectively, provided by the client. The users of SMP protocol must use a unique key for each queue, to avoid the possibility of aggregating and analyzing their queues in case SMP server is compromised.
-
-Creating and using the queue requires sending commands to the SMP server from the recipient and the sender - they are described in detail in [SMP commands](#smp-commands) section.
-
-## Out-of-band messages
-
-The out-of-band message with the queue information is sent via some trusted alternative channel from the recipient to the sender. This message is used to share one or several [queue URIs](#smp-queue-uri) that parties can use to establish the initial connection, the encryption scheme and, it can include the public key(s) for end-to-end encryption.
-
-The approach to out-of-band message passing and their syntax should be defined in application-level protocols.
-
-## Simplex queue
-
-The simplex queue is the main unit of SMP protocol. It is used by:
-
-- Sender of the queue (who received out-of-band message) to send messages to the server using sender's queue ID, signed by sender's key.
-
-- Recipient of the queue (who created the queue and sent out-of-band message) will use it to retrieve messages from the server, signing the commands by the recipient key. Recipient decrypts the messages with the key negotiated during the creation of the queue.
-
-- Participant identities are not shared with the server - new unique keys and queue IDs are used for each queue.
-
-This simplex queue can serve as a building block for more complex communication network. For example, two (or more, for redundancy) simplex queues can be used to create a duplex communication channel. Higher level primitives that are only known to system participants in their client applications can be created as well - e.g., contacts, conversations, groups and broadcasts. Simplex messaging servers only have the information about the low-level simplex queues. In this way a high level of privacy and security of the communication is provided. Application level primitives are not in scope of this protocol.
-
-This approach is based on the concept of [unidirectional networks][4] that are used for applications with high level of information security.
-
-Access to each queue is controlled with unique (not shared with other queues) asymmetric key pairs, separate for the sender and the recipient. The sender and the receiver have private keys, and the server has associated public keys to authenticate participants' commands by verifying cryptographic signatures.
-
-The messages sent over the queue are end-to-end encrypted using the DH secret agreed via out-of-band message and SMP confirmation.
-
-**Simplex queue diagram:**
-
-![Simplex queue](./diagrams/simplex-messaging/simplex.svg)
-
-Queue is defined by recipient ID `RID` and sender ID `SID`, unique for the server. Sender key (`SK`) is used by the server to verify sender's commands (identified by `SID`) to send messages. Recipient key (`RK`) is used by the server to verify recipient's commands (identified by `RID`) to retrieve messages.
-
-The protocol uses different IDs for sender and recipient in order to provide an additional privacy by preventing the correlation of senders and recipients commands sent over the network - in case the encrypted transport is compromised, it would still be difficult to correlate senders and recipients without access to the queue records on the server.
-
-## SMP queue URI
-
-The SMP queue URIs MUST include server identity, queue hostname, an optional port, sender queue ID and the public key that the clients must use to verify responses. Server identity is used to establish secure connection protected from MITM attack with SMP server (see [Appendix A](#appendix-a) for SMP transport protocol).
-
-The [ABNF][8] syntax of the queue URI is:
-
-```abnf
-queueURI = %s"smp://" smpServer "/" queueId "#" recipientDhPublicKey
-smpServer = serverIdentity "@" srvHost [":" port]
-srvHost = <hostname> ; RFC1123, RFC5891
-port = 1*DIGIT
-serverIdentity = base64url
-queueId = base64url
-base64url = <base64url encoded binary> ; RFC4648, section 5
-recipientDhPublicKey = x509UrlEncoded
-; the recipient's Curve25519 key for DH exchange to derive the secret
-; that the sender will use to encrypt delivered messages
-; using [NaCl crypto_box][16] encryption scheme (curve25519xsalsa20poly1305).
-
-x509UrlEncoded = <base64url X509 key encoding>
-```
-
-`hostname` can be IP address or domain name, as defined in RFC 1123, section 2.1.
-
-`port` is optional, the default TCP port for SMP protocol is 5223.
-
-`serverIdentity` is a required hash of the server certificate SPKI block (without line breaks, header and footer) used by the client to validate server certificate during transport handshake (see [Appendix A](#appendix-a))
-
-## SMP procedure
-
-The SMP procedure of creating a simplex queue on SMP server is explained using participants Alice (the recipient) who wants to receive messages from Bob (the sender).
-
-To create and start using a simplex queue Alice and Bob follow these steps:
-
-1. Alice creates a simplex queue on the server:
-
-   1. Decides which SMP server to use (can be the same or different server that Alice uses for other queues) and opens secure encrypted transport connection to the chosen SMP server (see [Appendix A](#appendix-a)).
-
-   2. Generates a new random public/private key pair (encryption key - `EK`) that she did not use before for Bob to encrypt the messages.
-
-   3. Generates another new random public/private key pair (recipient key - `RK`) that she did not use before for her to sign commands and to decrypt the transmissions received from the server.
-
-   4. Generates one more random key pair (recipient DH key - `RDHK`) to negotiate symmetric key that will be used by the server to encrypt message bodies delivered to Alice (to avoid shared cipher-text inside transport connection).
-
-   5. Sends `"NEW"` command to the server to create a simplex queue (see `create` in [Create queue command](#create-queue-command)). This command contains previously generated unique "public" keys `RK` and `RDHK`. `RK` will be used to verify the following commands related to the same queue signed by its private counterpart, for example to subscribe to the messages received to this queue or to update the queue, e.g. by setting the key required to send the messages (initially Alice creates the queue that accepts unsigned messages, so anybody could send the message via this queue if they knew the queue sender's ID and server address).
-
-   6. The server sends `"IDS"` response with queue IDs (`queueIds`):
-
-      - Recipient ID `RID` for Alice to manage the queue and to receive the messages.
-
-      - Sender ID `SID` for Bob to send messages to the queue.
-
-      - Server public DH key (`SDHK`) to negotiate a shared secret for message body encryption, that Alice uses to derive a shared secret with the server `SS`.
-
-2. Alice sends an out-of-band message to Bob via the alternative channel that both Alice and Bob trust (see [protocol abstract](#simplex-messaging-protocol-abstract)). The message must include:
-
-   - Unique "public" key (`EK`) that Bob must use for E2E key agreement.
-
-   - SMP server hostname and information to open secure encrypted transport connection (see [Appendix A](#appendix-a)).
-
-   - Sender queue ID `SID` for Bob to use.
-
-3. Bob, having received the out-of-band message from Alice, connects to the queue:
-
-   1. Generates a new random public/private key pair (sender key - `SK`) that he did not use before for him to sign messages sent to Alice's server.
-
-   2. Prepares the confirmation message for Alice to secure the queue. This message includes:
-
-      - Previously generated "public" key `SK` that will be used by Alice's server to authenticate Bob's messages, once the queue is secured.
-
-      - Optionally, any additional information (application specific, e.g. Bob's profile name and details).
-
-   3. Encrypts the confirmation body with the "public" key `EK` (that Alice provided via the out-of-band message).
-
-   4. Sends the encrypted message to the server with queue ID `SID` (see `send` in [Send message](#send-message)). This initial message to the queue must not be signed - signed messages will be rejected until Alice secures the queue (below).
-
-4. Alice receives Bob's message from the server using recipient queue ID `RID` (possibly, via the same transport connection she already has opened - see `message` in [Deliver queue message](#deliver-queue-message)):
-
-   1. She decrypts received message body using the secret `SS`.
-
-   2. She decrypts received message with [key agreed with sender using] "private" key `EK`.
-
-   3. Even though anybody could have sent the message to the queue with ID `SID` before it is secured (e.g. if communication is compromised), Alice would ignore all messages until the decryption succeeds (i.e. the result contains the expected message format). Optionally, in the client application, she also may identify Bob using the information provided, but it is out of scope of SMP protocol.
-
-5. Alice secures the queue `RID` with `"KEY"` command so only Bob can send messages to it (see [Secure queue command](#secure-queue-command)):
-
-   1. She sends the `KEY` command with `RID` signed with "private" key `RK` to update the queue to only accept requests signed by "private" key `SK` provided by Bob. This command contains unique "public" key `SK` previously generated by Bob.
-
-   2. From this moment the server will accept only signed commands to `SID`, so only Bob will be able to send messages to the queue `SID` (corresponding to `RID` that Alice has).
-
-   3. Once queue is secured, Alice deletes `SID` and `SK` - even if Alice's client is compromised in the future, the attacker would not be able to send messages pretending to be Bob.
-
-6. The simplex queue `RID` is now ready to be used.
-
-This flow is shown on the sequence diagram below.
-
-**Creating simplex queue from Bob to Alice:**
-
-![Creating queue](./diagrams/simplex-messaging/simplex-creating.svg)
-
-Bob now can securely send messages to Alice:
-
-1. Bob sends the message:
-
-   1. He encrypts the message to Alice with "public" key `EK` (provided by Alice, only known to Bob, used only for one simplex queue).
-
-   2. He signs `"SEND"` command to the server queue `SID` using the "private" key `SK` (that only he knows, used only for this queue).
-
-   3. He sends the command to the server (see `send` in [Send message](#send-message)), that the server will authenticate using the "public" key `SK` (that Alice earlier received from Bob and provided to the server via `"KEY"` command).
-
-2. Alice receives the message(s):
-
-   1. She signs `"SUB"` command to the server to subscribe to the queue `RID` with the "private" key `RK` (see `subscribe` in [Subscribe to queue](#subscribe-to-queue)).
-
-   2. The server, having authenticated Alice's command with the "public" key `RK` that she provided, delivers Bob's message(s) (see `message` in [Deliver queue message](#deliver-queue-message)).
-
-   3. She decrypts Bob's message(s) with the "private" key `EK` (that only she has).
-
-   4. She acknowledges the message reception to the server with `"ACK"` so that the server can delete the message and deliver the next messages.
-
-This flow is show on sequence diagram below.
-
-**Sending messages from Bob to Alice via simplex queue:**
-
-![Using queue](./diagrams/simplex-messaging/simplex-using.svg)
-
-**Simplex queue operation:**
-
-![Simplex queue operations](./diagrams/simplex-messaging/simplex-op.svg)
-
-Sequence diagram does not show E2E encryption - server knows nothing about encryption between the sender and the receiver.
-
-A higher level protocol application protocol should define the semantics that allow to use two simplex queues (or two sets of queues for redundancy) for the bi-directional or any other communication scenarios.
-
-The SMP is intentionally unidirectional - it provides no answer to how Bob will know that the transmission succeeded, and whether Alice received any messages. There may be a scenario when Alice wants to securely receive the messages from Bob, but she does not want Bob to have any proof that she received any messages - this low-level protocol can be used in this scenario, as all Bob knows as a fact is that he was able to send one unsigned message to the server that Alice provided, and now he can only send messages signed with the key `SK` that he sent to the server - it does not prove that any message was received by Alice.
-
-For practical purposes of bi-directional conversation, now that Bob can securely send encrypted messages to Alice, Bob can create the second simplex queue that will allow Alice to send messages to Bob in the same way, sending the second queue details via the first queue. If both Alice and Bob have their respective unique "public" keys (Alice's and Bob's `EK`s of two separate queues), or pass additional keys to sign the messages, the conversation can be both encrypted and signed.
-
-The established queues can also be used to change the encryption keys providing [forward secrecy][5], or to negotiate using other SMP queue(s).
-
-This protocol also can be used for off-the-record messaging, as Alice and Bob can use multiple queues between them and only information they pass to each other allows proving their identity, so if they want to share anything off-the-record they can initiate a new queue without linking it to any other information they exchanged. As a result, this protocol provides better anonymity and better protection from [MITM][1] than [OTR][6] protocol.
-
-## SMP qualities and features
-
-Simplex Messaging Protocol:
-
-- Defines only message-passing protocol:
-
-  - Transport agnostic - the protocol does not define how clients connect to the servers. It can be implemented over any ordered data stream channel: TCP connection, HTTP with long polling, websockets, etc.
-
-  - Not semantic - the protocol does not assign any meaning to queues and messages. While on the application level the queues and messages can have different meaning (e.g., for messages: text or image chat message, message acknowledgement, participant profile information, status updates, changing "public" key to encrypt messages, changing servers, etc.), on SMP protocol level all the messages are binary and their meaning can only be interpreted by client applications and not by the servers - this interpretation is out of scope of this protocol.
-
-- Client-server architecture:
-
-  - Multiple servers, that can be deployed by the system users, can be used to send and retrieve messages.
-
-  - Servers do not communicate with each other and do not "know" about other servers.
-
-  - Clients only communicate with servers (excluding the initial out-of-band message), so the message passing is asynchronous.
-
-  - For each queue, the message recipient defines the server through which the sender should send messages.
-
-  - While multiple servers and multiple queues can be used to pass each message, it is in scope of application level protocol(s), and out of scope of this protocol.
-
-  - Servers store messages only until they are retrieved by the recipients, and in any case, for a limited time.
-
-  - Servers are required to NOT store any message history or delivery log, but even if the server is compromised, it does not allow to decrypt the messages or to determine the list of queues established by any participant - this information is only stored on client devices.
-
-- The only element provided by SMP servers is simplex queues:
-
-  - Each queue is created and managed by the queue recipient.
-
-  - Asymmetric encryption is used to sign and verify the requests to send and receive the messages.
-
-  - One unique "public" key is used by the servers to authenticate requests to send the messages into the queue, and another unique "public" key - to retrieve the messages from the queue. "Unique" here means that each "public" key is used only for one queue and is not used for any other context - effectively, this key is not public and does not represent any participant identity.
-
-  - Both recipient and sender "public" keys are provided to the server by the queue recipient. "Public" key `RK` is provided when the queue is created, public key `SK` is provided when the queue is secured.
-
-  - The "public" keys known to the server and used to authenticate commands from the participants are unrelated to the keys used to encrypt and decrypt the messages - the latter keys are also unique per each queue but they are only known to participants, not to the servers.
-
-  - Messaging graph can be asymmetric: Bob's ability to send messages to Alice does not automatically lead to the Alice's ability to send messages to Bob.
-
-## Cryptographic algorithms
-
-Simplex messaging clients and servers must cryptographically sign commands, responses and messages for the following operations:
-
-- With the recipient's key `RK` (server to verify):
-  - create the queue (`NEW`)
-  - subscribe to queue (`SUB`)
-  - secure the queue (`KEY`)
-  - enable queue notifications (`NKEY`)
-  - acknowledge received messages (`ACK`)
-  - suspend the queue (`OFF`)
-  - delete the queue (`DEL`)
-- With the sender's key `SK` (server to verify):
-  - send messages (`SEND`)
-- With the optional notifier's key:
-  - subscribe to message notifications (`NSUB`)
-- With the server's key (for recipient and sender to verify)
-  - queue IDs response (`IDS`)
-  - notifier queue ID response (`NID`)
-  - delivered messages (`MSG`)
-  - `OK` and `ERR` responses (excluding error responses not related to a queue)
-
-To sign/verify transmissions clients and servers MUST use Ed25519 or Ed448 algorithm defined in [RFC8709][15].
-
-To encrypt/decrypt message bodies delivered to the recipients, servers/clients MUST use x25519 or x448 algorithm defined in [RFC8709][15] to derive the shared secret (TODO encryption scheme).
-
-Clients MUST encrypt message bodies sent via SMP servers - the protocol for this end-to-end encryption should be chosen by the clients using SMP protocol.
-
-The reasons to use these algorithms:
-
-- Faster operation than RSA algorithms.
-- DH key exchange provides forward secrecy.
-
-Future versions of the protocol may allow different cryptographic algorithms.
-
-## Simplex queue IDs
-
-Simplex messaging servers MUST generate 2 different IDs for each new queue - for the recipient (that created the queue) and for the sender. It is REQUIRED that:
-
-- These IDs are different and unique within the server.
-- Based on random bytes generated with cryptographically strong pseudo-random number generator.
-
-## Server security requirements
-
-Simplex messaging server implementations MUST NOT create, store or send to any other servers:
-
-- Logs of the client commands and transport connections in the production environment.
-
-- History of deleted queues, retrieved or acknowledged messages (deleted queues MAY be stored temporarily as part of the queue persistence implementation).
-
-- Snapshots of the database they use to store queues and messages (instead simplex messaging clients must manage redundancy by using more than one simplex messaging server). In-memory persistence is recommended.
-
-- Any other information that may compromise privacy or [forward secrecy][4] of communication between clients using simplex messaging servers.
-
-## Message delivery notifications
-
-Supporting message delivery while the client mobile app is not running requires sending push notifications with the device token. All alternative mechanisms for background message delivery are unreliable, particularly on iOS platform. Obviously, supporting push notification delivery by simply subscribing to messages would reduce meta-data privacy as it allows to see all queues that a given device uses.
-
-To protect the privacy of the recipients, there are several commands in SMP protocol that allow enabling and subscribing to message notifications from SMP queues, using separate set of "notifier keys" and via separate queue IDs - as long as SMP server is not compromised, these notifier queue IDs cannot be correlated with recipient or sender queue IDs.
-
-The clients can optionally instruct a dedicated push notification server to subscribe to notifications and deliver push notifications to the device, which can then retrieve the messages in the background and send local notifications to the user - this is out of scope of SMP protocol. The commands that SMP protocol provides to allow it:
-
-- `enableNotifications` (`"NKEY"`) with `notifierId` (`"NID"`) response - see [Enable notifications command](#enable-notifications-command).
-- `disableNotifications` (`"NDEL"`) - see [Disable notifications command](#disable-notifications-command).
-- `subscribeNotifications` (`"NSUB"`) - see [Subscribe to queue notifications](#subscribe-to-queue-notifications).
-- `messageNotification` (`"NMSG"`) - see [Deliver message notification](#deliver-message-notification).
-
-[`SEND` command](#send-message) includes the notification flag to instruct SMP server whether to send the notification - this flag is forwarded to the recepient inside encrypted envelope, together with the timestamp and the message body, so even if TLS is compromised this flag cannot be used for traffic correlation.
-
-## SMP Transmission andtransport block structure
-
-Each transport block (SMP transmission) has a fixed size of 16384 bytes for traffic uniformity.
-
-From SMP version 4 each block can contain multiple transmissions, version 3 blocks have 1 transmission.
-Some parts of SMP transmission are padded to a fixed size; this padding is uniformly added as a word16 encoded in network byte order - see `paddedString` syntax.
-
-In places where some part of the transmission should be padded, the syntax for `paddedNotation` is used:
-
-```abnf
-paddedString = originalLength string pad
-originalLength = 2*2 OCTET
-pad = N*N"#" ; where N = paddedLength - originalLength - 2
-
-paddedNotation = <padded(string, paddedLength)>
-; string - un-padded string
-; paddedLength - required length after padding, including 2 bytes for originalLength
-```
-
-Each transmission/block for SMP v3 between the client and the server must have this format/syntax:
-
-```abnf
-paddedTransmission = <padded(transmission), 16384>
-transmission = [signature] SP signed
-signed = sessionIdentifier SP [corrId] SP [queueId] SP smpCommand
-; corrId is required in client commands and server responses,
-; it is empty in server notifications.
-corrId = 1*32(%x21-7F) ; any characters other than control/whitespace
-queueId = encoded ; max 32 bytes when decoded (24 bytes is used),
-; empty queue ID is used with "create" command and in some server responses
-signature = encoded
-; empty signature can be used with "send" before the queue is secured with secure command
-; signature is always empty with "ping" and "serverMsg"
-encoded = <base64 encoded binary>
-```
-
-`base64` encoding should be used with padding, as defined in section 4 of [RFC 4648][9]
-
-Transport block for SMP v4 has this syntax:
-
-```abnf
-paddedTransportBlock = <padded(transportBlock), 16384>
-transportBlock = transmissionCount transmissions
-transmissionCount = 1*1 OCTET ; equal or greater than 1
-transmissions = transmissionLength transmission [transmissions]
-transmissionLength = 2*2 OCTET ; word16 encoded in network byte order
-```
-
-## SMP commands
-
-Commands syntax below is provided using [ABNF][8] with [case-sensitive strings extension][8a].
-
-```abnf
-smpCommand = ping / recipientCmd / send / subscribeNotifications / serverMsg
-recipientCmd = create / subscribe / secure / enableNotifications / disableNotifications /
-               acknowledge / suspend / delete
-serverMsg = queueIds / message / notifierId / messageNotification /
-            unsubscribed / ok / error
-```
-
-The syntax of specific commands and responses is defined below.
-
-### Correlating responses with commands
-
-The server should send `queueIds`, `error` and `ok` responses in the same order within each queue ID as the commands received in the transport connection, so that they can be correlated by the clients. To simplify correlation of commands and responses, the server must use the same `corrId` in the response as in the command sent by the client.
-
-If the transport connection is closed before some responses are sent, these responses should be discarded.
-
-### Command authentication
-
-SMP servers must authenticate all transmissions (excluding `ping` and initial `send` commands) by verifying the client signatures. Command signature should be generated by applying the algorithm specified for the queue to the `signed` block of the transmission, using the key associated with the queue ID (recipient's, sender's or notifier's, depending on which queue ID is used).
-
-### Keep-alive command
-
-To keep the transport connection alive and to generate noise traffic the clients should use `ping` command to which the server responds with `ok` response. This command should be sent unsigned and without queue ID.
-
-```abnf
-ping = %s"PING"
-```
-
-This command is always send unsigned.
-
-### Recipient commands
-
-Sending any of the commands in this section (other than `create`, that is sent without queue ID) is only allowed with recipient's ID (`RID`). If sender's ID is used the server must respond with `"ERR AUTH"` response (see [Error responses](#error-responses)).
-
-#### Create queue command
-
-This command is sent by the recipient to the SMP server to create a new queue. The syntax is:
-
-```abnf
-create = %s"NEW " recipientSignaturePublicKey recipientDhPublicKey
-recipientSignaturePublicKey = length x509encoded
-; the recipient's Ed25519 or Ed448 public key to verify commands for this queue
-
-recipientDhPublicKey = length x509encoded
-; the recipient's Curve25519 key for DH exchange to derive the secret
-; that the server will use to encrypt delivered message bodies
-; using [NaCl crypto_box][16] encryption scheme (curve25519xsalsa20poly1305).
-
-x509encoded = <binary X509 key encoding>
-
-length = 1*1 OCTET
-```
-
-If the queue is created successfully, the server must send `queueIds` response with the recipient's and sender's queue IDs and public keys to sign all responses and messages and to encrypt delivered message bodies:
-
-```abnf
-queueIds = %s"IDS " recipientId senderId srvDhPublicKey
-serverDhPublicKey = length x509encoded
-; the server's Curve25519 key for DH exchange to derive the secret
-; that the server will use to encrypt delivered message bodies to the recipient
-recipientId = length *OCTET ; 16-24 bytes
-senderId = length *OCTET ; 16-24 bytes
-```
-
-Once the queue is created, the recipient gets automatically subscribed to receive the messages from that queue, until the transport connection is closed. The `subscribe` command is needed only to start receiving the messages from the existing queue when the new transport connection is opened.
-
-`NEW` transmission MUST be signed using the private part of the `recipientSignaturePublicKey` ‚Äì this verifies that the client has the private key that will be used to sign subsequent commands for this queue.
-
-`IDS` response transmission MUST be sent with empty queue ID (the third part of the transmission).
-
-#### Subscribe to queue
-
-When the simplex queue was not created in the current transport connection, the recipient must use this command to start receiving messages from it:
-
-```abnf
-subscribe = %s"SUB"
-```
-
-If subscription is successful the server must respond with the first available message or with `ok` response if no messages are available. The recipient will continue receiving the messages from this queue until the transport connection is closed or until another transport connection subscribes to the same simplex queue - in this case the first subscription should be cancelled and [subscription END notification](#subscription-end-notification) delivered.
-
-The first message will be delivered either immediately or as soon as it is available; to receive the following message the recipient must acknowledge the reception of the message (see [Acknowledge message delivery](#acknowledge-message-delivery)).
-
-This transmission and its response MUST be signed.
-
-#### Secure queue command
-
-This command is sent by the recipient to the server to add sender's key to the queue:
-
-```abnf
-secure = %s"KEY " senderSignaturePublicKey
-senderSignaturePublicKey = length x509encoded
-; the sender's Ed25519 or Ed448 key to verify SEND commands for this queue
-```
-
-`senderKey` is received from the sender as part of the first message - see [Send Message](#send-message) command.
-
-Once the queue is secured only signed messages can be sent to it.
-
-#### Enable notifications command
-
-This command is sent by the recipient to the server to add notifier's key to the queue, to allow push notifications server to receive notifications when the message arrives, via a separate queue ID, without receiving message content.
-
-```abnf
-enableNotifications = %s"NKEY " notifierKey recipientNotificationDhPublicKey
-notifierKey = length x509encoded
-; the notifier's Ed25519 or Ed448 public key public key to verify NSUB command for this queue
-
-recipientNotificationDhPublicKey = length x509encoded
-; the recipient's Curve25519 key for DH exchange to derive the secret
-; that the server will use to encrypt notification metadata (encryptedNMsgMeta in NMSG)
-; using [NaCl crypto_box][16] encryption scheme (curve25519xsalsa20poly1305).
-```
-
-The server will respond with `notifierId` response if notifications were enabled and the notifier's key was successfully added to the queue:
-
-```abnf
-notifierId = %s"NID " notifierId srvNotificationDhPublicKey
-notifierId = length *OCTET ; 16-24 bytes
-srvNotificationDhPublicKey = length x509encoded
-; the server's Curve25519 key for DH exchange to derive the secret
-; that the server will use to encrypt notification metadata to the recipient (encryptedNMsgMeta in NMSG)
-```
-
-This response is sent with the recipient's queue ID (the third part of the transmission).
-
-To receive the message notifications, `subscribeNotifications` command ("NSUB") must be sent signed with the notifier's key.
-
-#### Disable notifications command
-
-This command is sent by the recipient to the server to remove notifier's credentials from the queue:
-
-```abnf
-disableNotifications = %s"NDEL"
-```
-
-The server must respond `ok` to this command if it was successful.
-
-Once notifier's credentials are removed server will no longer send "NMSG" for this queue to notifier.
-
-#### Acknowledge message delivery
-
-The recipient should send the acknowledgement of message delivery once the message was stored in the client, to notify the server that the message should be deleted:
-
-```abnf
-acknowledge = %s"ACK"
-```
-
-Even if acknowledgement is not sent by the recipient, the server should limit the time of message storage, whether it was delivered to the recipient or not.
-
-Having received the acknowledgement, SMP server should immediately delete the message and then send the next available message or respond with `ok` if there are no more messages available in this simplex queue.
-
-#### Suspend queue
-
-The recipient can suspend a queue prior to deleting it to make sure that no messages are lost:
-
-```abnf
-suspend = %s"OFF"
-```
-
-The server must respond with `"ERR AUTH"` to any messages sent after the queue was suspended (see [Error responses](#error-responses)).
-
-The server must respond `ok` to this command if it was successful.
-
-This command can be sent multiple times (in case transport connection was interrupted and the response was not delivered), the server should still respond `ok` even if the queue is already suspended.
-
-There is no command to resume the queue. Servers must delete suspended queues that were not deleted after some period of time.
-
-#### Delete queue
-
-The recipient can delete the queue, whether it was suspended or not.
-
-All undelivered messages must be deleted as soon as this command is received, before the response is sent.
-
-```abnf
-delete = %s"DEL"
-```
-
-### Sender commands
-
-Currently SMP defines only one command that can be used by senders - `send` message. This command must be used with sender's ID, if recipient's ID is used the server must respond with `"ERR AUTH"` response (see [Error responses](#error-responses)).
-
-#### Send message
-
-This command is sent to the server by the sender both to confirm the queue after the sender received out-of-band message from the recipient and to send messages after the queue is secured:
-
-```abnf
-send = %s"SEND " msgFlags SP smpEncMessage
-msgFlags = notificationFlag reserved
-notificationFlag = %s"T" / %s"F"
-smpEncMessage = smpPubHeader sentMsgBody ; message up to 16088 bytes
-smpPubHeader = smpClientVersion ("1" senderPublicDhKey / "0")
-smpClientVersion = word16
-senderPublicDhKey = length x509encoded
-; sender's Curve25519 public key to agree DH secret for E2E encryption in this queue
-; it is only sent in confirmation message
-x509encoded = <binary X509 key encoding>
-sentMsgBody = 16032*16032 OCTET
-; E2E-encrypted smpClientMessage padded to 16032 bytes before encryption
-word16 = 2*2 OCTET
-```
-
-The first message is sent to confirm the queue - it should contain sender's server key (see decrypted message syntax below) - this first message must be sent without signature.
-
-Once the queue is secured (see [Secure queue command](#secure-queue-command)), the following send commands must be sent with the signature.
-
-The server must respond with `"ERR AUTH"` response in the following cases:
-
-- the queue does not exist or is suspended
-- the queue is secured but the transmission does NOT have a signature
-- the queue is NOT secured but the transmission has a signature
-
-Until the queue is secured, the server should accept any number of unsigned messages - it both enables the legitimate sender to resend the confirmation in case of failure and also allows the simplex messaging client to ignore any confirmation messages that may be sent by the attackers (assuming they could have intercepted the queue ID in the server response, but do not have a correct encryption key passed to sender in out-of-band message).
-
-The body should be encrypted with the recipient's "public" key (`EK`); once decrypted it must have this format:
-
-```abnf
-sentMsgBody = <encrypted padded(smpClientMessage, 16032)>
-smpClientMessage = smpPrivHeader clientMsgBody
-smpPrivHeader = emptyHeader / smpConfirmationHeader
-emptyHeader = " "
-smpConfirmationHeader = %s"K" senderKey
-senderKey = length x509encoded
-; the sender's Ed25519 or Ed448 public key to sign SEND commands for this queue
-clientMsgBody = *OCTET ; up to 16016 in case of emptyHeader
-```
-
-`clientHeader` in the initial unsigned message is used to transmit sender's server key and can be used in the future revisions of SMP protocol for other purposes.
-
-SMP transmission structure for sent messages:
-
-```
-------- transmission (= 16384 bytes)
-    2 | originalLength
- 276- | signature sessionId corrId queueId %s"SEND" SP (1+114 + 1+32? + 1+32 + 1+24 + 4+1 = 210)
-      ....... smpEncMessage (= 16088 bytes = 16384 - 296 bytes)
-         8- | smpPubHeader (for messages it is only version and '0' to mean "no DH key" = 3 bytes)
-         24 | nonce for smpClientMessage
-         16 | auth tag for smpClientMessage
-            ------- smpClientMessage (E2E encrypted, = 16032 bytes = 16088 - 48)
-                2 | originalLength
-               12- | smpPrivHeader
-                  .......
-                        | clientMsgBody (<= 16016 bytes = 16032 - 14)
-                  .......
-               0+ | smpClientMessage pad
-            ------- smpClientMessage end
-            |
-      ....... smpEncMessage end
-  18+ | transmission pad
-------- transmission end
-```
-
-SMP transmission structure for received messages:
-
-```
-------- transmission (= 16384 bytes)
-    2 | originalLength
- 276- | signature sessionId corrId queueId %s"MSG" SP msgId timestamp (1+114 + 1+32? + 1+32 + 1+24 + 3+1 + 24+1 + 8 = 243)
-   16 | auth tag (msgId is used as nonce)
-      ------- serverEncryptedMsg (= 16090 bytes = 16384 - 294 bytes)
-          2 | originalLength
-            ....... smpEncMessage (= 16088 bytes = 16090 - 2 bytes)
-               16- | smpPubHeader (empty header for the message)
-               24 | nonce for smpClientMessage
-               16 | auth tag for smpClientMessage
-                  ------- smpClientMessage (E2E encrypted, = 16032 bytes = 16088 - 56 bytes)
-                      2 | originalLength
-                     16- | smpPrivHeader (empty header for the message)
-                        ....... clientMsgBody (<= 16016 bytes = 16032 - 16)
-                              -- TODO move internal structure (below) to agent protocol
-                          20- | agentPublicHeader (the size is for user messages post handshake, without E2E X3DH keys - it is version and 'M' for the messages - 3 bytes in total)
-                              ....... E2E double-ratchet encrypted (<= 15996 bytes = 16016 - 20)
-                                  1 | encoded double ratchet header length (it is 123 now)
-                                123 | encoded double ratchet header, including:
-                                         2 | version
-                                        16 | double-ratchet header iv
-                                        16 | double-ratchet header auth tag
-                                      1+88 | double-ratchet header (actual size is 69 bytes, the rest is reserved)
-                                 16 | message auth tag (IV generated from chain ratchet)
-                                    ------- encrypted agent message (= 15856 bytes = 15996 - 140)
-                                        2 | originalLength
-                                      64- | agentHeader (the actual size is 41 = 8 + 1+32)
-                                        2 | %s"MM"
-                                          .......
-                                                | application message (<= 15788 bytes = 15856 - 68)
-                                          .......
-                                       0+ | encrypted agent message pad
-                                    ------- encrypted agent message end
-                                    |
-                              ....... E2E double-ratchet encrypted end
-                              |
-                              -- TODO move internal structure (above) to agent protocol
-                        ....... clientMsgBody end
-                     0+ | smpClientMessage pad
-                  ------- smpClientMessage end
-                  |
-            ....... smpEncMessage end
-         0+ | serverEncryptedMsg pad
-      ------- serverEncryptedMsg end
-   0+ | transmission pad
-------- transmission end
-```
-
-### Notifier commands
-
-#### Subscribe to queue notifications
-
-The push notifications server (notifier) must use this command to start receiving message notifications from the queue:
-
-```abnf
-subscribeNotifications = %s"NSUB"
-```
-
-If subscription is successful the server must respond with `ok` response if no messages are available. The notifier will be receiving the message notifications from this queue until the transport connection is closed or until another transport connection subscribes to notifications from the same simplex queue - in this case the first subscription should be cancelled and [subscription END notification](#subscription-end-notification) delivered.
-
-The first message notification will be delivered either immediately or as soon as the message is available.
-
-### Server messages
-
-#### Queue IDs response
-
-Server must respond with this message when the new queue is created.
-
-See its syntax in [Create queue command](#create-queue-command)
-
-#### Deliver queue message
-
-The server must deliver messages to all subscribed simplex queues on the currently open transport connection. The syntax for the message delivery is:
-
-```abnf
-message = %s"MSG " msgId encryptedRcvMsgBody
-encryptedMsgBody = <encrypt paddedSentMsgBody> ; server-encrypted padded sent msgBody
-paddedSentMsgBody = <padded(sentMsgBody, maxMessageLength + 2)> ; maxMessageLength = 16088
-encryptedRcvMsgBody = <encrypt rcvMsgBody> ; server-encrypted meta-data and padded sent msgBody
-rcvMsgBody = timestamp msgFlags SP paddedSentMsgBody
-msgId = length 24*24OCTET
-timestamp = 8*8OCTET
-```
-
-`msgId` - unique message ID generated by the server based on cryptographically strong random bytes. It should be used by the clients to detect messages that were delivered more than once (in case the transport connection was interrupted and the server did not receive the message delivery acknowledgement). Message ID is used as a nonce for server/recipient encryption of message bodies.
-
-`timestamp` - system time when the server received the message from the sender as **a number of seconds** since Unix epoch (1970-01-01) encoded as 64-bit integer in network byte order. If a client system/language does not support 64-bit integers, until 2106 it is safe to simply skip the first 4 zero bytes and decode 32-bit unsigned integer (or as signed integer until 2038).
-
-`paddedSentMsgBody` - see syntax in [Send message](#send-message)
-
-When server delivers the messages to the recipient, message body should be encrypted with the secret derived from DH exchange using the keys passed during the queue creation and returned with `queueIds` response.
-
-This is done to prevent the possibility of correlation of incoming and outgoing traffic of SMP server inside transport protocol.
-
-#### Notifier queue ID response
-
-Server must respond with this message when queue notifications are enabled.
-
-See its syntax in [Enable notifications command](#enable-notifications-command)
-
-#### Deliver message notification
-
-The server must deliver message notifications to all simplex queues that were subscribed with `subscribeNotifications` command ("NSUB") on the currently open transport connection. The syntax for the message notification delivery is:
-
-```abnf
-messageNotification = %s"NMSG " nmsgNonce encryptedNMsgMeta
-
-encryptedNMsgMeta = <encrypted message metadata passed in notification>
-; metadata E2E encrypted between server and recipient containing server's message ID and timestamp (allows extension),
-; to be passed to the recipient by the notifier for them to decrypt
-; with key negotiated in NKEY and NID commands using nmsgNonce
-
-nmsgNonce = <nonce used in NaCl crypto_box encryption scheme>
-; nonce used by the server for encryption of message metadata, to be passed to the recipient by the notifier
-; for them to use in decryption of E2E encrypted metadata
-```
-
-Message notification does not contain any message data or non E2E encrypted metadata.
-
-#### Subscription END notification
-
-When another transport connection is subscribed to the same simplex queue, the server should unsubscribe and to send the notification to the previously subscribed transport connection:
-
-```abnf
-unsubscribed = %s"END"
-```
-
-No further messages should be delivered to unsubscribed transport connection.
-
-#### Error responses
-
-- incorrect block format, encoding or signature size (`BLOCK`).
-- missing or different session ID - tls-unique binding of TLS transport (`SESSION`)
-- command errors (`CMD`):
-  - error parsing command (`SYNTAX`)
-  - prohibited command (`PROHIBITED`) - any server response sent from client or `ACK` sent without active subscription or without message delivery.
-  - transmission has no required signature or queue ID (`NO_AUTH`)
-  - transmission has unexpected credentials (`HAS_AUTH`)
-  - transmission has no required queue ID (`NO_QUEUE`)
-- authentication error (`AUTH`) - incorrect signature, unknown (or suspended) queue, sender's ID is used in place of recipient's and vice versa, and some other cases (see [Send message](#send-message) command).
-- message queue quota exceeded error (`QUOTA`) - too many messages were sent to the message queue. Further messages can only be sent after the recipient retrieves the messages.
-- sent message is too large (> 16088) to be delivered (`LARGE_MSG`).
-- internal server error (`INTERNAL`).
-
-The syntax for error responses:
-
-```abnf
-error = %s"ERR " errorType
-errorType = %s"BLOCK" / %s"SESSION" / %s"CMD " cmdError / %s"AUTH" / %s"LARGE_MSG" /%s"INTERNAL"
-cmdError = %s"SYNTAX" / %s"PROHIBITED" / %s"NO_AUTH" / %s"HAS_AUTH" / %s"NO_ENTITY"
-```
-
-Server implementations must aim to respond within the same time for each command in all cases when `"ERR AUTH"` response is required to prevent timing attacks (e.g., the server should perform signature verification even when the queue does not exist on the server or the signature of different size is sent, using any RSA key with the same size as the signature size).
-
-### OK response
-
-When the command is successfully executed by the server, it should respond with OK response:
-
-```abnf
-ok = %s"OK"
-```
-
-## Appendices
-
-### Appendix A.
-
-**SMP transport protocol.**
-
-Both the recipient and the sender can use TCP or some other, possibly higher level, transport protocol to communicate with the server. The default TCP port for SMP server is 5223.
-
-For scenarios when meta-data privacy is critical, it is recommended that clients:
-
-- communicating over Tor network,
-- establish a separate connection for each SMP queue,
-- send noise traffic (using PING command).
-
-In addition to that, the servers can be deployed as Tor onion services.
-
-The transport protocol should provide the following:
-
-- server authentication (by matching server certificate hash with `serverIdentity`),
-- forward secrecy (by encrypting the traffic using ephemeral keys agreed during transport handshake),
-- integrity (preventing data modification by the attacker without detection),
-- unique channel binding (`sessionIdentifier`) to include in the signed part of SMP transmissions.
-
-By default, the client and server communicate using [TLS 1.3 protocol][13] restricted to:
-
-- TLS_CHACHA20_POLY1305_SHA256 cipher suite (for better performance on mobile devices),
-- ed25519 and ed448 EdDSA algorithms for signatures,
-- x25519 and x448 ECDHE groups for key exchange.
-- servers must send the chain of exactly 2 self-signed certificates in the handshake, with the first (offline) certificate one signing the second (online) certificate. Offline certificate fingerprint is used as a server identity - it is a part of SMP server address.
-- The clients must abort the connection in case a different number of certificates is sent.
-- server and client TLS configuration should not allow resuming the sessions.
-
-During TLS handshake the client must validate that the fingerprint of the online server certificate is equal to the `serverIdentity` the client received as part of SMP server address; if the server identity does not match the client must abort the connection.
-
-Once TLS handshake is complete, client and server will exchange blocks of fixed size (16384 bytes).
-
-The first block sent by the server should be `serverHello` and the client should respond with `clientHello` - these blocks are used to agree SMP protocol version:
-
-```abnf
-serverHello = minSmpVersion maxSmpVersion sessionIdentifier pad
-minSmpVersion = smpVersion
-maxSmpVersion = smpVersion
-sessionIdentifier = length *OCTET
-; unique session identifier derived from transport connection handshake
-; it should be included in all SMP transmissions sent in this transport connection.
-
-clientHello = smpVersion pad
-; chosen SMP protocol version - it must be the maximum supported version
-; within the range offered by the server
-
-smpVersion = 2*2OCTET ; Word16 version number
-
-pad = *OCTET
-```
-
-For TLS transport client should assert that `sessionIdentifier` is equal to `tls-unique` channel binding defined in [RFC 5929][14] (TLS Finished message struct); we pass it in `serverHello` block to allow communication over some other transport protocol (possibly, with another channel binding).
-
-[1]: https://en.wikipedia.org/wiki/Man-in-the-middle_attack
-[2]: https://en.wikipedia.org/wiki/End-to-end_encryption
-[3]: https://en.wikipedia.org/wiki/QR_code
-[4]: https://en.wikipedia.org/wiki/Unidirectional_network
-[5]: https://en.wikipedia.org/wiki/Forward_secrecy
-[6]: https://en.wikipedia.org/wiki/Off-the-Record_Messaging
-[8]: https://tools.ietf.org/html/rfc5234
-[8a]: https://tools.ietf.org/html/rfc7405
-[9]: https://tools.ietf.org/html/rfc4648#section-4
-[10]: https://tools.ietf.org/html/rfc3339
-[11]: https://tools.ietf.org/html/rfc5280
-[12]: https://tools.ietf.org/html/rfc7714
-[13]: https://datatracker.ietf.org/doc/html/rfc8446
-[14]: https://datatracker.ietf.org/doc/html/rfc5929#section-3
-[15]: https://www.rfc-editor.org/rfc/rfc8709.html
-[16]: https://nacl.cr.yp.to/box.html
diff --git a/source/protocol/simplex-uri-request.txt b/source/protocol/simplex-uri-request.txt
deleted file mode 100644
index 510377c..0000000
--- a/source/protocol/simplex-uri-request.txt
+++ /dev/null
@@ -1,18 +0,0 @@
-Scheme name: simplex
-
-Status: Provisional
-
-Applications/protocols that use this scheme name:
-This scheme is used for connection requests in SimpleX Agent Protocol,
-a middle layer protocol for managing bi-directional communication via
-redundant unidirectional SimpleX Messaging Protocol queues.
-
-Contact: Evgeny Poberezkin <ep@simplex.chat>
-
-Change controller: Evgeny Poberezkin <ep@simplex.chat>
-
-References:
-The syntax for connection requests in the latest version of SimpleX Agent Protocol:
-https://github.com/simplex-chat/simplexmq/blob/master/protocol/agent-protocol.md#connection-request
-SimpleX Messaging Protocol:
-https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md
diff --git a/source/protocol/smp-uri-request.txt b/source/protocol/smp-uri-request.txt
deleted file mode 100644
index d924ad9..0000000
--- a/source/protocol/smp-uri-request.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-Scheme name: smp
-
-Status: Provisional
-
-Applications/protocols that use this scheme name:
-This scheme is used for URIs of message queues in SimpleX Messaging Protocol,
-a client-server protocol for asynchronous distributed unidirectional
-message transmission via persistent message queues.
-
-Contact: Evgeny Poberezkin <ep@simplex.chat>
-
-Change controller: Evgeny Poberezkin <ep@simplex.chat>
-
-References:
-The syntax for message queue URIs in the latest version of SimpleX Messaging Protocol:
-https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md#smp-queue-uri
diff --git a/source/rfcs/2021-02-28-streams.md b/source/rfcs/2021-02-28-streams.md
deleted file mode 100644
index 1bb13f6..0000000
--- a/source/rfcs/2021-02-28-streams.md
+++ /dev/null
@@ -1,48 +0,0 @@
-# Streams
-
-Managing dedicated SMP queues for fast synchronous communication
-
-## Problem
-
-SMP agent protocol implementation provides the most secure way to distribute keys achieving the following qualities:
-
-- compromising the sender agent/device allows to send messages, but not to read them.
-- compromising the recipient agent/device allows to receive messages, but not to send them (neither public encryption key is stored - TBC if public key can be restored from the private - nor server authentication key is available).
-- compromising the server does not expose any information about messages content, as encrypted section has the same size.
-
-The current hybrid encryption scheme uses a new symmetric key for each message, and because the symmetric key is not persisted at any point, it is difficult to obtain it and send counterfeit messages on behalf of the sender (even in case both the server and recipient are compromised).
-
-There are 2 downsides of the current scheme:
-
-1. RSA encryption/decryption is relatively slow even for 2048 key size and gets much slower for larger key sizes. It is not a problem for the chat messages (and any content updates) that happen infrequently, but it makes the transmission of large files and any other streaming communication slow.
-
-2. If the large file or voice/video calls were to be sent via the same queue as normal messages/content updates, the server and any passive observer would be able to understand when such transmissions happen (even if performance was not a problem).
-
-## Proposed solution
-
-For every fast/dense data transmission use a separate short-lived connection with dedicated SMP queues that the agents would provision to receive such transmissions.
-
-Such connections that can be unidirectional or duplex can be managed by agents via additional set of agent commands using "stream" abstraction.
-
-The protocol to create and manage such stream could be the following:
-
-1. The sender client notifies the agent about the stream it has to create for a specific duplex connection (the connection must be duplex for it to be possible): `<conn_id> SNEW <size>` (where `conn_id` is the existing duplex connection, `size` is the size for the data to be transferred; 0 for unbounded streams), the response is `<conn_id> STREAM <stream_id> <size>`.
-2. The sender agent sends to the recipient agent the "envelope" `STREAM <stream_id> <size>`
-3. The receiving agent would notify the client about availability of the stream by sending `<conn_id> STREAM <stream_id> <size>` notification.
-4. Receiving client would send `<conn_id> SJOIN <stream_id>` command to the receiving agent.
-5. Receiving agent provisions the SMP queue on the random SMP server (we planned to remove SMP server from NEW command anyway). Possibly, there will be a limited list of servers that support streams (that is un-throttled number of messages), and stream support can be communicated via welcome header and change with AUTH SMP command.
-6. Receiving agent sends the envelop to sending agent `SJOIN <stream_id> <invitation>` (where invitation has the same format as in out-of-band message, but it has symmetric AES key and IV instead of asymmetric RSA key - the encryption scheme should codified in the invitation to make it generic).
-7. Sending agent and receiving agent confirm and secure SMP queue as usual. This is still not solving the problem that the sending agent should sign each command. We might extend SMP protocol to create a new queue type that allows authenticating the sender only once per TCP session so that messages can be sent without signing - the server can see that these queues are special anyway, as there will be much faster traffic there.
-8. Sending agent, once the queue is confirmed notifies the sending client that the stream is ready to accept data by sending notification `<conn_id> SREADY <stream_id> <max_chunk_size>`.
-9. Sending agent client can now send packets into the stream up to total `<size>` limit if it was specified by using command `<conn_id> SPUT <stream_id> <chunk_no> <chunk_size> <binary> ` (the chunk size should not be bigger than `max_chunk_size`, the agent would pad it to this size before sending to the receiving agent)
-10. Sending agent would send the chunk to the receiving agent in `CHUNK <chunk_no> <ts> <chunk_size> <binary>` envelope, where the first 4 bytes in decrypted binary is chunk size.
-11. Receiving agent would send the chunk to the client as `<conn_id> SDATA <stream_id> <chunk_no> <ts> <status> <chunk_size> <binary>` (possibly, with three IDs and timestamps as with messages).
-12. Both the receiving and sending clients can terminate the stream with `<conn_id> SCLOSE <stream_id>` command. The agent would send `SCLOSED <stream_id>` envelope and the opposite client would receive `<conn_id> SCLOSED <stream_id>` notification - no more data will be accepted into this stream.
-13. If the stream was bounded with some `size` then both the sending and receiving client would receive `SCLOSED` notification after the last chunk of correct size was sent (and the incorrect chunk would be rejected).
-14. If the stream was interrupted then the recipient client can request resuming this stream using `<conn_id> SRESUME <stream_id> <from_chunk_no>`, the recipient agent would send "envelope" `SRESUME <stream_id> <from_chunk_no> <invitation>`.
-
-To be clarified:
-1. Possibly the internal stream ID used by clients should be different from stream ID communicated between agents, and in any case it should be connection scoped (same as with messages).
-2. There seems to be no need to rotate symmetric keys, disconnections can be handled.
-3. Same as we plan for redundant SMP queues with one connection, agents could use multiple queues per stream to increase the bandwidth and/or transmission reliability (e.g. for file transfers, where interruptions are not problematic multiple queues can be used in parallel, while for calls agents can duplicate all transmitted bytes so that losing some queues or TCP disconnects do not result in communication interruption).
-4. Possibly the stream creation could be initiated by the receiving agent, to have it more similar to connection creation procedure.
diff --git a/source/rfcs/2022-04-20-smp-conf-timeout-recovery.md b/source/rfcs/2022-04-20-smp-conf-timeout-recovery.md
deleted file mode 100644
index 7c7f84c..0000000
--- a/source/rfcs/2022-04-20-smp-conf-timeout-recovery.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# SMP confirmation timeout recovery
-
-## Problem
-
-When sending an SMP confirmation a network timeout can lead to the following race condition:
-- server receives the confirmation while the joining party fails to receive the server's response;
-- joining party deletes the connection together with credentials sent in the confirmation for securing the queue;
-- initiating party will receive the confirmation from the server and secure the queue;
-- on subsequent attempt to join via the same invitation link initiating party will generate new credentials and fail authorization.
-
-This renders the joining party permanently unable to join via that invitation link and complete the connection.
-
-## Solution
-
-A possible solution is to keep and try to reuse same credentials on subsequent attempts:
-- joining party has to remember invitation link when saving the connection;
-- if SMP confirmation fails due to network timeout joining party doesn't delete the connection and keeps the credentials;
-- when joining, joining party checks whether such invitation link was already used for a connection, if yes:
-  - joining party tries to send SMP confirmation with the same credentials;
-  - if this SMP confirmation fails with authorization error (for example it can happen due to race condition explained above) joining party tries to send HELLO message;
-  - if HELLO message fails with authorization error (it can happen if connection was deleted or secured with different credentials), the recovery is no longer possible and connection can be deleted.
diff --git a/source/rfcs/2022-07-22-access-via-tor.md b/source/rfcs/2022-07-22-access-via-tor.md
deleted file mode 100644
index b4517d4..0000000
--- a/source/rfcs/2022-07-22-access-via-tor.md
+++ /dev/null
@@ -1,26 +0,0 @@
-# Accessing SMP servers via Tor
-
-## Problem
-
-While SMP protocol is focussed on minimizing application-level meta-data by using pair-wise identifiers instead of user profile identifiers, it is important for many users to protect their IP addresses.
-
-Further, even if IP addresses are hidden by onion routing, clients should be able to choose to use a separate TCP connection to subscribe to each queue, even though it increases traffic and battery consumption, as otherwise the servers can observe multiple queues accessed by the same client.
-
-## Solution and requirements
-
-While some users may want to access SMP servers via tor, some other users (even their contacts) may want the opposite - e.g., if they use the network when accessing Tor would be suspicious (or blocked).
-
-Therefore we need to support the connections when one of the user accesses the same server via Tor (and, possibly, via onion address), while another user accesses this server without Tor.
-
-At the same time the user accessing the server via Tor may not want that their contacts access this server without Tor, and it also may be possible that the server is not available under a normal (not .onion) address.
-
-The proposed options for connecting via Tor are:
-
-1. Access servers via Socks proxy: no/yes (specify port?)
-2. Use .onion addresses: no/when available/warn/always
-3. Require senders to use .onion addresses: yes/no
-4. Use separate TCP connection for each queue
-
-While it should be possible for SMP servers to have two addresses (with and without Tor), the queues should only use one server address - if the queue started being accessed via .onion address it should not be possible to access it via a normal address. Queue addresses in connection invitations should support dual server addresses (when senders are not required ot use .onion address).
-
-At the same time, the queue with the normal addresses can be accessed with and without Tor, depending on the current device settings.
diff --git a/source/rfcs/2022-08-14-queue-rotation.md b/source/rfcs/2022-08-14-queue-rotation.md
deleted file mode 100644
index fa40fda..0000000
--- a/source/rfcs/2022-08-14-queue-rotation.md
+++ /dev/null
@@ -1,53 +0,0 @@
-# SMP queue rotation and redundancy
-
-## Problem
-
-1. Long term usage of the queue allows the servers to analyze long term traffic patterns.
-
-2. If the user changes the configured SMP server(s), the previously created contacts do not migrate to the new server(s).
-
-3. Server can lose messages.
-
-## Solution
-
-Additional messages exchanged by SMP agents to negotiate addition and removal of queues to the connection.
-
-This approach allows for both rotation and redundancy, as changing queue will be done be adding a queue and then removing the existing queue.
-
-The reason for this approach is that otherwise it's non-trivial to switch from one queue to another without losing messages or delivering them out of order, it's easier to have messages delivered via both queues during the switch, however short or long time it is.
-
-### Messages
-
-Additional agent messages required for the protocol:
-
-    QADD_ -> "QA"
-    QKEY_ -> "QK"
-    QUSE_ -> "QU"
-    QTEST_ -> "QT"
-
-`QADD`: add the new queue address(es), the same format as `REPLY` message, encoded as `QA`.
-
-`QKEY`: pass sender's key via existing connection (SMP confirmation message will not be used, to avoid the same "race" of the initial key exchange that would create the risk of intercepting the queue for the attacker), encoded as `QK`.
-
-`QUSE`: instruct the sender to use the new queue with sender's queue ID as parameter, encoded as `QU`.
-
-`QTEST`: send test message to the new connection, encoded as `QT`. Any other message can be sent if available to continue rotation, the absence of this message is not an error. Once this message is successfully sent the sender will stop using the old queue. Once this message (or any other message in the new queue) is received, the recipient will stop using the old queue and delete it.
-
-### Protocol
-
-```
-participant A as Alice
-participant B as Bob
-participant R as Server that has A's receive queue
-participant S as Server that has A's send queue (B's receive queue)
-participant R' as Server that hosts the new A's receive queue
-
-A ->> R': create new queue
-A ->> S ->> B: QADD (R'): snd address of the new queue(s)
-B ->> S(R) ->> A: QKEY (R'): sender's key for the new queue(s) (to avoid the race of SMP confirmation for the initial exchange)
-A ->> S(R'): secure new queue
-A ->> S ->> B: QUSE (R'): instruction to use new queue(s)
-B ->> S(R') ->> A: QTEST
-A ->> S(R): DEL: delete the old queue
-B ->> S(R') ->> A: send all new messages to the new queue
-```
diff --git a/source/rfcs/2022-11-11-smp-basic-auth.md b/source/rfcs/2022-11-11-smp-basic-auth.md
deleted file mode 100644
index f0bfbd9..0000000
--- a/source/rfcs/2022-11-11-smp-basic-auth.md
+++ /dev/null
@@ -1,27 +0,0 @@
-# SMP Basic Auth
-
-## Problem
-
-Users who host their own servers do not want unknown people to be able to create messaging queues on their servers after discovering server address in groups or after making a connection. As the number of self-hosted servers is growing it became more important than it was when we excluded it from the original design.
-
-## Solution
-
-Single access password that can be optionally included in server address that is passed to app configuration. It will not be allowed in the existing contexts (and parsing will fail), to avoid accidentally leaking it. Server address with password will look this way: `smp://fingerprint:password@hosts`
-
-## Implementation plan
-
-1. A separate type to include server and password, so it can only be used where allowed.
-
-2. Server password to create queues will be configured in TRANSPORT section of INI file, as `create_password` parameter.
-
-3. The password will only be required in server configuration/address to create queues only, it won't be required for other receiving queue operations on already existing queues.
-
-4. If new command is attempted in the session that does not allow creating queues, the server will send `ERR AUTH` response
-
-5. Passing password to the server can be done in one of the several ways, we need to decide:
-
-  - as a parameter of NEW command. Pros: a local change, that only needs checking when queue is created. Cons: protocol version change.
-  - as a separate command AUTH. Pros: allows to include additional parameters and potentially be extended beyond basic auth. Cons: more complex to manage server state, can be more difficult syntax in the future, if extended.
-  - as part of handshake (we currently ignore the unparsed part of handshake block, so it can be extended). Pros: probably, the simplest, and independent of the commands protocol ‚Äì establishes create permission for the current session. Cons: the client won't know about whether it is able to create the queue until it tries (same as in case 1).
-
-  My preference is the last option. As a variant of the last option, we can add a server response/message that includes permission to create queues - it will only be sent to the clients who pass credential in handshake - that might simplify testing server connection (we currently do not do it). It might be unnecessary, as we could simply create and delete queue in case credential is passed as part of testing connection (and even sending a message to it).
diff --git a/source/rfcs/done/2021-01-20-logging.md b/source/rfcs/done/2021-01-20-logging.md
deleted file mode 100644
index ae84f8e..0000000
--- a/source/rfcs/done/2021-01-20-logging.md
+++ /dev/null
@@ -1,70 +0,0 @@
-# SMP agent logging
-
-## Problem and proposed solution.
-
-SMP agent performs multiple actions in response to the client commands and to the messages received from other SMP agents (wrapped in SMP protocol messages).
-
-Customary approach for the network protocol clients is to have a debug/verbose mode that enables logging of all sent and received messages and any other actions that the client performs.
-
-This document proposes a logging format for SMP agent that would be enabled if the agent is run with `--verbose` / `-v` command line option.
-
-We can also consider logging the database operations that change the data.
-
-## Types of actions and the associated log line format.
-
-### Client connected / disconnected
-
-```
-client n connected to Agent
-client n disconnected from Agent
-```
-
-where `n` is a sequential number of a connected agent client, starting from 1 (over the agent run-time).
-
-### Server connected / disconnected
-
-```
-Agent connected to host:port
-Agent disconnected from host:port
-```
-
-### Received command from the client
-
-```
-n --> A : corrId connId parsed_command // raw_command
-```
-
-`raw_command` is added only in case of parsing failure.
-
-### Sent command to SMP server
-
-```
-A --> host:port : corrId queueId parsed_command
-```
-
-### Received response / message from the SMP server
-
-```
-A <-- host:port : corrId queueId parsed_command // raw_command
-```
-
-In case the response is a message or notification, corrId should be replaced with `_`
-
-### Interpreted ("unwrapped") SMP message as agent message
-
-```
-Agent msg : connId parsed_message // raw_message 
-```
-
-### Sent response / message to the client
-
-```
-n <-- A : corrId connId parsed_command // raw_command
-```
-
-### Database changes
-
-```
-DB : insert/delete/update table key
-DB : insert/delete/update table key
-```
\ No newline at end of file
diff --git a/source/rfcs/done/2021-01-26-crypto.md b/source/rfcs/done/2021-01-26-crypto.md
deleted file mode 100644
index 39ca6eb..0000000
--- a/source/rfcs/done/2021-01-26-crypto.md
+++ /dev/null
@@ -1,192 +0,0 @@
-# SMP agent: cryptography
-
-3 main directions of work to enable basic level of security for communication via SMP agents and servers at the current stage of the project:
-
-- Transport encryption - enable encryption for TCP.
-
-- Initial handshake using asymmetric key pairs, starting with out-of-band message.
-
-- E2E encryption of messages between SMP agents relayed over SMP servers.
-
-- Authentication of agent commands with SMP servers.
-
-For initial implementation I propose approach to be as simple as possible as long as it meets our security requirements. So no pluggable encryption mechanisms, no configuration, no integration with [Noise Protocol Framework](https://noiseprotocol.org), only the most necessary Crypto schemes pre-decided per area of application.
-
-## Transport encryption
-
-One of the consideration is to use [noise protocol framework](https://noiseprotocol.org/noise.html), this section describes ad hoc protocol though.
-
-During TCP session both client and server should use symmetric AES 256 bit encryption using two session keys and two base IVs that will be agreed during the handshake. Both client and the server should maintain two 32-bit word counters, one for sent and one for the received messages. The IV for each message should be computed by xor-ing the sequential message counter, starting from 0, with the first 32 bits of agreed base IV. TODO - explain it in a more formal way, also document how 32-bit word is encoded - with the most or least significant byte first (currently encodeWord32 from Network.Transport.Internal is used)
-
-To establish the session keys and base IVs, the server should have an asymmetric key pair generated during server deployment and unknown to the clients. The users should know the key hash (256 bits) in advance in order to be able to establish connection.
-
-The handshake sequence is the following:
-
-1. Once the connection is established, the server sends server_header and its public RSA key encoded in X509 binary format to the client.
-2. The client compares the hash of the received key with the hash it already has (e.g. received as part of connection invitation or server in NEW command). If the hash does not match, the client must terminate the connection. TODO as the hash is optional in server syntax at the moment, hash comparison will be optional as well. Probably it should become required.
-3. If the hash is the same, the client should generate random symmetric AES keys and base IVs that will be used as session keys/IVs by the client and the server.
-4. The client then should construct client_handshake block and send it to the server encrypted with the server public key: `rsa-encrypt(client_handshake)`. `snd_aes_key` and `snd_base_iv` will be used by the client to encrypt **sent** messages and by the server to decrypt them, `rcv_aes_key` and `rcv_base_iv` will be used by the client to decrypt **received** messages and by the server to encrypt them.
-5. The server should decrypt the received keys and base IVs with its private key.
-6. In case of successful decryption, the server should send encrypted welcome block (encrypted_welcome_block) that contains SMP protocol version.
-
-All the subsequent data both from the client and from the server should be sent encrypted using symmetric AES keys and base IVs (incremented by counters on both sides) sent by the client during the handshake.
-
-Each transport block sent by the client and the server has this syntax:
-
-```abnf
-server_header = block_size protocol key_size
-block_size = 4*4(OCTET) ; 4-byte block size sent by the server, currently the client rejects if > 65536 bytes
-protocol = 2*2(OCTET) ; currently it is 0, that means binary RSA key
-key_size = 2*2(OCTET) ; the encoded key size in bytes (binary encoded in X509 standard)
-
-client_handshake = client_block_size client_protocol snd_aes_key snd_base_iv rcv_aes_key rcv_base_iv
-client_block_size = 4*4(OCTET) ; 4-byte block size sent by the client, currently it is ignored by the server - reserved
-client_protocol = 2*2(OCTET) ; currently it is 0 - reserved
-snd_aes_key = 32*32(OCTET)
-snd_base_iv = 16*16(OCTET)
-rcv_aes_key = 32*32(OCTET)
-rcv_base_iv = 16*16(OCTET)
-
-transport_block = aes_body_auth_tag aes_encrypted_body
-; size is sent by server during handshake, usually 8192 bytes
-aes_encrypted_body = 1*OCTET
-aes_body_auth_tag = 16*16(OCTET)
-
-encrypted_welcome_block = transport_block
-welcome_block = smp_version SP pad ; decrypt(encrypted_welcome_block)
-smp_version = %s"v" 1*DIGIT "." 1*DIGIT "." 1*DIGIT ["-" 1*ALPHA "." 1*DIGIT] ; in semver format
-  ; for example: v123.456.789-alpha.7
-pad = 1*OCTET
-```
-
-## Possible future improvements/changes
-
-- server id (256 bits), so that only the users that have it can connect to the server. This ID will have to be passed to the server during the handshake
-- block size agreed during handshake
-- transport encryption protocol agreed during handshake
-- welcome block containing SMP mode (smp_mode)
-
-```abnf
-smp_mode = smp_public / smp_authenticated
-smp_public = %s"pub" ; public (default) - no auth to create and manage queues
-smp_authenticated = %s"auth" ; server authentication with AUTH command (TBD) is required to create and manage queues
-```
-
-## Initial handshake
-### Why handshake has to be with asymmetric keys
-
-The following only makes sense under the assumption that public keys are not really used as "public", but are created as random and treated as secret instead.
-
-    E controls servers & listens out-of-band.
-    Keys are generated on the clients (A & B), queues are generated on servers.
-    1. A generates Apub, Aprv, BAq
-    2. A --oob-> B: Apub, BAq; E listens this, however she can't substitute this (passive attack on out-of-band, active on servers)
-    3. E generates EpubA, EprvA, AEq
-    4. E --BAq-> A: EpubA, AEq - encrypted with Apub;
-    Alice thinks this message is from Bob
-    5. B generates Bpub, Bprv, ABq
-    6. B --BAq-> ~~A~~E: Bpub, ABq - encrypted with Apub;
-    Eve controls servers so this doesn't get sent to Alice, instead it is received by Eve
-    7. Eve has to send to Bob via ABq encrypting with his Bpub. By controlling servers E could know ABq so she wouldn't have to decrypt it - she knows where to send. Even so she can't decrypt Bpub w/t Aprv. The problem [for Eve] is that Bpub and Aprv are generated on the clients, which she doesn't control.
-
-If keys were symmetric Eve could simply decrypt Bob's key with the key Alice sent out-of-band.
-
-### Where MITM attempt fails
-
-In asymmetric setup the following happens:
-
-- In Bob to Alice direction Eve intercepts messages from Bob and re-encrypts them using Apub.
-
-- In Alice to Bob direction Alice encrypts messages with EpubA and Eve can decrypt them with EprvA. Eve can't, however, re-encrypt them for Bob because she doesn't know Bpub. She also couldn't substitute it because it is out of her control. Alice wouldn't [technically] notice the MITM attempt, but Bob will not be receiving decryptable messages, and he would have to tell Alice out-of-band.
-
-> **To be discussed:** Implementation-wise Bob's connection probably should be shut down if he receives a message he fails to decrypt, or after some timeout if he doesn't receive messages.
-
-### Handshake implementation
-
-TODO
-
-## E2E encryption
-
-For E2E encryption of messages between SMP agents we should go with some robust [Authenticated Encyption](https://en.wikipedia.org/wiki/Authenticated_encryption) scheme following [Encrypt-then-MAC](https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC_(EtM)) approach.
-
-Since we have a shared secret Apub, Bpub (if Apub is compromised connection should be shut down on Bob's side, see [above](#-Where-MITM-attempt-fails)) there is no point in using digital signatures over MACs for message authentication other than non-repudiation. Besides [digital signatures generally being less performant than MACs](https://crypto.stackexchange.com/a/37657), the non-repudiation quality I believe may in fact be more undesirable than not for many possible applications. If some applications require non-repudiation it can be implemented later on with digital signatures on application level. See a good answer on differences of MAC and digital signature qualities [here](https://crypto.stackexchange.com/a/5647).
-
-Symmetric keys are generated per message and encrypted with receiver's public key (encryption key).
-
-The syntax of each encrypted message body is the following:
-
-```abnf
-encrypted_message_body = rsa_signature encrypted_body
-encrypted_body = rsa_encrypted_header aes_encrypted_body
-rsa_signature = 256*256(OCTET) ; sign(encrypted_body) - assuming 2048 bit key size
-rsa_encrypted_header = 256*256(OCTET) ; encrypt(header) - assuming 2048 bit key size
-aes_encrypted_body = 1*OCTET ; encrypt(body)
-
-header = aes_key aes_iv auth_tag payload_size
-aes_key = 32*32(OCTET)
-aes_iv = 16*16(OCTET)
-auth_tag = 16*16(OCTET)
-payload_size = 4*4(OCTET)
-
-body = payload pad
-```
-
-Future considerations:
-- Generation of symmetric keys per session and session rotation;
-
-## E2E implementation
-
-### Message encryption
-
-For each message, the agent performs the following actions to encrypt it:
-
-1. Generates random AES256 key with [getRandomBytes]() - see [tutorial](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-Tutorial.html)
-2. Pad the message using some padding scheme TBC - we could consider [PADM√â](https://petsymposium.org/2019/files/papers/issue4/popets-2019-0056.pdf), but there is no existing implementation. This particular scheme is protected against both understanding the nature of the traffic and has low overhead (< 12%). There are various other padding schemes described [here](https://en.wikipedia.org/wiki/Padding_(cryptography)) - the proposal is to postpone this decision and not to include any padding in the chat prototype to be released.
-3. Encrypt the message using this AES256 key with [AES-GCM-SIV](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-Cipher-AESGCMSIV.html) (AEAD scheme) using the function `encrypt` with a random nonce.
-4. Encrypt the AES256 key with public encryption key for the queue using RSA-OAEP [encrypt](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-PubKey-RSA-OAEP.html#v:encrypt) function parameterized with [SHA256](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-Hash-Algorithms.html#t:SHA256) algorithm.
-5. The message to send is concatenation of:
-    1. encrypted AES256 key,
-    2. AuthTag from encryption in step 3, 
-    3. encrypted message (in this order).
-
-As there is no additional data that is sent e2e in clear text, we potentially need some simpler algorithm, possibly the one implemented in the tutorial, that implements authenticated encryption without additional (unencrypted) data.
-
-Or we could use this algorithm to allow some data that is sent e2e in clear text later.
-
-### Message decryption
-
-Agent decrypts the message following the same steps in the opposite order:
-
-1. Split encrypted message to AES256 key, AuthTag and encrypted message - tag and key have fixed size (?).
-2. Decrypt AES256 key using the decryption key (the private key that recipient has).
-3. Decrypt the message using AES256 key.
-4. Remove the padding - scheme TBC, not in the initial implementation.
-
-## Authentication with SMP server
-
-Each command sent to the server should include digital signature in the first part of the SMP transmission.
-
-To compute the signature, the agent will use [signSafer](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-PubKey-RSA-PSS.html#v:signSafer) function parameterized with [SHA256](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-Hash-Algorithms.html#t:SHA256) algorithm with the "signed" part of the transmission.
-
-To verify the signature, the server will use [verify](https://hackage.haskell.org/package/cryptonite-0.28/docs/Crypto-PubKey-RSA-PSS.html#v:verify) function with the same hash algorithm.
-
-The above implies that the way the transmissions are processed should change.
-
-It is simpler during the sending, because it is possible to serialise signed part, prepend the signature and then send it.
-
-It is more difficult during the receiving because to read the whole transmission it has to be parsed first (in order to have the size of the message in SEND command and to read the remaining binary), then serialized back, and only after it the signature can be verified. Possible solution is to have both unparsed and parsed transmission in some data structure (e.g. tuple) to avoid unnecessary serialisation.
-
-The proposed change is also to change SMP protocol in this way:
-1. to have components of a signed transmission part on a single line, space-separated, rather than on multiple lines (to avoid byte-string differences because of different presentation of the end of line)
-2. the separation between SEND and binary part does not matter as binary is read separately and can be consistently appended with CRLF (arguably, it also applies to the rest of transmission part, but it is just simpler to read and parse one line and then append binary, if necessary, for signature verification).
-
-```abnf
-transmission = [signature] CRLF signed CRLF
-signed = [corrId] SP [queueId] SP msg
-```
-
-Off topic: SMP agent protocol can also be similarly changed to align with SMP protocol.
-
-## Concerns
-
-- MITM between SMP agent and server is still possible w/t transport encryption.
diff --git a/source/rfcs/done/2021-01-26-messages.md b/source/rfcs/done/2021-01-26-messages.md
deleted file mode 100644
index 71db024..0000000
--- a/source/rfcs/done/2021-01-26-messages.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# SMP Agent: message management
-
-The proposal is to change the way SMP agent manages the messages from the SMP servers.
-
-Currently, it acts just as a proxy, when it does not receive any further messages from the server until the client ACKs them. The downside with this approach is that the agent can't work autonomously from the client, and the client always has to be active to retrieve the messages from the server. So while the agent offers a convenient, higher abstraction level when it comes to establishing connections, it does not offer any advantage over message management than using SMP server directly. There is a benefit to have an agent as a local, mailbox-like layer that downloads all messages for all connections and makes them available for further processing on the application layer.
-
-## Phase 1. Managed agent MVP
-
-These should be sufficient for terminal chat prototype
-
-- Agent only maintains active subscriptions to the connections that the clients explicitly requested, only during client sessions, using `SUB` command.
-- Agent would automatically send `ACK` commands to SMP servers and store them in the database.
-- When the client subscribes to the connection (`SUB` - subscribe and deliver all messages received from the server) the response to `SUB` command is `OK`.
-- Receiving agent should maintain its own numbering in addition to the sending agent numbering, in case the sending agent message number decreases.
-- When there is an active subscription, Agent forwards messages to the connected clients in the order of their arrival, without any confirmations from the clients. It is client's responsibility to track that they didn't miss any messages and request re-delivery if needed.
-
-## Phase 2. Subscription management and message access
-
-- When the client subscribes to the connection (`SUB` - subscribe and deliver all missed messages) the response to `SUB` command is `NOMSG` or `MID n` where n is the ID of the last received message (1-based).
-- `SUB SKIP` - subscribe but only deliver the new messages
-- `SUB OFF` - turn off subscription
-- Messages received by the agent during the period when there was no active client subscription are not sent to the client automatically - client has to request them one by one using `MGET n` command (it can also be used to request re-delivery of old messages or for any other direct access scenario).
-- Clients can delete received messages using `MDEL n` command, where `n` is a sequential agent-assigned message ID - same that was used in `MSG` delivery.
-- Clients can confirm the receipt of the messages to the sender using `MACK n` command
-- Client can also request the last message ID with `MLAST` command - with the same responses.
-
-## Phase 3. Autonomous agent
-
-- Agent maintains active subscriptions to all connections that the clients created, whether there are active sessions with the clients or not.
-- `SUB ON` command would be used to receive messages from the agent, and while it is active the agent would maintain an active TCP connection(s) with the server(s) to retrieve the messages as soon as they arrive.
-- In the absence of the client connection the agent would periodically check and retrieve messages from the servers, possibly up to a quota, from all active connections. If the servers do not reply, the agent could have some retry logic with exponential back-off eventually marking connections (and/or servers) as unresponsive.
-
-This design allows to have a single agent running in the background with multiple client applications connecting to it. It provides better message delivery guarantees, assuming transient nature of SMP server storage.
\ No newline at end of file
diff --git a/source/rfcs/done/2021-05-17-open-connection.md b/source/rfcs/done/2021-05-17-open-connection.md
deleted file mode 100644
index 02eec21..0000000
--- a/source/rfcs/done/2021-05-17-open-connection.md
+++ /dev/null
@@ -1,52 +0,0 @@
-# Open connections
-
-## Problem
-
-This proposal describes how to create invitations that can be used multiple times. 
-
-It can be used for:
-- an open invitation to join a group.
-- an open invitation to connect to a person - e.g. QR code/invitation link on a person's website, or passed from one person to another.
-- part of the solution for public DNS-based addresses (when a directory server would map address in some domain name#example.tld to an open invitation).
-
-## Solution
-
-No changes to SMP protocol - a dedicated unsecured SMP queue is used to receive invitations to connect that are sent in encrypted agent message. An unsecured SMP queue is used as an out-of-band channel for establishing another SMP queue.
-
-Additional parameters in commands in SMP agent protocol:
-
-- `NEW` command will have a parameter `INV` or `CON` to create an invitation or a permanent contact connection.
-
-`conn_id? OPEN` (or `PUB`, `NEWPUB`, tbc) - to create an "open"/"public" queue, the response is an invitation in a different format (TBC):
-  - should allow multiple servers (probably the original invitation should be extended to support it)
-  - should have a marker to indicate it's an open/public queue (probably the original invitation should be extended to include an invitation type).
-
-e.g. `smp:<queue_type>::<server1>/<queue_id1>,<server2>/<queue_id2>::<key1>`
-
-`queue_type`:
-  - `prv` - original invitation, should be accepted with KEY SMP message
-  - `pub` - open invitation, should be accepted with INV SMP message (to be added to SMP protocol)
-
-```mmd
-A ->> AA: oidA? OPEN
-AA ->> A: oidA INV pub_inv
-
-...
-
-B ->> BA: cidBA? JOIN pub_inv len CRLF meta_binary CRLF ; change command to require meta, len can be 0 for the current usage ; meta is used to send user profile
-BA ->> B: cidBA OK
-BA ->> SA ->> AA: INV prv_inv CRLF meta_binary
-AA ->> A: oidA CONF invID len meta_binary
-A ->> AA cidAB? LET invID
-
-establish connection as usual
-
-BA ->> B: cidBA CON
-AA ->> A: cidAB CON
-```
-
-That protocol requires addressing the current problem when an invitation cannot be accepted when the party that generated the invitation is not online.
-
-Questions.
-
-1. Do we need to differentiate the semantics of the invitation on the syntax level, or should we allow to just manage it outside of protocol when the receiving agent decides which SMP messages to accept and which to ignore (KEY / INV).
\ No newline at end of file
diff --git a/source/rfcs/done/2022-03-22-nofication-server.md b/source/rfcs/done/2022-03-22-nofication-server.md
deleted file mode 100644
index eebb948..0000000
--- a/source/rfcs/done/2022-03-22-nofication-server.md
+++ /dev/null
@@ -1,91 +0,0 @@
-# Notification server
-
-## Background and motivation
-
-SimpleX Chat clients should receive message notifications when not being online and/or subscribed to SMP servers.
-
-To avoid revealing identities of clients directly to SMP servers via any kind of push notification tokens, a new party called SimpleX Notification Server is introduced to act as a service for subscribing to SMP server queue notifications on behalf of clients and sending push notifications to them.
-
-## Proposal
-
-TCP service using the same TLS transport as SMP server, with the fixed size blocks (256 bytes?) and the following set of commands:
-
-### Protocol
-
-#### Create subscription
-
-Command:
-
-`%s"CREATE " ntfSmpQueueURI ntfPrivateKey token subPublicKey`
-
-Response:
-
-`s%"OK"`
-
-#### Check subscription status
-
-Command:
-
-`%s"CHECK " ntfSmpQueueURI`
-
-Response:
-
-```abnf
-statusResp = %s"STAT " status
-status = %s"ERR AUTH" / "ERR SMP AUTH" / %s"ERR SMP TIMEOUT" / %s"ACTIVE" / %s"PENDING"
-```
-
-#### Update subscription device token
-
-Command:
-
-`%s"TOKEN " ntfSmpQueueURI token`
-
-Response:
-
-`s%"OK" / %s"ERR"`
-
-#### Delete subscription (e.g. when deleting the queue or moving to another notification server)
-
-Command:
-
-`%s"DELETE " SP ntfSmpQueueURI`
-
-Response:
-
-`s%"OK" / %s"ERR"`
-
-### Agent schema changes
-
-See [migration](../src/Simplex/Messaging/Agent/Store/SQLite/Migrations/M20220322_notifications.hs)
-
-### Agent code
-
-```haskell
-data NtfOptions = NtfOptions
-  { ntfServer :: Server, -- same type as for SMP servers, probably will be renamed
-    ntfToken :: ByteString,
-    ntfInitialCheckDelay :: Int, -- initial check delay after subscription is created, seconds
-    ntfPeriodicCheckInterval :: Int -- subscription check interval, seconds
-  }
-
-data AgentConfig = AgentConfig {
-  -- ...
-  initialNtfOpts :: Maybe NtfOptions
-  -- ...
-  }
-
-data AgentClient = AgentClient {
-  -- ...
-  ntfOpts :: TVar (Maybe NtfOptions)
-  -- ...
-  }
-```
-
-A configuration parameter `initialNtfOpts :: Maybe NtfOptions` - if it is set or changes the agent would automatically manage subscriptions as SMP queues are subscribed/created/deleted and as the token or server changes.
-
-There will be a method to update notifications configuration in case token or server changes.
-
-All subscriptions will be managed in a separate subscription management loop, that would always take the earliest un-updated subscription that requires some action (ntf_sub_action column) and perform this action - the table of subscription would serve both as the table of existing subscriptions and required actions.
-
-E.g. if the queue is subscribed and there is no notification subscription, it will be created in the table with "create" action, and the loop would create it and schedule "check" action on it.
\ No newline at end of file
diff --git a/source/rfcs/done/2022-06-05-smp-notifications.md b/source/rfcs/done/2022-06-05-smp-notifications.md
deleted file mode 100644
index 4e58189..0000000
--- a/source/rfcs/done/2022-06-05-smp-notifications.md
+++ /dev/null
@@ -1,34 +0,0 @@
-# SMP protocol changes to support push notifications on iOS
-
-## Problem
-
-There are already commands/responses to allow subscriptions to message notifications - NKEY/NID, NSUB/NMSG. These commands will be used by SMP agent (NKEY/NID) and by notification server (NSUB/NMSG) to have message notifications delivered to notification server, so it can forward them to APNS server using device token.
-
-There are two remaining problems that these commands do not solve.
-
-1. Receiving the message when notification arrives.
-
-iOS requires creating a bundled notification service extension (NSE) that runs in isolated container and, if we were to use the existing commands, would have SMP subscription to the same SMP servers as the main app, triggering resubscriptions every time the message reception switches between the app and NSE. That would cause a substantial increase in traffic and battery consumption to the users.
-
-2. Showing notifications for service messages.
-
-Users do not expect to see notifications for every single SMP messages - e.g., we currently do not show notifications when messages are edited and deleted, and users do not expect them. NSE requires that for every received push notification there should be some notification shown to the users. So only we would have to show a notification for message deletes and updates, we would have to show it for all service messages - e.g. user accepted file invitation, or file transmission has started, contact profile updates and so on.
-
-We considered differentiating whether notifications are sent per queue, from the recipient side, so we do not send notifications for file queues. But it seems insufficient, particularly if we add such features as message receipts, status updates, etc.
-
-## Proposal
-
-1. To retrieve messages when push notifications arrive, we will add 2 SMP commands:
-
-- GET: retrieve one message from the connection. Resonse could be either MSG (the same as when MSG is delivered, but with the correlation id) or GMSG (to simplify processing) ‚Äì TBC during implementation. If message is not available, the response could be ERR NO_MSG
-- ACK or GACK: acknowledge that the message was processed by the client and can be removed - TBC which one is better. The response is OK or ERR NO_MSG if there was nothing to acknowledge (same as with ACK now)
-
-This would allow receiving a single message from the queue without subscription, this way avoiding that the main app is unsubscribed from the queue.
-
-2. The only way to avoid showing unnecessary notifications (status updates, service messages, etc.) is to avoid sending them. That requires instructing SMP server whether notification should be sent both per queue, from the recipient side, and per message - from the sender side. So the notification would only be sent if the queue has them enabled (via NKEY command) and the sender includes an additional flag in SEND command. The same flag should be included into MSG, so when the message is retrieved with GET command, the client knows, on the agent or chat level (or both), whether this message should have notification shown to the user, and if not - retrieve the next one(s) as well.
-
-This is a substantial change to SMP protocol, that would require client and server upgrade for notifications to be supported.
-
-We should consider whether to increase the SMP protocol version number to 2, so that the new clients can connect to the old clients but without notifications, or we could keep the old commands in the protocol and instead of adding flags to the existing commands, create new commands.
-
-We can also consider making commands extensible so that the new flags can be added (and ignored by parsers if not supported) to at least some existing commands.
diff --git a/source/rfcs/done/2022-06-13-db-sync.md b/source/rfcs/done/2022-06-13-db-sync.md
deleted file mode 100644
index dc375e2..0000000
--- a/source/rfcs/done/2022-06-13-db-sync.md
+++ /dev/null
@@ -1,75 +0,0 @@
-# DB access and processing messages for iOS notification service extension
-
-## Problem
-
-The only way to receive/process notificaitons is via a separate NSE process that requires a concurrent DB and network access.
-
-SQLite concurenncy does not work, so we need to sync database access.
-
-The problem is complex, as we do not directly control db access from the app, it can be triggered by the message arriving and it may fail to complete in case the app is suspended in the background.
-
-So we need to prevent db access from starting when we know the app is about to be suspended.
-
-The last problem is how to receive and process messages in NSE - should it use recently added GET command or should it subscribe to the connections that receive messages and process messages normally.
-
-To summarize, 2 problems need to be solved:
-
-1. sync db access between 2 (or more, if we add share extension) processes
-
-2. prevent access from starting when the process is due to suspend, only complete operations.
-
-3. Receiveing and processing agent messages in NSE
-
-## Proposed solution
-
-For problem 1, we can use Posix semaphores from our core code, in the same bracket that manages database connection - it would wait for semaphore to be free and unlock it once the db operation is complete.
-
-For problem 2, we need to communicate from the app when it goes to the background to prevent database access starting and completing before the suspension. This would set some `aboutToSuspend` STM flag (or the opposite) that would prevent operations from progressing (using STM retry, that would block until the flag has the value allowing operation to progress).
-
-Several possibilities can be considered:
-
-- use this flag in the bracket that provides DB connections. While simple, it may lock some operations in the middle and may also lead to the situation when network operation succeeds but database access was blocked, and the database is not updated.
-- use this flag to stop network operations that would require database updates - like sending messages, subscriptions and ACK - all these operations would require database access once they succeed.
-- use two flags, for both cases above, but set them at different times since going to background - block new network operations as soon as the app goes to the background and block database access once the app is about to be suspended.
-
-The last option seems more robust. To do it, there will be an api allowing the app to communicat its phase:
-
-- app going to the background would trigger blocking new network operations and start a new background task - `background` phase.
-- background task receiving completion warning, or, maybe, some time after it is started - probably 20 seconds - or whatever happens earlier - would trigger call blocking db access - `suspended` phase.
-- app becoming active would trigger unblocking both flags - `active` phase.
-
-`/_app phase <phase>` where `phase` can be one of the above values.
-
-NSE would also use the same phases:
-
-- sending `active` when it is started (the process starts as active, but it is possible that the new notification arrives to the same process, after the previous one sent background/suspension)
-- sending `background + suspended` (or `suspended` should set both flags) once it is finished processing the notification, provided no new notification arrived and started processing - this should be tracked in NSE.
-
-For problem 3, NSE can do one of the following:
-
-- use SUB and process messages normally - the downside is that the app will have to resubscribe and it has to be tracked.
-- use GET and process messages by pushing them through the processing function - the downside it that a rewiring of message processing is needed.
-- use GET but deliver messages through the same queue as when they arrive normally (in which case getMessage agent function should not return the message, but will return a flag showing whether the message was received, or, possibly, or, possibly will return a message but the message would also be sent to the queue?).
-- process messages in agent manually and in chat via the queue.
-
-One of the downside of GET is that it requires calling GET again after ACK. We could have two variants of ACK (or additional ACK parameter) - one that never delivers a new message, and another one that does. In this case, if get needs to process the next message (when the current one has no notification flag), it can call ACK that delivers the next message. But, it is probably a premature optimization, and having general support of batched commands would add more value.
-
-Additional problem is concurrency in NSE - if the new notification from the same queue arrives before the current one finishes processing in the same process one of the following can happen:
-
-- the 2nd notification naively call GET and receives the same message.
-- the 2nd notification waits until the first finished processing, in which case it can run out of time.
-
-The problem is that the app won't know it's the same queue, as nId is encrypted, so the agent should handle this scenario when the new call to getMessage is made before the previous one finished processing, and differentiate between calls made for additional messages (possibly, getMessage should include previous message ID, if it is available) and the first call.
-
-EDIT: GETs have to be sent from UI to chat and from chat to agent as function calls, but the agent will have to queue get calls to make sure they return different messages. GET call would return message flags (incl. notification flag), so that the UI can send the next GET if needed without waiting.
-
-Considered alternative: include notification content in the message and have NSE only perform decryption, without any network IO. In this case notification content would be in SEND and in NMSG, e2e encrypted.
-
-While promising, as it solves network coordination issues and makes GET unnecessary, it creates mutliple other problems, so it was rejected:
-
-- message content is exposed to centralized ntf and apns servers, creating additional attack vector.
-- it adds complexity in security critical parts of the stack - double ratchet encryption, as it requires either storing message keys and using different IVs for notifications, or initializing completely separate ratchet for notifications content.
-- it reduces the size of the message.
-- it makes user experience worse, as:
-  - it would not accelerate handshake for new contacts and for file delivery - this approach only works for content messages.
-  - it would open the app without the new messages - the users would have to wait until the messages are received. It is also bad for "security optics" - the users might think that the message content was exposed to notifications.
diff --git a/source/rfcs/done/2022-06-13-db-sync.mmd b/source/rfcs/done/2022-06-13-db-sync.mmd
deleted file mode 100644
index 022f57d..0000000
--- a/source/rfcs/done/2022-06-13-db-sync.mmd
+++ /dev/null
@@ -1,61 +0,0 @@
-sequenceDiagram
-  participant M as iOS message<br>notification
-  participant S as iOS system
-  participant N as iOS NSE
-  participant U as iOS UI
-  participant C as Core chat
-  participant A as Core agent
-
-  M ->> N: notification
-  S ->> N: get app pref
-  note over N: ignore,<br>app is active
-
-  note over M, A: app going to background
-  S ->> U: phase: background<br>(possibly, "will" method)
-  U ->> S: set app pref "pausing"
-  U ->> C: /_app phase paused, result CRCmdOk
-  C ->> A: pauseAgent<br>(no new network IO)
-  M ->> N: notification
-  S ->> N: get app pref
-  note over N: wait/poll for<br>"paused"/"suspending"/"suspended"<br>event/pref
-  A ->> C: event "IO paused"<br>(after in-flight op completed)<br>PHASE PAUSED
-  C ->> U: event "IO paused" (CRAppPaused)
-  U ->> S: set shared pref "paused"
-
-  note over M, A: process notification
-  M ->> N: notification
-  S ->> N: get app pref<br>continue if<br>"paused"/"suspending"/"suspended"
-  N ->> S: set NSE pref "active"
-  N ->> C: /_get message
-  C ->> A: getMessage
-  A ->> C: msg flags
-  C ->> N: msg flags
-  note over N: get messages<br>until notification flag set
-  A ->> C: MSG/CONF/INFO
-  C ->> N: some event
-  N ->> S: set NSE pref "completed"
-  N ->> S: show notification
-
-  note over M, A: app about to be suspended<br>(or 15-20 sec after background)
-  S ->> U: background task notice
-  U ->> S: set app pref "suspending"
-  U ->> C: /_app phase suspended, response ok
-  C ->> A: suspendAgent<br>(no new DB)
-  A ->> C: event "DB paused"<br>(after in-flight op completed)<br>PHASE SUSPENDED
-  C ->> U: event "DB paused" (CRAppSuspended)
-  U ->> S: set app pref "suspended"
-
-  note over M, A: app about to be activated
-  S ->> U: phase: active<br>(or inactive?)<br><br>(possibly, "will" method)
-  S ->> U: get NSE pref
-  U ->> S: set app pref "activating"
-  alt nse active?
-    U ->> C: /_app phase inactive
-    note over U: poll/wait till NSE pref is "completed"
-  end
-
-  U ->> C: /_app phase active (response result)
-  C ->> A: activateAgent<br>(allow IO/DB)
-  A ->> C: result ()
-  C ->> U: CRCmdOk
-  U ->> S: set app pref "active"
diff --git a/source/rfcs/rejected/2021-05-23-broadcast.md b/source/rfcs/rejected/2021-05-23-broadcast.md
deleted file mode 100644
index 506118d..0000000
--- a/source/rfcs/rejected/2021-05-23-broadcast.md
+++ /dev/null
@@ -1,50 +0,0 @@
-# SMP agent broadcast
-
-## Problem
-
-Support agent message broadcast to multiple connections.
-
-It is done in ad-hoc way as part of the previous [groups proposal](./2021-05-23-groups2.md) - this proposal defines broadcast as a separate agent primitive to simplify group management.
-
-It can also be used for other purposes when the same message needs to be sent to multiple recipients without creating groups.
-
-## Solution
-
-A minimal protocol of additional client commands to create, manage and use broadcasts.
-
-From the point of view of the recipient this will look like a normal message, as if the sending agent executed multiple send commands (in fact, broadcast can be implemented by agent sending itself multiple SEND commands)
-
-### Commands and messages
-
-- command `B:bId? NEW` - create broadcast (response is `B:bId OK`, or `ERR` if broadcast already exists)
-- command `B:bId ADD C:cId` - add existing connection to a broadcast (response is `B:bId OK` or `ERR`, e.g. if connection already added or does not exist)
-- command `B:bId SEND msg` - broadcast message (response is multiple `B:cId SENT [C:bId] msgId` or ERR, separately for each connection and then for the broadcast)
-- message `B:bId SENT [C:bId] msgId` - notification that the message is sent to a specific or all recipients
-- command `B:bId REM C:cId` - remove connection from broadcast (response is `B:bId OK` or `ERR`)
-- message `B:bId EMPTY` - all connections were removed from the broadcast
-- command `B:bId DEL` - delete broadcast (response is `B:bId OK` and when the last connection is removed an additional `B:bId EMPTY` is sent)
-- command `B:bId LS` - list connections in broadcast, response is `B:Id MS space_separated_connections`
-- message `B:bId MS space_separated_connections`
-
-## Questions
-
-1. Should broadcast IDs use the same namespace as connection IDs (and as group IDs)? Having the same namespace for all abstractions that the agent can operate on can be helpful, as it can also allow implementing some queries to determine which type a given ID has, but it also increases implementation complexity.
-
-2. Given that this abstraction would be used as internal abstraction for groups (same as connections internal to the group), it might be better to implement "agent users", each with its own connection namespace. In this case agent would use itself as one of the users.
-
-3. There is a similarity of commands for connections, groups and broadcasts, they only differ on the single-letter prefix. We could do one of the following:
-  - use the same command for different object types. This feels incorrect and error prone on its own.
-  - extend transmission structure with the field defining the object type (connection, group, broadcast, etc.).
-
-In this case, the transmission would look like:
-
-```
-agentTransmission = [corrId] CRLF objectType:[objectID] CRLF agentCommand
-objectType = C | B | G ; this is the additional field
-```
-
-This approach would allow reusing the existing command avoiding the unnecessary repetition.
-
-In this case, the command type could be parameterized with the list of supported agent object types, so we can ensure on the type level that only allowed commands can be constructed.
-
-EDIT: This approach is already implemented
diff --git a/source/rfcs/rejected/2021-05-23-groups2.md b/source/rfcs/rejected/2021-05-23-groups2.md
deleted file mode 100644
index 672d807..0000000
--- a/source/rfcs/rejected/2021-05-23-groups2.md
+++ /dev/null
@@ -1,134 +0,0 @@
-# SMP agent groups
-
-## Problems
-
-- device/user profile synchronisation
-- group communication
-
-Both use cases can be facilitated by message broadcasts between a group of SMP agents.
-
-## Solution: symmetric groups as part of SMP agent protocol
-
-The proposed approach does not scale to large groups, as each agent has to broadcast the messages of their clients to all other agents in the group. While for large group it is more effective to have a server managing the list of group members, it introduces the challenges with key distribution, privacy etc.
-
-This proposal contains the set of additional SMP agent commands and message envelopes to provide a low level abstraction for group communication.
-
-The groups are symmetric, all agents who are members of the group have equal rights and can add and remove members and leave group. Higher level protocol can manage the permissions of the different users, user and group profiles, using reserved fields for passing arbitrary information about the groups and the members.
-
-All the information about the groups is stored only in the agents.
-
-## Group message integrity
-
-Two approaches are possible:
-
-1. Each agent on a regular interval sends to all agents the sender IDs and the digests of the last messages from all agents they communicate with.
-To avoid `(n-1)*n` messages for each group integrity verification, IDs and digests from all senders can be compacted in one messages:
-
-```
-broadcast: %s"CHECK" SP memId1 ":" msgId1 ":" hash1 ":" status1 SP memId2 ":" msgId2 ":" hash2 ":" status2
-```
-
-A side question is that we currently do not support large agent messages; possibly we should support messages larger than SMP block size to simplify this and other scenarios, similarly to how websockets protocol does it. There might still be a limit to how large the full message can be. That probably requires re-thinking of how messages are managed and separation of message reception from the servers and message delivery to the clients, but this is likely to be required anyway for when we start running the agent in the background.
-
-There may be two situations to consider:
-
-1) The recipient of this verification message can have the same message as the last one or they can have more messages received - both such scenarios are ok and do not necessarily indicate a problem, as they just might be slightly ahead in receiving the messages. They would make the last matching message as ok, and the latter messages would remain unknown - it does not indicate the lack of integrity of the group, although if the next integrity check without the same messages does (this needs to be clarified).
-2) The recipient of this verification message can have fewer messages received. This situation can be resolved in several ways:
-- try to retrieve all messages from the queue that is behind. It might work, but it may be that the sender is simply trying to send messages because the network is down.
-- wait until the next integrity check and only report integrity violation if during the next integrity check they still cannot reconcile the previous integrity check. This is probably an acceptable compromise.
-
-2. Each agent sends message receipts to sending agents - message receipts would contain a signature of the message hashes. In the agent uses the same verification key for each member of the group, as considered below, these receipts can be re-broadcasted to other agents (again, grouping them in one message to avoid `(n-1)*n` messages) as a proof that the messages were delivered.
-
-Comparing with the first approach, there are pros and cons:
-- pros:
-  - the sender would only send such integrity check messages when they have send a message to all parties, thus avoiding the situation when some messages might have been not yet sent (or failed to send and they are retrying).
-- cons:
-  - integrity check message mush contain a signature per member, so it would be substantially larger.
-  - agents must use the same verification key for all members in the group, complicating the group and connections management.
-  - in the same way as in the first scenario, some delivery notifications can be arbitrarily delayed.
-
-With either approach, each agent should probably track all the receipts of all messages from all agents. 
-
-Overall the first approach seems better. It shows who received which messages and the only case where the lack of integrity would be reported if the message with the same order number is different or some messages are skipped to some recipients (i.e. they broadcast integrity violation for some of the senders).
-
-## Agent commands and messages syntax
-
-- command `G:gId? NEW` - create group (response is `G:gId OK`, or `ERR` if this group already exists)
-- command `C:cId INTRO G:gId gInfo` - invite existing connection to a group
-- message `C:cId REQ G:invID gInfo` - invitation to join the group
-- command `G:gId? ACPT G:invId` - accept invitation (response is `G:gId OK`)
-- message `G:gId CON C:cId` - 2 connections created with some group member (both for group and direct messages)
-- message `G:gId MEM [C:cId]` - connection created with all group members for a given member or current client
-- command `G:gId SEND msg` - send message to group
-- message `G:gId SENT [C:cId] msgId` - notification that the message is sent and its internal ID
-- message `G:gId MSG C:cId msgdata` - received group message from cId, msgdata is the same set of parameters as in `MSG`
-- command `G:gId ACK msgId` - acknowledge message reception by the client
-- message `G:gId RCVD [C:cId] msgId status` - message delivery notification
-- command `G:gId LEAVE` - leave the group
-- message `G:gId LEFT [C:cId]` - connection cId left the group
-- command `G:gId REM C:cId` - remove group member (response is `G:gId OK`, followed by `REMD` notification)
-- message `G:gId REMD C:cId [C:cId]` - member removed (who, by whom - if it's not the current user)
-- message `G:gId OUT C:cId` - you are removed
-- message `G:gId EMPTY` - all members left the group and it is now empty
-- command `G:gId DEL` - delete the group (response is `G:gId OK`)
-- message `G:gId DELD [C:cId]` - group deleted (by whom, if it's not the current user)
-- command `G:bId LS` - list connections in the group, response is `MS space_separated_connections`
-- message `G:bId MS space_separated_connections`
-
-## Agent message envelopes syntax (group-specific)
-
-- `GROUP C:mid G:inv gInfo` - invitation to join the group
-- `MEM C:mid` - confirmation that member connected to all members
-- `LEFT` - notification that member left the group
-- `OUT` - you are removed from the group
-- `REM C:mid` - remove member mid from the group
-- `REMD C:mid` - confirmation that member is removed
-- `DEL` - group is deleted
-- `DELD` - confirmation that group is deleted
-
-## Protocol costs
-
-- Adding a member:
-  - GROUP - `1 + connection_cost`
-  - [introductions](./2021-05-23-introduction.md) - `(5 + 2 * connection_cost) * (n - 1)`
-  - MEM - `n - 1`
-  - total - `6n - 5 + (2n - 1) * connection_cost` agent messages, where connection cost is 5 messages (2 * HELLO, 2 * MSG - confirmation, 1 * REPLY ) agent messages, so the total is `16n - 10`.
-
-- Sending a message:
-  - MSG - (n-1)
-  - RCVD - (n-1)
-  - total - `2n-2` messages
-
-- Member leaves a group:
-  - LEFT - (n-1)
-  - total -`n-1` messages
-
-- Member is removed by another member:
-  - OUT - 1
-  - REM - (n-1)
-  - REMD - (n-1)
-  - total `2n-1` messages
-
-- Group is deleted:
-  - DEL - (n-1)
-  - DELD - (n-1)
-  - total - `2n-2` messages
-
-- Group integrity verification:
-  - TODO
-
-## Questions
-
-1. Message verification keys. Agents use separate server and encryption key for each connection, but there can be a value of having the same message verification key used for all members in the group. E.g., a member can validate to other group members that the message was delivered to all group members by sending signed message receipts they receive from the agent (the second approach to group integrity verification above). This would mean that for each message `n*(n-1)` messages will be send, although signed receipts can be grouped to reduce this number. It can be done periodically, rather than on each message, as described [here](https://signal.org/blog/private-groups/).
-
-The [sequence digram for group operations](https://mermaid-js.github.io/mermaid-live-editor/#/view/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gIHBhcnRpY2lwYW50IE0gYXMgRXhpc3Rpbmc8YnI-bWVtYmVyIChNKVxuICBwYXJ0aWNpcGFudCBNQSBhcyBFeGlzdGluZzxicj5tZW1iZXI8YnI-YWdlbnQgKE1BKVxuICBwYXJ0aWNpcGFudCBBIGFzIEFsaWNlIChBKVxuICBwYXJ0aWNpcGFudCBBQSBhcyBBbGljZSdzPGJyPmFnZW50IChBQSlcbiAgcGFydGljaXBhbnQgQkEgYXMgQm9iJ3M8YnI-YWdlbnQgKEJBKVxuICBwYXJ0aWNpcGFudCBCIGFzIEJvYiAoQilcblxuICBub3RlIG92ZXIgQSwgQUE6IDEuIGNyZWF0ZSBuZXcgZ3JvdXAgKG5vIG1lbWJlcnMpXG4gIEEgLT4-IEFBOiBHOmdpZEE_IE5FVzxicj4oZ2lkQSAtIGdyb3VwIElEIG9mIHRoaXMgZ3JvdXAgZm9yIEEsPGJyPmNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIGFnZW50KVxuXG4gIG5vdGUgb3ZlciBBQTogY3JlYXRlIFwiaW50ZXJuYWxcIiBicm9hZGNhc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBncm91cDxicj4oQjogTkVXKVxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcblxuICBub3RlIG92ZXIgQSwgQkE6IDIuIGFkZCBCb2IgdG8gZ3JvdXBcblxuICBBIC0-PiBBQTogQzppZEFCIElOVFJPIEc6Z2lkQSBnSW5mbzxicj4oaWRBQiAtIGNvbm4gYWxpYXMgQSBoYXMgZm9yIEIpXG4gIFxuICBub3RlIG92ZXIgQUE6IGdlbmVyYXRlIG5ldyByYW5kb20gSUQgZm9yIG1lbWJlciBCIChtaWRCLCB1bmlxdWUgcGVyIGdyb3VwKTxicj5pbml0aWF0ZSBcImludGVybmFsXCIgY29ubmVjdGlvbiBnaWRBQiBmb3IgQiBpbiBncm91cDxicj4oaW50ZXJuYWwgbWVhbnMgdGhhdCBpdCBpcyBub3QgdmlzaWJsZSB0byB0aGUgY2xpZW50czxicj5hbmQgY2Fubm90IGJlIHVzZWQgd2l0aCBjbGllbnQgY29tbWFuZHMpXG5cbiAgQUEgLT4-IEJBOiB2aWEgaWRBQjogR1JPVVAgQzptaWRCIGc6Z0ludkFCIGdJbmZvXG4gIEJBIC0-PiBCOiBDOmlkQkEgUkVRIEc6aW52SUQgZ0luZm88YnI-KGludklEIC0gdG8gcmVmZXIgdG8gaXQgaW4gQUNQVClcbiAgQiAtPj4gQkE6IEc6Z2lkQj8gQUNQVCBHOmludklEPGJyPihSSkNUIEc6aW52SUQgY291bGQgYmUgYWRkZWQpXG5cbiAgbm90ZSBvdmVyIEJBOiBjcmVhdGUgZ3JvdXAgYW5kIFwiaW50ZXJuYWxcIiBicm9hZGNhc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBncm91cDxicj4oQjogTkVXKVxuXG4gIEJBIC0-PiBCOiBHOmdpZEIgT0tcblxuICBCQSAtPj4gQUE6IGVzdGFibGlzaCBpbnRlcm5hbCBjb25uZWN0aW9uIGdpZEJBICh1c2luZyBnOmdJbnZBQikgZm9yIEEgaW4gZ3JvdXBcblxuICBub3RlIG92ZXIgQkEsIEFBOiBhZGQgY29ubmVjdGlvbnMgZ2lkQkEgYW5kIGdpZEFCIHRvIGJyb2FkY2FzdHM8YnI-KEI6IEFERClcbiBcbiAgQUEgLT4-IEE6IEc6Z2lkQSBDT04gQzppZEFCXG4gIEJBIC0-PiBCOiBHOmdpZEEgQ09OIEM6aWRCQVxuXG4gIG5vdGUgb3ZlciBNLCBCOiBGb3IgZWFjaCBleGlzdGluZyBtZW1iZXIgTTo8YnI-Y3JlYXRlIGFuZCBhY2NlcHQgaW50ZXJuYWwgaW50cm9kdWN0aW9uIGJldHdlZW4gY29ubmVjdGlvbnMsIHJlbGF0ZWQgdG8gdGhlIGdyb3VwLCB2aWEgZ2lkQUIvQkEvQU0vTUEsIGNvbm5lY3Rpb25zIGNyZWF0ZWQgYXJlIGdpZEJNIGFuZCBnaWRNQjxicj5UaGUgZmFjdCB0aGF0IHRoZSBpbnRyb2R1Y3Rpb24gYXJyaXZlcyB2aWEgY29ubmVjdGlvbiBhbGxvY2F0ZWQgZm9yIHRoZSBncm91cCwgYWxsb3dzIGFnZW50cyBpZGVudGlmeSBpdCBhcyBhIG5ldyBncm91cCBtZW1iZXIsIElEIHVzZWQgaW4gaW50cm9kdWN0aW9ucyBpcyBncm91cC1zY29wZWQgbWVtYmVyIElELlxuXG4gIG5vdGUgb3ZlciBBLCBCQTogb25jZSBhbGwgbWVtYmVycyB3ZXJlIHNlbnQgdG8gQlxuICBBQSAtPj4gQkE6IHZpYSBnaWRBQjogTUVNIEM6bWlkQlxuXG4gIG5vdGUgb3ZlciBCQSwgQjogb25jZSBhbGwgbWVtYmVycyBhcmUgY29ubmVjdGVkXG4gIEJBIC0-PiBCOiBHOmdpZEIgTUVNXG5cbiAgbm90ZSBvdmVyIEEsIEFBOiBvbmNlIGFsbCBtZW1iZXJzIHJlcG9ydGVkIGNvbm5lY3Rpb25cbiAgQUEgLT4-IEE6IEc6Z2lkQSBNRU0gQzppZEFCXG5cbiAgbm90ZSBvdmVyIE0sIEFBOiBmb3IgZWFjaCBtZW1iZXIgTVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBNRU0gQzptaWRCXG4gIE1BIC0-PiBNOiBHOmdpZE0gTUVNIEM6aWRNQlxuICBcbiAgbm90ZSBvdmVyIE0sIEI6IDMuIEIgc2VuZHMgbWVzc2FnZSB0byB0aGUgZ3JvdXBcblxuICBCIC0-PiBCQTogRzpnaWRCIFNFTkQgbXNnXG5cbiAgbm90ZSBvdmVyIEJBOiBzZW5kIG1lc3NhZ2UgdmlhIGFzc29jaWF0ZWQgYnJvYWRjYXN0IGFuZCByZXNwb25kIHRvIGNsaWVudCB3aXRoIFNFTlQgbm90aWZpY2F0aW9uc1xuXG4gIEJBIC0-PiBCOiBHOmdpZEIgU0VOVCBDOmlkQkEgaW50TXNnSURcbiAgQkEgLT4-IEI6IEc6Z2lkQiBTRU5UIEM6aWRCTSBpbnRNc2dJRFxuICBcbiAgbm90ZSBvdmVyIEJBLCBCOiBvbmNlIHNlbnQgdG8gYWxsXG4gIEJBIC0-PiBCOiBHOmdpZEIgU0VOVCBpbnRNc2dJRFxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgTVNHIEM6aWRBQiBpbnRNc2dJRCBtc2dkYXRhXG4gIEEgLT4-IEFBOiBHOmdpZEEgQUNLIGludE1zZ0lEXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBSQ1ZEIGV4dE1zZ0lEIGhhc2ggc2lnXG4gIEJBIC0-PiBCOiBHOmdpZEEgUkNWRCBDOmlkQkEgaW50TXNnSUQgc3RhdHVzPGJyPihzdGF0dXMgLSBtZXNzYWdlIGludGVncml0eSBjaGVjaylcblxuICBNQSAtPj4gTTogRzpnaWRNIE1TRyBDOmlkTUIgaW50TXNnSUQgbXNnZGF0YVxuICBNIC0-PiBNQTogRzpnaWRNIEFDSyBpbnRNc2dJRFxuICBNQSAtPj4gQkE6IHZpYSBnaWRNQjogUkNWRCBleHRNc2dJRCBoYXNoIHNpZ1xuICBCQSAtPj4gQjogRzpnaWRNIFJDVkQgQzppZEJNIGludE1zZ0lEIHN0YXR1c1xuXG4gIG5vdGUgb3ZlciBCQSwgQjogb25jZSByZWNlaXZlZCBieSBhbGxcbiAgQkEgLT4-IEI6IEc6Z2lkTSBSQ1ZEIGludE1zZ0lEIHN0YXR1c1xuXG4gIG5vdGUgb3ZlciBNLCBCOiA0YS4gQSBsZWF2ZXMgZ3JvdXBcblxuICBBIC0-PiBBQTogRzpnaWRBIExFQVZFXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcbiAgQUEgLT4-IEJBOiB2aWEgZ2lkQUI6IExFRlRcbiAgbm90ZSBvdmVyIEFBOiByZW1vdmUgZ2lkQUIsIHJlbW92ZSBmcm9tIGJyb2FkY2FzdFxuICBub3RlIG92ZXIgQkE6IHJlbW92ZSBnaWRCQSwgcmVtb3ZlIGZyb20gYnJvYWRjYXN0XG4gIEJBIC0-PiBCOiBHOmdpZEIgTEVGVCBDOmlkQkFcblxuICBBQSAtPj4gTUE6IHZpYSBnaWRBTTogTEVGVFxuICBub3RlIG92ZXIgQUE6IHJlbW92ZSBnaWRBTSwgcmVtb3ZlIGZyb20gYnJvYWRjYXN0XG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGdpZE1BLCByZW1vdmUgZnJvbSBicm9hZGNhc3RcbiAgTUEgLT4-IE06IEc6Z2lkTSBMRUZUIEM6aWRNQVxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgTEVGVFxuXG4gIG5vdGUgb3ZlciBCLCBCQTogaWYgYWxsIG1lbWJlcnMgbGVmdFxuICBCQSAtPj4gQjogRzpnaWRCOiBFTVBUWVxuXG4gIG5vdGUgb3ZlciBNLCBCOiA0Yi4gQSByZW1vdmVzIEIgZnJvbSBncm91cFxuXG4gIEEgLT4-IEFBOiBHOmdpZEEgUkVNIEM6aWRBQlxuICBBQSAtPj4gQTogRzpnaWRBIE9LXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBPVVRcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgZ2lkQkEsIGFsbCBnaWRCTVxuICBCQSAtPj4gQjogRzpnaWRCIE9VVCBDOmlkQkFcblxuICBub3RlIG92ZXIgQUE6IHJlbW92ZSBnaWRBQlxuICBBQSAtPj4gQTogRzpnaWRBIE9LXG5cbiAgbm90ZSBvdmVyIE0sIEI6IGJlbG93IHN0ZXBzIGhhcHBlbiBmb3IgZWFjaCBleGlzdGluZyBtZW1iZXIgTVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBSRU0gQzptaWRCXG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGdpZE1CXG4gIE1BIC0-PiBBQTogdmlhIGdpZE1BOiBSRU1EIEM6bWlkQlxuICBNQSAtPj4gTTogRzpnaWRNIFJFTUQgQzppZE1CIEM6aWRNQTxicj4oQiByZW1vdmVkIGJ5IEEpXG5cbiAgbm90ZSBvdmVyIEEsIEFBOiBvbmNlIGFsbCBtZW1iZXJzIHJlbW92ZWQgQlxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgUkVNRCBDOmlkQUI8YnI-KEIgcmVtb3ZlZCBieSB0aGlzIGFnZW50KVxuXG4gIG5vdGUgb3ZlciBNLCBCOiA0Yy4gQSBkZWxldGVzIGdyb3VwXG4gIEEgLT4-IEFBOiBHOmdpZEEgREVMXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcbiAgXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBERUxcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgYWxsIGdyb3VwIGNvbm5lY3Rpb25zIGFuZCBtZXNzYWdlc1xuICBCQSAtPj4gQjogRzpnaWRCIERFTEQgQzppZEJBPGJyPihncm91cCBkZWxldGVkIGJ5IEEpXG4gIEJBIC0-PiBBQTogdmlhIGdpZEJBOiBERUxEXG4gIEFBIC0-PiBBOiBHOmdpZEEgREVMRCBDOmlkQUJcblxuICBBQSAtPj4gTUE6IHZpYSBnaWRBTTogREVMXG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGFsbCBncm91cCBjb25uZWN0aW9ucyBhbmQgbWVzc2FnZXNcbiAgTUEgLT4-IE06IEc6Z2lkTSBERUxEIEM6aWRNQTxicj4oZ3JvdXAgZGVsZXRlZCBieSBBKVxuICBNQSAtPj4gQUE6IHZpYSBnaWRNQTogREVMRFxuICBBQSAtPj4gQTogRzpnaWRBIERFTEQgQzppZEFNXG5cbiAgQUEgLT4-IEE6IEc6Z2lkQSBERUxEPGJyPihncm91cCBkZWxldGVkIGJ5IHRoaXMgYWdlbnQgLSBhbGwgY29uZmlybWVkKVxuIiwibWVybWFpZCI6e30sInVwZGF0ZUVkaXRvciI6ZmFsc2V9), the source is [here](./groups.mmd).
-
-![sequence digram for group operations](https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gIHBhcnRpY2lwYW50IE0gYXMgRXhpc3Rpbmc8YnI-bWVtYmVyIChNKVxuICBwYXJ0aWNpcGFudCBNQSBhcyBFeGlzdGluZzxicj5tZW1iZXI8YnI-YWdlbnQgKE1BKVxuICBwYXJ0aWNpcGFudCBBIGFzIEFsaWNlIChBKVxuICBwYXJ0aWNpcGFudCBBQSBhcyBBbGljZSdzPGJyPmFnZW50IChBQSlcbiAgcGFydGljaXBhbnQgQkEgYXMgQm9iJ3M8YnI-YWdlbnQgKEJBKVxuICBwYXJ0aWNpcGFudCBCIGFzIEJvYiAoQilcblxuICBub3RlIG92ZXIgQSwgQUE6IDEuIGNyZWF0ZSBuZXcgZ3JvdXAgKG5vIG1lbWJlcnMpXG4gIEEgLT4-IEFBOiBHOmdpZEE_IE5FVzxicj4oZ2lkQSAtIGdyb3VwIElEIG9mIHRoaXMgZ3JvdXAgZm9yIEEsPGJyPmNhbiBiZSBnZW5lcmF0ZWQgYnkgdGhlIGFnZW50KVxuXG4gIG5vdGUgb3ZlciBBQTogY3JlYXRlIFwiaW50ZXJuYWxcIiBicm9hZGNhc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBncm91cDxicj4oQjogTkVXKVxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcblxuICBub3RlIG92ZXIgQSwgQkE6IDIuIGFkZCBCb2IgdG8gZ3JvdXBcblxuICBBIC0-PiBBQTogQzppZEFCIElOVFJPIEc6Z2lkQSBnSW5mbzxicj4oaWRBQiAtIGNvbm4gYWxpYXMgQSBoYXMgZm9yIEIpXG4gIFxuICBub3RlIG92ZXIgQUE6IGdlbmVyYXRlIG5ldyByYW5kb20gSUQgZm9yIG1lbWJlciBCIChtaWRCLCB1bmlxdWUgcGVyIGdyb3VwKTxicj5pbml0aWF0ZSBcImludGVybmFsXCIgY29ubmVjdGlvbiBnaWRBQiBmb3IgQiBpbiBncm91cDxicj4oaW50ZXJuYWwgbWVhbnMgdGhhdCBpdCBpcyBub3QgdmlzaWJsZSB0byB0aGUgY2xpZW50czxicj5hbmQgY2Fubm90IGJlIHVzZWQgd2l0aCBjbGllbnQgY29tbWFuZHMpXG5cbiAgQUEgLT4-IEJBOiB2aWEgaWRBQjogR1JPVVAgQzptaWRCIGc6Z0ludkFCIGdJbmZvXG4gIEJBIC0-PiBCOiBDOmlkQkEgUkVRIEc6aW52SUQgZ0luZm88YnI-KGludklEIC0gdG8gcmVmZXIgdG8gaXQgaW4gQUNQVClcbiAgQiAtPj4gQkE6IEc6Z2lkQj8gQUNQVCBHOmludklEPGJyPihSSkNUIEc6aW52SUQgY291bGQgYmUgYWRkZWQpXG5cbiAgbm90ZSBvdmVyIEJBOiBjcmVhdGUgZ3JvdXAgYW5kIFwiaW50ZXJuYWxcIiBicm9hZGNhc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBncm91cDxicj4oQjogTkVXKVxuXG4gIEJBIC0-PiBCOiBHOmdpZEIgT0tcblxuICBCQSAtPj4gQUE6IGVzdGFibGlzaCBpbnRlcm5hbCBjb25uZWN0aW9uIGdpZEJBICh1c2luZyBnOmdJbnZBQikgZm9yIEEgaW4gZ3JvdXBcblxuICBub3RlIG92ZXIgQkEsIEFBOiBhZGQgY29ubmVjdGlvbnMgZ2lkQkEgYW5kIGdpZEFCIHRvIGJyb2FkY2FzdHM8YnI-KEI6IEFERClcbiBcbiAgQUEgLT4-IEE6IEc6Z2lkQSBDT04gQzppZEFCXG4gIEJBIC0-PiBCOiBHOmdpZEEgQ09OIEM6aWRCQVxuXG4gIG5vdGUgb3ZlciBNLCBCOiBGb3IgZWFjaCBleGlzdGluZyBtZW1iZXIgTTo8YnI-Y3JlYXRlIGFuZCBhY2NlcHQgaW50ZXJuYWwgaW50cm9kdWN0aW9uIGJldHdlZW4gY29ubmVjdGlvbnMsIHJlbGF0ZWQgdG8gdGhlIGdyb3VwLCB2aWEgZ2lkQUIvQkEvQU0vTUEsIGNvbm5lY3Rpb25zIGNyZWF0ZWQgYXJlIGdpZEJNIGFuZCBnaWRNQjxicj5UaGUgZmFjdCB0aGF0IHRoZSBpbnRyb2R1Y3Rpb24gYXJyaXZlcyB2aWEgY29ubmVjdGlvbiBhbGxvY2F0ZWQgZm9yIHRoZSBncm91cCwgYWxsb3dzIGFnZW50cyBpZGVudGlmeSBpdCBhcyBhIG5ldyBncm91cCBtZW1iZXIsIElEIHVzZWQgaW4gaW50cm9kdWN0aW9ucyBpcyBncm91cC1zY29wZWQgbWVtYmVyIElELlxuXG4gIG5vdGUgb3ZlciBBLCBCQTogb25jZSBhbGwgbWVtYmVycyB3ZXJlIHNlbnQgdG8gQlxuICBBQSAtPj4gQkE6IHZpYSBnaWRBQjogTUVNIEM6bWlkQlxuXG4gIG5vdGUgb3ZlciBCQSwgQjogb25jZSBhbGwgbWVtYmVycyBhcmUgY29ubmVjdGVkXG4gIEJBIC0-PiBCOiBHOmdpZEIgTUVNXG5cbiAgbm90ZSBvdmVyIEEsIEFBOiBvbmNlIGFsbCBtZW1iZXJzIHJlcG9ydGVkIGNvbm5lY3Rpb25cbiAgQUEgLT4-IEE6IEc6Z2lkQSBNRU0gQzppZEFCXG5cbiAgbm90ZSBvdmVyIE0sIEFBOiBmb3IgZWFjaCBtZW1iZXIgTVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBNRU0gQzptaWRCXG4gIE1BIC0-PiBNOiBHOmdpZE0gTUVNIEM6aWRNQlxuICBcbiAgbm90ZSBvdmVyIE0sIEI6IDMuIEIgc2VuZHMgbWVzc2FnZSB0byB0aGUgZ3JvdXBcblxuICBCIC0-PiBCQTogRzpnaWRCIFNFTkQgbXNnXG5cbiAgbm90ZSBvdmVyIEJBOiBzZW5kIG1lc3NhZ2UgdmlhIGFzc29jaWF0ZWQgYnJvYWRjYXN0IGFuZCByZXNwb25kIHRvIGNsaWVudCB3aXRoIFNFTlQgbm90aWZpY2F0aW9uc1xuXG4gIEJBIC0-PiBCOiBHOmdpZEIgU0VOVCBDOmlkQkEgaW50TXNnSURcbiAgQkEgLT4-IEI6IEc6Z2lkQiBTRU5UIEM6aWRCTSBpbnRNc2dJRFxuICBcbiAgbm90ZSBvdmVyIEJBLCBCOiBvbmNlIHNlbnQgdG8gYWxsXG4gIEJBIC0-PiBCOiBHOmdpZEIgU0VOVCBpbnRNc2dJRFxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgTVNHIEM6aWRBQiBpbnRNc2dJRCBtc2dkYXRhXG4gIEEgLT4-IEFBOiBHOmdpZEEgQUNLIGludE1zZ0lEXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBSQ1ZEIGV4dE1zZ0lEIGhhc2ggc2lnXG4gIEJBIC0-PiBCOiBHOmdpZEEgUkNWRCBDOmlkQkEgaW50TXNnSUQgc3RhdHVzPGJyPihzdGF0dXMgLSBtZXNzYWdlIGludGVncml0eSBjaGVjaylcblxuICBNQSAtPj4gTTogRzpnaWRNIE1TRyBDOmlkTUIgaW50TXNnSUQgbXNnZGF0YVxuICBNIC0-PiBNQTogRzpnaWRNIEFDSyBpbnRNc2dJRFxuICBNQSAtPj4gQkE6IHZpYSBnaWRNQjogUkNWRCBleHRNc2dJRCBoYXNoIHNpZ1xuICBCQSAtPj4gQjogRzpnaWRNIFJDVkQgQzppZEJNIGludE1zZ0lEIHN0YXR1c1xuXG4gIG5vdGUgb3ZlciBCQSwgQjogb25jZSByZWNlaXZlZCBieSBhbGxcbiAgQkEgLT4-IEI6IEc6Z2lkTSBSQ1ZEIGludE1zZ0lEIHN0YXR1c1xuXG4gIG5vdGUgb3ZlciBNLCBCOiA0YS4gQSBsZWF2ZXMgZ3JvdXBcblxuICBBIC0-PiBBQTogRzpnaWRBIExFQVZFXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcbiAgQUEgLT4-IEJBOiB2aWEgZ2lkQUI6IExFRlRcbiAgbm90ZSBvdmVyIEFBOiByZW1vdmUgZ2lkQUIsIHJlbW92ZSBmcm9tIGJyb2FkY2FzdFxuICBub3RlIG92ZXIgQkE6IHJlbW92ZSBnaWRCQSwgcmVtb3ZlIGZyb20gYnJvYWRjYXN0XG4gIEJBIC0-PiBCOiBHOmdpZEIgTEVGVCBDOmlkQkFcblxuICBBQSAtPj4gTUE6IHZpYSBnaWRBTTogTEVGVFxuICBub3RlIG92ZXIgQUE6IHJlbW92ZSBnaWRBTSwgcmVtb3ZlIGZyb20gYnJvYWRjYXN0XG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGdpZE1BLCByZW1vdmUgZnJvbSBicm9hZGNhc3RcbiAgTUEgLT4-IE06IEc6Z2lkTSBMRUZUIEM6aWRNQVxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgTEVGVFxuXG4gIG5vdGUgb3ZlciBCLCBCQTogaWYgYWxsIG1lbWJlcnMgbGVmdFxuICBCQSAtPj4gQjogRzpnaWRCOiBFTVBUWVxuXG4gIG5vdGUgb3ZlciBNLCBCOiA0Yi4gQSByZW1vdmVzIEIgZnJvbSBncm91cFxuXG4gIEEgLT4-IEFBOiBHOmdpZEEgUkVNIEM6aWRBQlxuICBBQSAtPj4gQTogRzpnaWRBIE9LXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBPVVRcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgZ2lkQkEsIGFsbCBnaWRCTVxuICBCQSAtPj4gQjogRzpnaWRCIE9VVCBDOmlkQkFcblxuICBub3RlIG92ZXIgQUE6IHJlbW92ZSBnaWRBQlxuICBBQSAtPj4gQTogRzpnaWRBIE9LXG5cbiAgbm90ZSBvdmVyIE0sIEI6IGJlbG93IHN0ZXBzIGhhcHBlbiBmb3IgZWFjaCBleGlzdGluZyBtZW1iZXIgTVxuXG4gIEFBIC0-PiBNQTogdmlhIGdpZEFNOiBSRU0gQzptaWRCXG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGdpZE1CXG4gIE1BIC0-PiBBQTogdmlhIGdpZE1BOiBSRU1EIEM6bWlkQlxuICBNQSAtPj4gTTogRzpnaWRNIFJFTUQgQzppZE1CIEM6aWRNQTxicj4oQiByZW1vdmVkIGJ5IEEpXG5cbiAgbm90ZSBvdmVyIEEsIEFBOiBvbmNlIGFsbCBtZW1iZXJzIHJlbW92ZWQgQlxuXG4gIEFBIC0-PiBBOiBHOmdpZEEgUkVNRCBDOmlkQUI8YnI-KEIgcmVtb3ZlZCBieSB0aGlzIGFnZW50KVxuXG4gIG5vdGUgb3ZlciBNLCBCOiA0Yy4gQSBkZWxldGVzIGdyb3VwXG4gIEEgLT4-IEFBOiBHOmdpZEEgREVMXG4gIEFBIC0-PiBBOiBHOmdpZEEgT0tcbiAgXG4gIEFBIC0-PiBCQTogdmlhIGdpZEFCOiBERUxcbiAgbm90ZSBvdmVyIEJBOiByZW1vdmUgYWxsIGdyb3VwIGNvbm5lY3Rpb25zIGFuZCBtZXNzYWdlc1xuICBCQSAtPj4gQjogRzpnaWRCIERFTEQgQzppZEJBPGJyPihncm91cCBkZWxldGVkIGJ5IEEpXG4gIEJBIC0-PiBBQTogdmlhIGdpZEJBOiBERUxEXG4gIEFBIC0-PiBBOiBHOmdpZEEgREVMRCBDOmlkQUJcblxuICBBQSAtPj4gTUE6IHZpYSBnaWRBTTogREVMXG4gIG5vdGUgb3ZlciBNQTogcmVtb3ZlIGFsbCBncm91cCBjb25uZWN0aW9ucyBhbmQgbWVzc2FnZXNcbiAgTUEgLT4-IE06IEc6Z2lkTSBERUxEIEM6aWRNQTxicj4oZ3JvdXAgZGVsZXRlZCBieSBBKVxuICBNQSAtPj4gQUE6IHZpYSBnaWRNQTogREVMRFxuICBBQSAtPj4gQTogRzpnaWRBIERFTEQgQzppZEFNXG5cbiAgQUEgLT4-IEE6IEc6Z2lkQSBERUxEPGJyPihncm91cCBkZWxldGVkIGJ5IHRoaXMgYWdlbnQgLSBhbGwgY29uZmlybWVkKVxuIiwibWVybWFpZCI6e30sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)
-
-## Relevant external documents
-
-[Signal group protocol](https://signal.org/blog/private-groups/)
-
-[mpOTR](https://cypherpunks.ca/~iang/pubs/mpotr.pdf)
-
-[Threema whitepaper](https://threema.ch/press-files/cryptography_whitepaper.pdf)
diff --git a/source/rfcs/rejected/2021-05-23-introduction.md b/source/rfcs/rejected/2021-05-23-introduction.md
deleted file mode 100644
index 6212fcf..0000000
--- a/source/rfcs/rejected/2021-05-23-introduction.md
+++ /dev/null
@@ -1,41 +0,0 @@
-# SMP agent introduction
-
-## Problem
-
-Allow an agent client to connect two connections it has directly, with the agent acting as an out-of-band channel.
-
-It can be used both separately as part of some client functionality, and as part of group protocol.
-
-## Solution
-
-A protocol with commands and message envelopes to exchange the information between parties to establish connection.
-
-### Commands and messages
-
-Below commands are for the scenario when A introduces B to M.
-
-- command `C:idAB INTRO C:idAM infoM` - initiate introduction of the connection cIdB to connection cIdM (response is `C:idAB OK`)
-- message `C:idBA REQ C:invId infoM` - notification to confirm introduction
-- command `C:idBM? ACPT C:invId` - accept offer to be introduced (response is `C:idBM OK`, followed by `C:idBM CON`)
-- message `C:idBM CON` - confirmation that connection is established to both introduced parties
-- message `C:idAB CON C:idAM` - confirmation that connection is established to the introducer
-
-### Agent envelopes
-
-- `INTRO C:extIntroIdM infoM` - new introduction offered by introducer
-- `INV C:extIntroIdB prv:invBM infoB` - invitation to join connection from B to M sent via A
-- `REQ C:extIntroIdB prv:invBM infoB` - new introduction forwarded by the introducer
-- `CON C:extIntroId` - confirmation that the connection is established sent by both introduced parties to the introducer
-
-## Namespace
-
-Given that the introduction objects are short lived, they should not reuse the same commands or share the same namespace as connections, broadcasts and groups, but they probably should share the namespace with group and connection invitations.
-
-## Introduction protocol costs
-
-5 messages + cost to establish a connection
-
-
-The [sequence digram for introduction](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gIHBhcnRpY2lwYW50IEEgYXMgQWxpY2UgKEEpIC0gdGhlIGludHJvZHVjZXJcbiAgcGFydGljaXBhbnQgQUEgYXMgQWxpY2Unczxicj5hZ2VudCAoQUEpXG4gIHBhcnRpY2lwYW50IEIgYXMgQm9iIChCKSAtIGludHJvZHVjZWRcbiAgcGFydGljaXBhbnQgQkEgYXMgQm9iJ3M8YnI-YWdlbnQgKEJBKVxuICBwYXJ0aWNpcGFudCBNIGFzIE1hcmsgKE0pIC0gaW50cm9kdWNlZCB0b1xuICBwYXJ0aWNpcGFudCBNQSBhcyBNYXJrJ3M8YnI-YWdlbnQgKE1BKVxuXG4gIG5vdGUgb3ZlciBBLCBBQTogMS4gY3JlYXRlIGludHJvZHVjdGlvblxuICBBIC0-PiBBQTogQzppZEFCIElOVFJPIEM6aWRBTSBpbmZvTTxicj4oaWRBQiAtIGNvbm4gYWxpYXMgQSBoYXMgZm9yIEIsPGJyPmlkQU0gLSBmb3IgTSlcbiAgQUEgLT4-IEE6IEM6aWRBQiBPS1xuXG4gIG5vdGUgb3ZlciBBLCBCQTogMi4gc2VuZCBpbnRybyB0byBCb2JcblxuICBBQSAtPj4gQkE6IHZpYSBpZEFCOiBJTlRSTyBDOmV4dEludHJvSWRNIGluZm9NXG4gIEJBIC0-PiBCOiBDOmlkQkEgUkVRIEM6aW50SW50cm9JZE0gaW5mb01cbiAgQiAtPj4gQkE6IEM6aWRCTT8gQUNQVCBDOmludEludHJvSWRNXG4gIEJBIC0-PiBCOiBDOmlkQk0gT0tcblxuICBub3RlIG92ZXIgQkE6IDMuIGNyZWF0ZSBjb25uZWN0aW9uIGZvciAgTSBpZEJNXG5cbiAgQkEgLT4-IEFBOiB2aWEgaWRCQTogSU5WIEM6ZXh0SW50cm9JZE0gcHJ2OmludkJNIGluZm9CXG5cbiAgbm90ZSBvdmVyIEFBLCBNOiA0LiBzZW5kIGludHJvIHRvIE1hcmtcblxuICBBQSAtPj4gTUE6IHZpYSBpZEFNOiBSRVEgQzpleHRJbnRyb0lkQiBwcnY6aW52Qk0gaW5mb0JcblxuICBub3RlIG92ZXIgTUEsIEI6IDUuIE1hcmsgY29ubmVjdHMgdG8gQm9iXG5cbiAgTUEgLT4-IE06IEM6aWRNQSBSRVEgQzppbnRJbnRyb0lkQiBpbmZvQlxuICBNIC0-PiBNQTogQzppZE1CPyBBQ1BUIEM6aW50SW50cm9JZEJcbiAgTUEgLT4-IE06IEM6aWRNQiBPS1xuXG4gIE1BIC0-PiBCQTogIGVzdGFibGlzaCBjb25uZWN0aW9uIGlkQk0gLT4gaWRNQlxuXG4gIG5vdGUgb3ZlciBBLCBNQTogNi4gbm90aWZ5IGFsbCBjbGllbnRzXG5cbiAgTUEgLT4-IE06IEM6aWRNQiBDT05cbiAgTUEgLT4-IEFBOiB2aWEgaWRNQTogQ09OIEM6ZXh0SW50cm9JZEJcbiAgQkEgLT4-IEI6IEM6aWRCTSBDT05cbiAgQkEgLT4-IEFBOiB2aWEgaWRCQTogQ09OIEM6ZXh0SW50cm9JZEJcbiAgQUEgLT4-IEE6IEM6aWRBQiBDT04gQzppZEFNXG4iLCJtZXJtYWlkIjp7fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0), the source is [here](./intro.mmd).
-
-![sequence digram for introduction](https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gIHBhcnRpY2lwYW50IEEgYXMgQWxpY2UgKEEpIC0gdGhlIGludHJvZHVjZXJcbiAgcGFydGljaXBhbnQgQUEgYXMgQWxpY2Unczxicj5hZ2VudCAoQUEpXG4gIHBhcnRpY2lwYW50IEIgYXMgQm9iIChCKSAtIGludHJvZHVjZWRcbiAgcGFydGljaXBhbnQgQkEgYXMgQm9iJ3M8YnI-YWdlbnQgKEJBKVxuICBwYXJ0aWNpcGFudCBNIGFzIE1hcmsgKE0pIC0gaW50cm9kdWNlZCB0b1xuICBwYXJ0aWNpcGFudCBNQSBhcyBNYXJrJ3M8YnI-YWdlbnQgKE1BKVxuXG4gIG5vdGUgb3ZlciBBLCBBQTogMS4gY3JlYXRlIGludHJvZHVjdGlvblxuICBBIC0-PiBBQTogQzppZEFCIElOVFJPIEM6aWRBTSBpbmZvTTxicj4oaWRBQiAtIGNvbm4gYWxpYXMgQSBoYXMgZm9yIEIsPGJyPmlkQU0gLSBmb3IgTSlcbiAgQUEgLT4-IEE6IEM6aWRBQiBPS1xuXG4gIG5vdGUgb3ZlciBBLCBCQTogMi4gc2VuZCBpbnRybyB0byBCb2JcblxuICBBQSAtPj4gQkE6IHZpYSBpZEFCOiBJTlRSTyBDOmV4dEludHJvSWRNIGluZm9NXG4gIEJBIC0-PiBCOiBDOmlkQkEgUkVRIEM6aW50SW50cm9JZE0gaW5mb01cbiAgQiAtPj4gQkE6IEM6aWRCTT8gQUNQVCBDOmludEludHJvSWRNXG4gIEJBIC0-PiBCOiBDOmlkQk0gT0tcblxuICBub3RlIG92ZXIgQkE6IDMuIGNyZWF0ZSBjb25uZWN0aW9uIGZvciAgTSBpZEJNXG5cbiAgQkEgLT4-IEFBOiB2aWEgaWRCQTogSU5WIEM6ZXh0SW50cm9JZE0gcHJ2OmludkJNIGluZm9CXG5cbiAgbm90ZSBvdmVyIEFBLCBNOiA0LiBzZW5kIGludHJvIHRvIE1hcmtcblxuICBBQSAtPj4gTUE6IHZpYSBpZEFNOiBSRVEgQzpleHRJbnRyb0lkQiBwcnY6aW52Qk0gaW5mb0JcblxuICBub3RlIG92ZXIgTUEsIEI6IDUuIE1hcmsgY29ubmVjdHMgdG8gQm9iXG5cbiAgTUEgLT4-IE06IEM6aWRNQSBSRVEgQzppbnRJbnRyb0lkQiBpbmZvQlxuICBNIC0-PiBNQTogQzppZE1CPyBBQ1BUIEM6aW50SW50cm9JZEJcbiAgTUEgLT4-IE06IEM6aWRNQiBPS1xuXG4gIE1BIC0-PiBCQTogIGVzdGFibGlzaCBjb25uZWN0aW9uIGlkQk0gLT4gaWRNQlxuXG4gIG5vdGUgb3ZlciBBLCBNQTogNi4gbm90aWZ5IGFsbCBjbGllbnRzXG5cbiAgTUEgLT4-IE06IEM6aWRNQiBDT05cbiAgTUEgLT4-IEFBOiB2aWEgaWRNQTogQ09OIEM6ZXh0SW50cm9JZEJcbiAgQkEgLT4-IEI6IEM6aWRCTSBDT05cbiAgQkEgLT4-IEFBOiB2aWEgaWRCQTogQ09OIEM6ZXh0SW50cm9JZEJcbiAgQUEgLT4-IEE6IEM6aWRBQiBDT04gQzppZEFNXG4iLCJtZXJtYWlkIjp7fSwidXBkYXRlRWRpdG9yIjpmYWxzZX0)
diff --git a/source/rfcs/rejected/groups.mmd b/source/rfcs/rejected/groups.mmd
deleted file mode 100644
index c9151c0..0000000
--- a/source/rfcs/rejected/groups.mmd
+++ /dev/null
@@ -1,135 +0,0 @@
-sequenceDiagram
-  participant M as Existing<br>member (M)
-  participant MA as Existing<br>member<br>agent (MA)
-  participant A as Alice (A)
-  participant AA as Alice's<br>agent (AA)
-  participant BA as Bob's<br>agent (BA)
-  participant B as Bob (B)
-
-  note over A, AA: 1. create new group (no members)
-  A ->> AA: G:gidA? NEW<br>(gidA - group ID of this group for A,<br>can be generated by the agent)
-
-  note over AA: create "internal" broadcast associated with the group<br>(B: NEW)
-
-  AA ->> A: G:gidA OK
-
-  note over A, BA: 2. add Bob to group
-
-  A ->> AA: C:idAB INTRO G:gidA gInfo<br>(idAB - conn alias A has for B)
-  
-  note over AA: generate new random ID for member B (midB, unique per group)<br>initiate "internal" connection gidAB for B in group<br>(internal means that it is not visible to the clients<br>and cannot be used with client commands)
-
-  AA ->> BA: via idAB: GROUP C:midB g:gInvAB gInfo
-  BA ->> B: C:idBA REQ G:invID gInfo<br>(invID - to refer to it in ACPT)
-  B ->> BA: G:gidB? ACPT G:invID<br>(RJCT G:invID could be added)
-
-  note over BA: create group and "internal" broadcast associated with the group<br>(B: NEW)
-
-  BA ->> B: G:gidB OK
-
-  BA ->> AA: establish internal connection gidBA (using g:gInvAB) for A in group
-
-  note over BA, AA: add connections gidBA and gidAB to broadcasts<br>(B: ADD)
- 
-  AA ->> A: G:gidA CON C:idAB
-  BA ->> B: G:gidA CON C:idBA
-
-  note over M, B: For each existing member M:<br>create and accept internal introduction between connections, related to the group, via gidAB/BA/AM/MA, connections created are gidBM and gidMB<br>The fact that the introduction arrives via connection allocated for the group, allows agents identify it as a new group member, ID used in introductions is group-scoped member ID.
-
-  note over A, BA: once all members were sent to B
-  AA ->> BA: via gidAB: MEM C:midB
-
-  note over BA, B: once all members are connected
-  BA ->> B: G:gidB MEM
-
-  note over A, AA: once all members reported connection
-  AA ->> A: G:gidA MEM C:idAB
-
-  note over M, AA: for each member M
-
-  AA ->> MA: via gidAM: MEM C:midB
-  MA ->> M: G:gidM MEM C:idMB
-  
-  note over M, B: 3. B sends message to the group
-
-  B ->> BA: G:gidB SEND msg
-
-  note over BA: send message via associated broadcast and respond to client with SENT notifications
-
-  BA ->> B: G:gidB SENT C:idBA intMsgID
-  BA ->> B: G:gidB SENT C:idBM intMsgID
-  
-  note over BA, B: once sent to all
-  BA ->> B: G:gidB SENT intMsgID
-
-  AA ->> A: G:gidA MSG C:idAB intMsgID msgdata
-  A ->> AA: G:gidA ACK intMsgID
-  AA ->> BA: via gidAB: RCVD extMsgID hash sig
-  BA ->> B: G:gidA RCVD C:idBA intMsgID status<br>(status - message integrity check)
-
-  MA ->> M: G:gidM MSG C:idMB intMsgID msgdata
-  M ->> MA: G:gidM ACK intMsgID
-  MA ->> BA: via gidMB: RCVD extMsgID hash sig
-  BA ->> B: G:gidM RCVD C:idBM intMsgID status
-
-  note over BA, B: once received by all
-  BA ->> B: G:gidM RCVD intMsgID status
-
-  note over M, B: 4a. A leaves group
-
-  A ->> AA: G:gidA LEAVE
-  AA ->> A: G:gidA OK
-  AA ->> BA: via gidAB: LEFT
-  note over AA: remove gidAB, remove from broadcast
-  note over BA: remove gidBA, remove from broadcast
-  BA ->> B: G:gidB LEFT C:idBA
-
-  AA ->> MA: via gidAM: LEFT
-  note over AA: remove gidAM, remove from broadcast
-  note over MA: remove gidMA, remove from broadcast
-  MA ->> M: G:gidM LEFT C:idMA
-
-  AA ->> A: G:gidA LEFT
-
-  note over B, BA: if all members left
-  BA ->> B: G:gidB: EMPTY
-
-  note over M, B: 4b. A removes B from group
-
-  A ->> AA: G:gidA REM C:idAB
-  AA ->> A: G:gidA OK
-  AA ->> BA: via gidAB: OUT
-  note over BA: remove gidBA, all gidBM
-  BA ->> B: G:gidB OUT C:idBA
-
-  note over AA: remove gidAB
-  AA ->> A: G:gidA OK
-
-  note over M, B: below steps happen for each existing member M
-
-  AA ->> MA: via gidAM: REM C:midB
-  note over MA: remove gidMB
-  MA ->> AA: via gidMA: REMD C:midB
-  MA ->> M: G:gidM REMD C:idMB C:idMA<br>(B removed by A)
-
-  note over A, AA: once all members removed B
-
-  AA ->> A: G:gidA REMD C:idAB<br>(B removed by this agent)
-
-  note over M, B: 4c. A deletes group
-  A ->> AA: G:gidA DEL
-  AA ->> A: G:gidA OK
-  
-  AA ->> BA: via gidAB: DEL
-  note over BA: remove all group connections and messages
-  BA ->> B: G:gidB DELD C:idBA<br>(group deleted by A)
-  BA ->> AA: via gidBA: DELD
-  AA ->> A: G:gidA DELD C:idAB
-
-  AA ->> MA: via gidAM: DEL
-  note over MA: remove all group connections and messages
-  MA ->> M: G:gidM DELD C:idMA<br>(group deleted by A)
-  MA ->> AA: via gidMA: DELD
-  AA ->> A: G:gidA DELD C:idAM
-
-  AA ->> A: G:gidA DELD<br>(group deleted by this agent - all confirmed)
diff --git a/source/rfcs/rejected/intro.mmd b/source/rfcs/rejected/intro.mmd
deleted file mode 100644
index 3c7c7e0..0000000
--- a/source/rfcs/rejected/intro.mmd
+++ /dev/null
@@ -1,42 +0,0 @@
-sequenceDiagram
-  participant A as Alice (A) - the introducer
-  participant AA as Alice's<br>agent (AA)
-  participant B as Bob (B) - introduced
-  participant BA as Bob's<br>agent (BA)
-  participant M as Mark (M) - introduced to
-  participant MA as Mark's<br>agent (MA)
-
-  note over A, AA: 1. create introduction
-  A ->> AA: C:idAB INTRO C:idAM infoM<br>(idAB - conn alias A has for B,<br>idAM - for M)
-  AA ->> A: C:idAB OK
-
-  note over A, BA: 2. send intro to Bob
-
-  AA ->> BA: via idAB: INTRO C:extIntroIdM infoM
-  BA ->> B: C:idBA REQ C:intIntroIdM infoM
-  B ->> BA: C:idBM? ACPT C:intIntroIdM
-  BA ->> B: C:idBM OK
-
-  note over BA: 3. create connection for  M idBM
-
-  BA ->> AA: via idBA: INV C:extIntroIdM invBM infoB
-
-  note over AA, M: 4. send intro to Mark
-
-  AA ->> MA: via idAM: REQ C:extIntroIdB invBM infoB
-
-  note over MA, B: 5. Mark connects to Bob
-
-  MA ->> M: C:idMA REQ C:intIntroIdB infoB
-  M ->> MA: C:idMB? ACPT C:intIntroIdB
-  MA ->> M: C:idMB OK
-
-  MA ->> BA:  establish connection idBM -> idMB
-
-  note over A, MA: 6. notify all clients
-
-  MA ->> M: C:idMB CON
-  MA ->> AA: via idMA: CON C:extIntroIdB
-  BA ->> B: C:idBM CON
-  BA ->> AA: via idBA: CON C:extIntroIdB
-  AA ->> A: C:idAB CON C:idAM
diff --git a/source/rfcs/rejected/protocol_overview.md b/source/rfcs/rejected/protocol_overview.md
deleted file mode 100644
index 1ff6ff4..0000000
--- a/source/rfcs/rejected/protocol_overview.md
+++ /dev/null
@@ -1,146 +0,0 @@
-# Overview of SMP agent protocol commands
-
-## Connections
-
-### Commands and messages
-
-A initiates connection, B accepts
-
-- command `C:idB? NEW` - create connection
-- message `C:idB INV cInv`
-- command `C:idA? JOIN cInv replyMode` - join connection (response `OK`, followed by `CON`)
-- *message* `C:idB REQ prv:invId infoB` - request from B joining sent to A (not implemented)
-- *command* `C:idB ACPT prv:invId` - A confirms B joining (not implemented)
-- message `C:id CON` - connection is established
-- command `C:id SUB` - subscribe to connection
-- message `C:id END` - unsubscribed from connection
-- command `C:idB SEND msg` - send message
-- message `C:idA SENT msgId` - confirmation that the message is sent
-- message `C:id MSG msgId msgMeta msgIntegrity msgBody` - received message
-- *command* `C:idB ACK msgId` - acknowledge message reception (not implemented)
-- *message* `C:idA RCVD msgId msgIntegrity` - confirmation of message reception and integrity (not implemented)
-- command `C:id OFF` - suspend connection
-- command `C:id DEL` - delete connection
-- message `C:id? OK` - command confirmation
-- message `C:id? ERR e` - error
-
-### Envelopes
-
-- `MSG `
-- `HELLO verificationKey ackMode`
-- `REPLY replyInv`
-
-## Broadcasts
-
-### Commands & messages
-
-- command `B:id? NEW` - create broadcast (response is `B:id OK`)
-- command `B:id SEND msg` - broadcast message (response is multiple `C:id SENT msgId` or ERR, separately for each connection, followed by `B:id SENT msgId` once sent to all)
-- message `B:id SENT msgId` - notification that the message is sent and its internal ID, same as SENT
-- command `B:id ADD cId` - add existing connection to a broadcast (response is `B:id OK` or `ERR`, e.g. if bId is used)
-- command `B:id REM cId` - remove connection from the broadcast (response is `REMD`)
-- message `B:id REMD cId` - connection removed from the broadcast
-- message `B:id EMPTY` - all connections were removed from the broadcast
-- command `B:id DEL` - delete broadcast (response is `B:id OK`)
-- command `B:id LS` - list connections in broadcast, response is `B:id MEM space_separated_connections`
-- message `B:id MEM space_separated_connections`
-
-## Open/public connection
-
-### Commands
-
-- command `O:id? NEW` - create open connection
-- message `O:id INV oInv` - open invitation
-- command `C:id? JOIN oInv replyMode` - join connection (response `OK`, followed by `CON`)
-- message `O:id REQ open:invId infoB` - confirmation from B joining sent to A
-- command `C:idC? ACPT open:invId` - note, that it creates new connection, keeping OPEN connection
-- command `O:id SUB` - subscribe to open connection
-- message `O:id END` - unsubscribed from open connection
-- command `O:id OFF` - suspend open connection
-- command `O:id DEL` - delete open connection
-- message `O:id? OK` - command confirmation
-- message `O:id? ERR e` - error
-
-## Introductions
-
-### Commands
-
-- command `C:idAB INTRO C:idAM infoM` - introduce connection cIdB to connection cIdM (response is `OK`)
-- message `C:idBA REQ C:invId infoM` - notification to confirm introduction
-- command `C:idBM? ACPT C:invId` - accept offer to be introduced (response is `cIdBM OK`, followed by `ICON`)
-- message `C:idBM CON` - confirmation that connection is established to both introduced parties
-- message `C:idAB CON C:idAM` - confirmation that connection is established to the introducer
-
-### Envelopes
-
-- `INTRO C:extIntroIdM infoM` - new introduction offered by introducer
-- `INV C:extIntroIdB prv:invBM infoB` - invitation to join connection from B to M sent via A (can be pub:)
-- `REQ C:extIntroIdB prv:invBM infoB` - new introduction forwarded by introducer
-- `CON C:extIntroIdM` - confirmation that the connection is established sent by both introduced parties to the introducer
-
-## Groups
-
-## Agent commands and messages syntax
-
-- command `G:gId? NEW` - create group (response is `G:gId OK`)
-- command `C:cId INTRO G:gId gInfo` - add existing connection to a group
-- message `C:cId REQ g:invID gInfo` - invitation to join the group
-- command `G:gId? ACPT g:invId` - accept invitation (response is `G gId OK`)
-- message `G:gId CON C:cId` - 2 connections created with some group member (both for group and direct messages)
-- message `G:gId MEM [C:cId]` - connection created with all group members for a given member or current client
-- command `G:gId SEND msg` - send message to group
-- message `G:gId SENT msgId` - notification that the message is sent and its internal ID, same as SENT
-- message `G:gId MSG C:cId msgId msgdata` - received group message from cId, msgdata is the same set of parameters as in `MSG`
-- command `G:gId ACK msgId` - acknowledge message reception by the client
-- message `G:gId RCVD t:cId msgId status` - message delivery notification
-- command `G:gId LEAVE` - leave the group
-- message `G:gId LEFT [C:cId]` - connection cId left the group
-- command `G:gId REM C:cId` - remove group member (response is `gId OK`, followed by `GREMD` notification)
-- message `G:gId REMD C:cId [C:cId]` - member removed
-- message `G:gId OUT C:cId` - you are removed (see question below - should it be just a sequence of GLEFT?)
-- message `G:gId EMPTY` - all members left the group and it is now empty
-- command `G:gId DEL` - delete the group (response is `gId OK`)
-- message `G:gId DELD [C:cId]` - group deleted
-
-## Agent message envelopes syntax
-
-- `GROUP C:mid G:inv gInfo` - invitation to join the group
-- `MEM C:mid` - confirmation that member connected to all members
-- `LEFT` - notification that member left the group
-- `OUT` - you are removed from the group
-- `REM C:mid` - remove member mid from the group
-- `REMD C:mid` - confirmation that member is removed
-- `DEL` - group is deleted
-- `DELD` - confirmation that group is deleted
-
-## Commands and objects
-
-| Dir     | Command / message    | (C)onnection | (O)pen connection | (B)roadcast | (G)roup |
-|:---------:|:--------------------:|:------------:|:-----------------:|:-----------:|:-------:|
-| command | `t:id? NEW`           | ‚úì | ‚úì | ‚úì | ‚úì |
-| command | `C:id INTRO t:id info` | ‚úì | - | - | ‚úì |
-| message | `t:id INV inv`        | ‚úì | ‚úì | - | - |
-| command | `C:id? JOIN inv replyMode info` | ‚úì | - | - | - |
-| message | `t:id REQ invId info` | ‚úì | ‚úì | - | ‚úì |
-| command | `t:id? ACPT invId`    | ‚úì | - | - | ‚úì |
-| message | `t:id CON [C:id]`     | ‚úì | - | - | ‚úì |
-| message | `t:id MEM [C:id]`     | - | - | - | ‚úì |
-| command | `t:id SUB`            | ‚úì | ‚úì | - | ‚úì |
-| message | `t:id END`            | ‚úì | ‚úì | - | ‚úì |
-| command | `t:id OFF`            | ‚úì | ‚úì | - | - |
-| command | `t:id DEL`            | ‚úì | ‚úì | ‚úì | ‚úì |
-| message | `t:id DELD [C:Id]`    | ‚úì | ‚úì | ‚úì | ‚úì |
-| command | `t:id SEND msg`       | ‚úì | - | ‚úì | ‚úì |
-| message | `t:id SENT [t':id] msgId` | ‚úì | - | ‚úì | ‚úì |
-| message | `t:id MSG [C:id] msgId msgdata` | ‚úì | - | - | ‚úì |
-| command | `t:id ACK msgId`      | ‚úì | - | - | ‚úì |
-| message | `t:id RCVD [t':id] msgId status` | ‚úì | - | - | ‚úì |
-| command | `t:id ADD C:id`       | - | - | - | ‚úì |
-| command | `t:id REM C:id`       | - | - | ‚úì | ‚úì |
-| command | `t:id REMD C:id`      | - | - | ‚úì | ‚úì |
-| message | `t:id EMPTY`          | - | - | ‚úì | ‚úì |
-| message | `G:id OUT C:id`       | - | - | - | ‚úì |
-| command | `t:id LS`             | - | - | ‚úì | ‚úì |
-| message | `t:id MS cIds`        | - | - | ‚úì | ‚úì |
-| command | `G:id LEAVE`          | - | - | - | ‚úì |
-| message | `G:id LEFT [C:id]`    | - | - | - | ‚úì |
diff --git a/source/scripts/docker/entrypoint b/source/scripts/docker/entrypoint
deleted file mode 100755
index a761f33..0000000
--- a/source/scripts/docker/entrypoint
+++ /dev/null
@@ -1,23 +0,0 @@
-#!/usr/bin/env sh
-confd="/etc/opt/simplex"
-logd="/var/opt/simplex/"
-
-# Check if server has been initialized
-if [ ! -f "$confd/smp-server.ini" ]; then
-	# If not, determine ip or domain
-	case $addr in
-		'') printf "Please specify \$addr environment variable.\n"; exit 1 ;;
-		*[a-zA-Z]*) smp-server init -y -l -n "$addr" ;;
-		*) smp-server init -y -l --ip "$addr" ;;
-	esac
-
-fi
-
-# backup store log
-[ -f "$logd/smp-server-store.log" ] && cp "$logd"/smp-server-store.log "$logd"/smp-server-store.log.bak
-# rotate server log
-[ -f "$logd/smp-server.log" ] && mv "$logd"/smp-server.log "$logd"/smp-server-"$(date +'%FT%T')".log
-
-# Finally, run smp-sever. Notice that "exec" here is important:
-# smp-server replaces our helper script, so that it can catch INT signal
-exec smp-server start > "$logd"/smp-server.log 2>&1
diff --git a/source/scripts/ntf-server-linode.sh b/source/scripts/ntf-server-linode.sh
deleted file mode 100644
index e682c21..0000000
--- a/source/scripts/ntf-server-linode.sh
+++ /dev/null
@@ -1,178 +0,0 @@
-#!/bin/bash
-
-# <UDF name="enable_store_log" label="Store log - persist notification subscriptions to append only log and restore them upon server restart." default="on" oneof="on, off" />
-# <UDF name="api_token" label="Linode API token - enable Linode to create tags with server address, fingerprint and version. Note: minimal permissions token should have are read/write access to `linodes` (to create tags) and `domains` (to add A record for the third level domain if FQDN is provided)." default="" />
-# <UDF name="fqdn" label="FQDN (Fully Qualified Domain Name) - provide third level domain name (e.g. ntf.example.com). If provided use `ntf://fingerprint@FQDN` as server address in the client. If FQDN is not provided use `ntf://fingerprint@IP` instead." default="" />
-# <UDF name="apns_key_id" label="APNS key ID." default="" />
-
-# Log all stdout output to stackscript.log
-exec &> >(tee -i /var/log/stackscript.log)
-
-# Uncomment next line to enable debugging features
-# set -xeo pipefail
-
-cd $HOME
-
-# https://superuser.com/questions/1638779/automatic-yess-to-linux-update-upgrade
-# https://superuser.com/questions/1412054/non-interactive-apt-upgrade
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  update
-
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  dist-upgrade
-
-# TODO install unattended-upgrades
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  install jq
-
-# Add firewall
-echo "y" | ufw enable
-
-# Open ports
-ufw allow ssh
-ufw allow https
-ufw allow 5223
-
-# Increase file descriptors limit
-echo 'fs.file-max = 1000000' >> /etc/sysctl.conf
-echo 'fs.inode-max = 1000000' >> /etc/sysctl.conf
-echo 'root soft nofile unlimited' >> /etc/security/limits.conf
-echo 'root hard nofile unlimited' >> /etc/security/limits.conf
-
-# Download latest release
-bin_dir="/opt/simplex-notifications/bin"
-binary="$bin_dir/ntf-server"
-mkdir -p $bin_dir
-curl -L -o $binary https://github.com/simplex-chat/simplexmq/releases/latest/download/ntf-server-ubuntu-20_04-x86-64
-chmod +x $binary
-
-# / Add to PATH
-cat > /etc/profile.d/simplex.sh << EOF
-#!/bin/bash
-
-export PATH="$PATH:$bin_dir"
-
-EOF
-# Add to PATH /
-
-# Source and test PATH
-source /etc/profile.d/simplex.sh
-ntf-server --version
-
-# Initialize server
-init_opts=()
-
-[[ $ENABLE_STORE_LOG == "on" ]] && init_opts+=(-l)
-
-ip_address=$(curl ifconfig.me)
-init_opts+=(--ip $ip_address)
-
-[[ -n "$FQDN" ]] && init_opts+=(-n $FQDN)
-
-ntf-server init "${init_opts[@]}"
-
-# Server fingerprint
-fingerprint=$(cat /etc/opt/simplex-notifications/fingerprint)
-
-# Determine server address to specify in welcome script and Linode tag
-if [[ -n "$FQDN" ]]; then
-  server_address=$FQDN
-else
-  server_address=$ip_address
-fi
-
-# Set up welcome script
-on_login_script="/opt/simplex-notifications/on_login.sh"
-
-# / Welcome script
-cat > $on_login_script << EOF
-#!/bin/bash
-
-fingerprint=\$1
-server_address=\$2
-
-cat << EOF2
-********************************************************************************
-
-SimpleX notifications server address: ntf://\$fingerprint@\$server_address
-Check server status with: systemctl status ntf-server
-
-To keep this server secure, the UFW firewall is enabled.
-All ports are BLOCKED except 22 (SSH), 443 (HTTPS), 5223 (notifications server).
-
-********************************************************************************
-To stop seeing this message delete line - bash /opt/simplex-notifications/on_login.sh - from /root/.bashrc
-EOF2
-
-EOF
-# Welcome script /
-
-chmod +x $on_login_script
-echo "bash $on_login_script $fingerprint $server_address" >> /root/.bashrc
-
-# Create A record and update Linode's tags
-if [[ -n "$API_TOKEN" ]]; then
-  if [[ -n "$FQDN" ]]; then
-    domain_address=$(echo $FQDN | rev | cut -d "." -f 1,2 | rev)
-    domain_id=$(curl -H "Authorization: Bearer $API_TOKEN" https://api.linode.com/v4/domains \
-    | jq --arg da "$domain_address" '.data[] | select( .domain == $da ) | .id')
-    if [[ -n $domain_id ]]; then
-      curl \
-        -s -H "Content-Type: application/json" \
-        -H "Authorization: Bearer $API_TOKEN" \
-        -X POST -d "{\"type\":\"A\",\"name\":\"$FQDN\",\"target\":\"$ip_address\"}" \
-        https://api.linode.com/v4/domains/${domain_id}/records
-    fi
-  fi
-
-  version=$(ntf-server --version | cut -d ' ' -f 3-)
-
-  curl \
-    -s -H "Content-Type: application/json" \
-    -H "Authorization: Bearer $API_TOKEN" \
-    -X PUT -d "{\"tags\":[\"$server_address\",\"$fingerprint\",\"$version\"]}" \
-    https://api.linode.com/v4/linode/instances/$LINODE_ID
-fi
-
-# / Create systemd service
-cat > /etc/systemd/system/ntf-server.service << EOF
-[Unit]
-Description=SimpleX notifications server
-
-[Service]
-Environment="APNS_KEY_FILE=/etc/opt/simplex-notifications/AuthKey.p8"
-Environment="APNS_KEY_ID=$APNS_KEY_ID"
-Type=simple
-ExecStart=/bin/sh -c "exec $binary start >> /var/opt/simplex-notifications/ntf-server.log 2>&1"
-KillSignal=SIGINT
-Restart=always
-RestartSec=10
-LimitNOFILE=1000000
-LimitNOFILESoft=1000000
-
-[Install]
-WantedBy=multi-user.target
-
-EOF
-# Create systemd service /
-
-# Start systemd service
-chmod 644 /etc/systemd/system/ntf-server.service
-sudo systemctl enable ntf-server
-# ! APNS key file and certificate have to be copied manually
-# sudo systemctl start ntf-server
-
-# Reboot Linode to apply upgrades
-# sudo reboot
diff --git a/source/scripts/smp-server-digitalocean-droplet/README.md b/source/scripts/smp-server-digitalocean-droplet/README.md
deleted file mode 100644
index 5f0bb39..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/README.md
+++ /dev/null
@@ -1,23 +0,0 @@
-# SMP server image for DigitalOcean
-
-## How to build an image
-
-1. [Create an API token](https://cloud.digitalocean.com/account/api/tokens) in vendor account in DigitalOcean.
-2. Install [packer](https://www.packer.io/downloads) downloading binary or with brew (on Mac):
-
-```shell
-brew tap hashicorp/tap
-brew install hashicorp/tap/packer
-```
-
-3. Run `packer build` in the `smp-server-digitalocean-droplet` repository:
-
-```shell
-cd ./scripts/smp-server-digitalocean-droplet
-DIGITALOCEAN_TOKEN=$YOUR_TOKEN packer build -on-error=ask -color=false ./marketplace-image.json
-```
-
-**TODO** (see Linode script)
-
-- Increase file descriptors limit
-- Configure Restart for systemd service
diff --git a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/initialize_server.sh b/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/initialize_server.sh
deleted file mode 100644
index 4b66e2a..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/initialize_server.sh
+++ /dev/null
@@ -1,51 +0,0 @@
-#!/bin/bash
-
-# Download latest release
-bin_dir="/opt/simplex/bin"
-binary="$bin_dir/smp-server"
-mkdir -p $bin_dir
-curl -L -o $binary https://github.com/simplex-chat/simplexmq/releases/latest/download/smp-server-ubuntu-20_04-x86-64
-chmod +x $binary
-
-# / Add to PATH
-cat > /etc/profile.d/simplex.sh << EOF
-#!/bin/bash
-
-export PATH="$PATH:$bin_dir"
-
-EOF
-# Add to PATH /
-
-# Source and test PATH
-source /etc/profile.d/simplex.sh
-smp-server --version
-
-# Initialize server
-ip_address=$(curl ifconfig.me)
-smp-server init -l --ip $ip_address
-
-# Server fingerprint
-fingerprint=$(cat /etc/opt/simplex/fingerprint)
-
-# Set up welcome script
-echo "bash /opt/simplex/on_login.sh $fingerprint $ip_address" >> /root/.bashrc
-
-# / Create systemd service for SMP server
-cat > /etc/systemd/system/smp-server.service << EOF
-[Unit]
-Description=SMP server
-
-[Service]
-Type=simple
-ExecStart=/bin/sh -c "exec $binary start >> /var/opt/simplex/smp-server.log 2>&1"
-
-[Install]
-WantedBy=multi-user.target
-
-EOF
-# Create systemd service for SMP server /
-
-# Start systemd service for SMP server
-chmod 644 /etc/systemd/system/smp-server.service
-sudo systemctl enable smp-server
-sudo systemctl start smp-server
diff --git a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/on_login.sh b/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/on_login.sh
deleted file mode 100644
index c7e6391..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/on_login.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash
-
-fingerprint=$1
-server_address=$2
-
-cat <<EOF
-********************************************************************************
-
-SMP server address: smp://$fingerprint@$server_address
-Check SMP server status with: systemctl status smp-server
-
-To keep this server secure, the UFW firewall is enabled.
-All ports are BLOCKED except 22 (SSH), 443 (HTTPS), 5223 (SMP server).
-
-********************************************************************************
-To stop seeing this message delete line - bash /opt/simplex/on_login.sh - from /root/.bashrc
-EOF
diff --git a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/server_bootstrap.sh b/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/server_bootstrap.sh
deleted file mode 100644
index 136a327..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/files/opt/simplex/server_bootstrap.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/bash
-
-set -eu
-
-if [[ ! -f /opt/simplex/do_initialize_server ]]; then
-  touch /opt/simplex/do_initialize_server
-elif [[ ! -f /etc/opt/simplex/smp-server.ini ]]; then
-  chmod +x /opt/simplex/initialize_server.sh
-  /opt/simplex/initialize_server.sh
-else
-  echo "SMP server already initialized"
-fi
diff --git a/source/scripts/smp-server-digitalocean-droplet/marketplace-image.json b/source/scripts/smp-server-digitalocean-droplet/marketplace-image.json
deleted file mode 100644
index b8a4f80..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/marketplace-image.json
+++ /dev/null
@@ -1,47 +0,0 @@
-{
-  "variables": {
-    "token": "{{env `DIGITALOCEAN_TOKEN`}}",
-    "image_name": "smp-server-snapshot",
-    "application_name": "SMP server"
-  },
-  "sensitive-variables": ["token"],
-  "builders": [
-    {
-      "type": "digitalocean",
-      "api_token": "{{user `token`}}",
-      "image": "ubuntu-20-04-x64",
-      "region": "fra1",
-      "size": "s-1vcpu-1gb",
-      "ssh_username": "root",
-      "snapshot_name": "{{user `image_name`}}"
-    }
-  ],
-  "provisioners": [
-    {
-      "type": "shell",
-      "inline": [
-        "cloud-init status --wait",
-        "mkdir -p /opt/simplex"
-      ]
-    },
-    {
-      "type": "file",
-      "source": "files/opt/",
-      "destination": "/opt/"
-    },
-    {
-      "type": "shell",
-      "environment_vars": [
-        "application_name={{user `application_name`}}",
-        "DEBIAN_FRONTEND=noninteractive"
-      ],
-      "scripts": [
-        "scripts/01-packages.sh",
-        "scripts/02-firewall.sh",
-        "scripts/03-init-start.sh",
-        "scripts/90-cleanup.sh",
-        "scripts/99-img-check.sh"
-      ]
-    }
-  ]
-}
diff --git a/source/scripts/smp-server-digitalocean-droplet/scripts/01-packages.sh b/source/scripts/smp-server-digitalocean-droplet/scripts/01-packages.sh
deleted file mode 100644
index b23fd7b..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/scripts/01-packages.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/sh
-
-# https://superuser.com/questions/1638779/automatic-yess-to-linux-update-upgrade
-# https://superuser.com/questions/1412054/non-interactive-apt-upgrade
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  update
-
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  dist-upgrade
-
-# TODO install unattended-upgrades; jq is not needed on DigitalOcean
-# sudo DEBIAN_FRONTEND=noninteractive \
-#   apt-get \
-#   -o Dpkg::Options::=--force-confold \
-#   -o Dpkg::Options::=--force-confdef \
-#   -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-#   install jq
diff --git a/source/scripts/smp-server-digitalocean-droplet/scripts/02-firewall.sh b/source/scripts/smp-server-digitalocean-droplet/scripts/02-firewall.sh
deleted file mode 100644
index 311d342..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/scripts/02-firewall.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/sh
-
-# Add firewall
-echo "y" | ufw enable
-
-# Open ports
-ufw allow ssh
-ufw allow https
-ufw allow 5223
diff --git a/source/scripts/smp-server-digitalocean-droplet/scripts/03-init-start.sh b/source/scripts/smp-server-digitalocean-droplet/scripts/03-init-start.sh
deleted file mode 100644
index 3bb2aa8..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/scripts/03-init-start.sh
+++ /dev/null
@@ -1,23 +0,0 @@
-#!/bin/bash
-
-chmod +x /opt/simplex/server_bootstrap.sh
-
-# / Create systemd service for server bootstrap script
-cat > /etc/systemd/system/server-bootstrap.service << EOF
-[Unit]
-Description=Server bootstrap script that downloads and initializes SMP server from the latest release
-
-[Service]
-Type=oneshot
-ExecStart=/opt/simplex/server_bootstrap.sh
-
-[Install]
-WantedBy=multi-user.target
-
-EOF
-# Create systemd service for server bootstrap script /
-
-# Start systemd service for server bootstrap script
-chmod 644 /etc/systemd/system/server-bootstrap.service
-sudo systemctl enable server-bootstrap
-sudo systemctl start server-bootstrap
diff --git a/source/scripts/smp-server-digitalocean-droplet/scripts/90-cleanup.sh b/source/scripts/smp-server-digitalocean-droplet/scripts/90-cleanup.sh
deleted file mode 100644
index c0af8b0..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/scripts/90-cleanup.sh
+++ /dev/null
@@ -1,60 +0,0 @@
-#!/bin/bash
-
-# DigitalOcean Marketplace Image Validation Tool
-# ¬© 2021 DigitalOcean LLC.
-# This code is licensed under Apache 2.0 license (see LICENSE.md for details)
-
-set -o errexit
-
-# Ensure /tmp exists and has the proper permissions before
-# checking for security updates
-# https://github.com/digitalocean/marketplace-partners/issues/94
-if [[ ! -d /tmp ]]; then
-  mkdir /tmp
-fi
-chmod 1777 /tmp
-
-if [ -n "$(command -v yum)" ]; then
-  yum update -y
-  yum clean all
-elif [ -n "$(command -v apt-get)" ]; then
-  apt-get -y update
-  apt-get -y upgrade
-  apt-get -y autoremove
-  apt-get -y autoclean
-fi
-
-rm -rf /tmp/* /var/tmp/*
-history -c
-cat /dev/null > /root/.bash_history
-unset HISTFILE
-find /var/log -mtime -1 -type f -exec truncate -s 0 {} \;
-rm -rf /var/log/*.gz /var/log/*.[0-9] /var/log/*-????????
-rm -rf /var/lib/cloud/instances/*
-rm -f /root/.ssh/authorized_keys /etc/ssh/*key*
-touch /etc/ssh/revoked_keys
-chmod 600 /etc/ssh/revoked_keys
-
-# Securely erase the unused portion of the filesystem
-GREEN='\033[0;32m'
-NC='\033[0m'
-printf "\n${GREEN}Writing zeros to the remaining disk space to securely
-erase the unused portion of the file system.
-Depending on your disk size this may take several minutes.
-The secure erase will complete successfully when you see:${NC}
-    dd: writing to '/zerofile': No space left on device\n
-Beginning secure erase now\n"
-
-dd if=/dev/zero of=/zerofile &
-  PID=$!
-  while [ -d /proc/$PID ]
-    do
-      printf "."
-      sleep 5
-    done
-sync; rm /zerofile; sync
-cat /dev/null > /var/log/lastlog; cat /dev/null > /var/log/wtmp
-
-rm /var/log/auth.log
-rm /var/log/kern.log
-rm /var/log/ufw.log
diff --git a/source/scripts/smp-server-digitalocean-droplet/scripts/99-img-check.sh b/source/scripts/smp-server-digitalocean-droplet/scripts/99-img-check.sh
deleted file mode 100644
index 0617de1..0000000
--- a/source/scripts/smp-server-digitalocean-droplet/scripts/99-img-check.sh
+++ /dev/null
@@ -1,682 +0,0 @@
-#!/bin/bash
-
-# DigitalOcean Marketplace Image Validation Tool
-# ¬© 2021 DigitalOcean LLC.
-# This code is licensed under Apache 2.0 license (see LICENSE.md for details)
-
-VERSION="v. 1.6"
-RUNDATE=$( date )
-
-# Script should be run with SUDO
-if [ "$EUID" -ne 0 ]
-  then echo "[Error] - This script must be run with sudo or as the root user."
-  exit 1
-fi
-
-STATUS=0
-PASS=0
-WARN=0
-FAIL=0
-
-# $1 == command to check for
-# returns: 0 == true, 1 == false
-cmdExists() {
-    if command -v "$1" > /dev/null 2>&1; then
-        return 0
-    else
-        return 1
-    fi
-}
-
-function getDistro {
-    if [ -f /etc/os-release ]; then
-    # freedesktop.org and systemd
-    . /etc/os-release
-    OS=$NAME
-    VER=$VERSION_ID
-elif type lsb_release >/dev/null 2>&1; then
-    # linuxbase.org
-    OS=$(lsb_release -si)
-    VER=$(lsb_release -sr)
-elif [ -f /etc/lsb-release ]; then
-    # For some versions of Debian/Ubuntu without lsb_release command
-    . /etc/lsb-release
-    OS=$DISTRIB_ID
-    VER=$DISTRIB_RELEASE
-elif [ -f /etc/debian_version ]; then
-    # Older Debian/Ubuntu/etc.
-    OS=Debian
-    VER=$(cat /etc/debian_version)
-elif [ -f /etc/SuSe-release ]; then
-    # Older SuSE/etc.
-    :
-elif [ -f /etc/redhat-release ]; then
-    # Older Red Hat, CentOS, etc.
-    VER=$( cat /etc/redhat-release | cut -d" " -f3 | cut -d "." -f1)
-    d=$( cat /etc/redhat-release | cut -d" " -f1 | cut -d "." -f1)
-    if [[ $d == "CentOS" ]]; then
-      OS="CentOS Linux"
-    fi
-else
-    # Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
-    OS=$(uname -s)
-    VER=$(uname -r)
-fi
-}
-function loadPasswords {
-SHADOW=$(cat /etc/shadow)
-}
-
-function checkAgent {
-  # Check for the presence of the do-agent in the filesystem
-  if [ -d /var/opt/digitalocean/do-agent ];then
-     echo -en "\e[41m[FAIL]\e[0m DigitalOcean Monitoring Agent detected.\n"
-            ((FAIL++))
-            STATUS=2
-      if [[ $OS == "CentOS Linux" ]]; then
-        echo "The agent can be removed with 'sudo yum remove do-agent' "
-      elif [[ $OS == "Ubuntu" ]]; then
-        echo "The agent can be removed with 'sudo apt-get purge do-agent' "
-      fi
-  else
-    echo -en "\e[32m[PASS]\e[0m DigitalOcean Monitoring agent was not found\n"
-    ((PASS++))
-  fi
-}
-
-function checkLogs {
-    cp_ignore="/var/log/cpanel-install.log"
-    echo -en "\nChecking for log files in /var/log\n\n"
-    # Check if there are log archives or log files that have not been recently cleared.
-    for f in /var/log/*-????????; do
-      [[ -e $f ]] || break
-      if [ $f != $cp_ignore ]; then
-        echo -en "\e[93m[WARN]\e[0m Log archive ${f} found\n"
-        ((WARN++))
-        if [[ $STATUS != 2 ]]; then
-            STATUS=1
-        fi
-      fi
-    done
-    for f in  /var/log/*.[0-9];do
-      [[ -e $f ]] || break
-        echo -en "\e[93m[WARN]\e[0m Log archive ${f} found\n"
-        ((WARN++))
-        if [[ $STATUS != 2 ]]; then
-            STATUS=1
-        fi
-    done
-    for f in /var/log/*.log; do
-      [[ -e $f ]] || break
-      if [[ "${f}" = '/var/log/lfd.log' && "$( cat "${f}" | egrep -v '/var/log/messages has been reset| Watching /var/log/messages' | wc -c)" -gt 50 ]]; then
-        if [ $f != $cp_ignore ]; then
-        echo -en "\e[93m[WARN]\e[0m un-cleared log file, ${f} found\n"
-        ((WARN++))
-        if [[ $STATUS != 2 ]]; then
-            STATUS=1
-        fi
-      fi
-      elif [[ "${f}" != '/var/log/lfd.log' && "$( cat "${f}" | wc -c)" -gt 50 ]]; then
-      if [ $f != $cp_ignore ]; then
-        echo -en "\e[93m[WARN]\e[0m un-cleared log file, ${f} found\n"
-        ((WARN++))
-        if [[ $STATUS != 2 ]]; then
-            STATUS=1
-        fi
-      fi
-    fi
-    done
-}
-function checkTMP {
-  # Check the /tmp directory to ensure it is empty.  Warn on any files found.
-  return 1
-}
-function checkRoot {
-    user="root"
-    uhome="/root"
-    for usr in $SHADOW
-    do
-      IFS=':' read -r -a u <<< "$usr"
-      if [[ "${u[0]}" == "${user}" ]]; then
-        if [[ ${u[1]} == "!" ]] || [[ ${u[1]} == "!!" ]] || [[ ${u[1]} == "*" ]]; then
-            echo -en "\e[32m[PASS]\e[0m User ${user} has no password set.\n"
-            ((PASS++))
-        else
-            echo -en "\e[41m[FAIL]\e[0m User ${user} has a password set on their account.\n"
-            ((FAIL++))
-            STATUS=2
-        fi
-      fi
-    done
-    if [ -d ${uhome}/ ]; then
-            if [ -d ${uhome}/.ssh/ ]; then
-                if  ls ${uhome}/.ssh/*> /dev/null 2>&1; then
-                    for key in ${uhome}/.ssh/*
-                        do
-                             if  [ "${key}" == "${uhome}/.ssh/authorized_keys" ]; then
-
-                                if [ "$( cat "${key}" | wc -c)" -gt 50 ]; then
-                                    echo -en "\e[41m[FAIL]\e[0m User \e[1m${user}\e[0m has a populated authorized_keys file in \e[93m${key}\e[0m\n"
-                                    akey=$(cat ${key})
-                                    echo "File Contents:"
-                                    echo $akey
-                                    echo "--------------"
-                                    ((FAIL++))
-                                    STATUS=2
-                                fi
-                            elif  [ "${key}" == "${uhome}/.ssh/id_rsa" ]; then
-                                if [ "$( cat "${key}" | wc -c)" -gt 0 ]; then
-                                  echo -en "\e[41m[FAIL]\e[0m User \e[1m${user}\e[0m has a private key file in \e[93m${key}\e[0m\n"
-                                      akey=$(cat ${key})
-                                      echo "File Contents:"
-                                      echo $akey
-                                      echo "--------------"
-                                      ((FAIL++))
-                                      STATUS=2
-                                else
-                                  echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has empty private key file in \e[93m${key}\e[0m\n"
-                                  ((WARN++))
-                                  if [[ $STATUS != 2 ]]; then
-                                    STATUS=1
-                                  fi
-                                fi
-                            elif  [ "${key}" != "${uhome}/.ssh/known_hosts" ]; then
-                                 echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has a file in their .ssh directory at \e[93m${key}\e[0m\n"
-                                    ((WARN++))
-                                    if [[ $STATUS != 2 ]]; then
-                                        STATUS=1
-                                    fi
-                            else
-                                if [ "$( cat "${key}" | wc -c)" -gt 50 ]; then
-                                    echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has a populated known_hosts file in \e[93m${key}\e[0m\n"
-                                    ((WARN++))
-                                    if [[ $STATUS != 2 ]]; then
-                                        STATUS=1
-                                    fi
-                                fi
-                            fi
-                        done
-                else
-                    echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m has no SSH keys present\n"
-                fi
-            else
-                echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m does not have an .ssh directory\n"
-            fi
-             if [ -f /root/.bash_history ];then
-
-                      BH_S=$( cat /root/.bash_history | wc -c)
-
-                      if [[ $BH_S -lt 200 ]]; then
-                          echo -en "\e[32m[PASS]\e[0m ${user}'s Bash History appears to have been cleared\n"
-                          ((PASS++))
-                      else
-                          echo -en "\e[41m[FAIL]\e[0m ${user}'s Bash History should be cleared to prevent sensitive information from leaking\n"
-                          ((FAIL++))
-                              STATUS=2
-                      fi
-
-                      return 1;
-                  else
-                      echo -en "\e[32m[PASS]\e[0m The Root User's Bash History is not present\n"
-                      ((PASS++))
-                  fi
-        else
-            echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m does not have a directory in /home\n"
-        fi
-        echo -en "\n\n"
-    return 1
-}
-
-function checkUsers {
-    # Check each user-created account
-    for user in $(awk -F: '$3 >= 1000 && $1 != "nobody" {print $1}' /etc/passwd;)
-    do
-      # Skip some other non-user system accounts
-      if [[ $user == "centos" ]]; then
-        :
-      elif [[ $user == "nfsnobody" ]]; then
-        :
-    else
-      echo -en "\nChecking user: ${user}...\n"
-      for usr in $SHADOW
-        do
-          IFS=':' read -r -a u <<< "$usr"
-          if [[ "${u[0]}" == "${user}" ]]; then
-              if [[ ${u[1]} == "!" ]] || [[ ${u[1]} == "!!" ]] || [[ ${u[1]} == "*" ]]; then
-                  echo -en "\e[32m[PASS]\e[0m User ${user} has no password set.\n"
-                  ((PASS++))
-              else
-                  echo -en "\e[41m[FAIL]\e[0m User ${user} has a password set on their account. Only system users are allowed on the image.\n"
-                  ((FAIL++))
-                  STATUS=2
-              fi
-          fi
-        done
-        #echo "User Found: ${user}"
-        uhome="/home/${user}"
-        if [ -d "${uhome}/" ]; then
-            if [ -d "${uhome}/.ssh/" ]; then
-                if  ls "${uhome}/.ssh/*"> /dev/null 2>&1; then
-                    for key in ${uhome}/.ssh/*
-                        do
-                            if  [ "${key}" == "${uhome}/.ssh/authorized_keys" ]; then
-                                if [ "$( cat "${key}" | wc -c)" -gt 50 ]; then
-                                    echo -en "\e[41m[FAIL]\e[0m User \e[1m${user}\e[0m has a populated authorized_keys file in \e[93m${key}\e[0m\n"
-                                    akey=$(cat ${key})
-                                    echo "File Contents:"
-                                    echo $akey
-                                    echo "--------------"
-                                    ((FAIL++))
-                                    STATUS=2
-                                fi
-                              elif  [ "${key}" == "${uhome}/.ssh/id_rsa" ]; then
-                                if [ "$( cat "${key}" | wc -c)" -gt 0 ]; then
-                                  echo -en "\e[41m[FAIL]\e[0m User \e[1m${user}\e[0m has a private key file in \e[93m${key}\e[0m\n"
-                                      akey=$(cat ${key})
-                                      echo "File Contents:"
-                                      echo $akey
-                                      echo "--------------"
-                                      ((FAIL++))
-                                      STATUS=2
-                                else
-                                  echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has empty private key file in \e[93m${key}\e[0m\n"
-                                  ((WARN++))
-                                  if [[ $STATUS != 2 ]]; then
-                                    STATUS=1
-                                  fi
-                                fi
-                            elif  [ "${key}" != "${uhome}/.ssh/known_hosts" ]; then
-
-                                 echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has a file in their .ssh directory named \e[93m${key}\e[0m\n"
-                                 ((WARN++))
-                                 if [[ $STATUS != 2 ]]; then
-                                        STATUS=1
-                                    fi
-
-                            else
-                                if [ "$( cat "${key}" | wc -c)" -gt 50 ]; then
-                                    echo -en "\e[93m[WARN]\e[0m User \e[1m${user}\e[0m has a known_hosts file in \e[93m${key}\e[0m\n"
-                                    ((WARN++))
-                                    if [[ $STATUS != 2 ]]; then
-                                        STATUS=1
-                                    fi
-                                fi
-                            fi
-
-
-                        done
-                else
-                    echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m has no SSH keys present\n"
-                fi
-            else
-                echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m does not have an .ssh directory\n"
-            fi
-        else
-            echo -en "\e[32m[ OK ]\e[0m User \e[1m${user}\e[0m does not have a directory in /home\n"
-        fi
-
-         # Check for an uncleared .bash_history for this user
-              if [ -f "${uhome}/.bash_history" ]; then
-                            BH_S=$( cat "${uhome}/.bash_history" | wc -c )
-
-                            if [[ $BH_S -lt 200 ]]; then
-                                echo -en "\e[32m[PASS]\e[0m ${user}'s Bash History appears to have been cleared\n"
-                                ((PASS++))
-                            else
-                                echo -en "\e[41m[FAIL]\e[0m ${user}'s Bash History should be cleared to prevent sensitive information from leaking\n"
-                                ((FAIL++))
-                                    STATUS=2
-
-                            fi
-                           echo -en "\n\n"
-                         fi
-        fi
-    done
-}
-function checkFirewall {
-
-    if [[ $OS == "Ubuntu" ]]; then
-      fw="ufw"
-      ufwa=$(ufw status |head -1| sed -e "s/^Status:\ //")
-      if [[ $ufwa == "active" ]]; then
-        FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-      else
-        FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-      fi
-    elif [[ $OS == "CentOS Linux" ]]; then
-      if [ -f /usr/lib/systemd/system/csf.service ]; then
-        fw="csf"
-        if [[ $(systemctl status $fw >/dev/null 2>&1) ]]; then
-
-        FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-        elif cmdExists "firewall-cmd"; then
-          if [[ $(systemctl is-active firewalld >/dev/null 2>&1 && echo 1 || echo 0) ]]; then
-           FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-          ((PASS++))
-          else
-            FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-          ((WARN++))
-          fi
-        else
-          FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-        fi
-      else
-        fw="firewalld"
-        if [[ $(systemctl is-active firewalld >/dev/null 2>&1 && echo 1 || echo 0) ]]; then
-          FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-        else
-          FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-        fi
-      fi
-    elif [[ "$OS" =~ Debian.* ]]; then
-      # user could be using a number of different services for managing their firewall
-      # we will check some of the most common
-      if cmdExists 'ufw'; then
-        fw="ufw"
-        ufwa=$(ufw status |head -1| sed -e "s/^Status:\ //")
-        if [[ $ufwa == "active" ]]; then
-        FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-      else
-        FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-      fi
-      elif cmdExists "firewall-cmd"; then
-        fw="firewalld"
-        if [[ $(systemctl is-active --quiet $fw) ]]; then
-          FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-        else
-          FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-        fi
-      else
-        # user could be using vanilla iptables, check if kernel module is loaded
-        fw="iptables"
-        if [[ $(lsmod | grep -q '^ip_tables' 2>/dev/null) ]]; then
-          FW_VER="\e[32m[PASS]\e[0m Firewall service (${fw}) is active\n"
-        ((PASS++))
-        else
-          FW_VER="\e[93m[WARN]\e[0m No firewall is configured. Ensure ${fw} is installed and configured\n"
-        ((WARN++))
-        fi
-      fi
-    fi
-
-}
-function checkUpdates {
-    if [[ $OS == "Ubuntu" ]] || [[ "$OS" =~ Debian.* ]]; then
-        # Ensure /tmp exists and has the proper permissions before
-        # checking for security updates
-        # https://github.com/digitalocean/marketplace-partners/issues/94
-        if [[ ! -d /tmp ]]; then
-          mkdir /tmp
-        fi
-        chmod 1777 /tmp
-
-        echo -en "\nUpdating apt package database to check for security updates, this may take a minute...\n\n"
-        apt-get -y update > /dev/null
-
-        uc=$(apt-get --just-print upgrade | grep -i "security" | wc -l)
-        if [[ $uc -gt 0 ]]; then
-          update_count=$(( ${uc} / 2 ))
-        else
-          update_count=0
-        fi
-
-        if [[ $update_count -gt 0 ]]; then
-            echo -en "\e[41m[FAIL]\e[0m There are ${update_count} security updates available for this image that have not been installed.\n"
-            echo -en
-            echo -en "Here is a list of the security updates that are not installed:\n"
-            sleep 2
-            apt-get --just-print upgrade | grep -i security | awk '{print $2}' | awk '!seen[$0]++'
-            echo -en
-            ((FAIL++))
-            STATUS=2
-        else
-            echo -en "\e[32m[PASS]\e[0m There are no pending security updates for this image.\n\n"
-        fi
-    elif [[ $OS == "CentOS Linux" ]]; then
-        echo -en "\nChecking for available security updates, this may take a minute...\n\n"
-
-        update_count=$(yum check-update --security --quiet | wc -l)
-         if [[ $update_count -gt 0 ]]; then
-            echo -en "\e[41m[FAIL]\e[0m There are ${update_count} security updates available for this image that have not been installed.\n"
-            ((FAIL++))
-            STATUS=2
-        else
-            echo -en "\e[32m[PASS]\e[0m There are no pending security updates for this image.\n"
-            ((PASS++))
-        fi
-    else
-        echo "Error encountered"
-        exit 1
-    fi
-
-    return 1;
-}
-function checkCloudInit {
-
-    if hash cloud-init 2>/dev/null; then
-        CI="\e[32m[PASS]\e[0m Cloud-init is installed.\n"
-        ((PASS++))
-    else
-        CI="\e[41m[FAIL]\e[0m No valid verison of cloud-init was found.\n"
-        ((FAIL++))
-        STATUS=2
-    fi
-    return 1
-}
-function checkMongoDB {
-  # Check if MongoDB is installed
-  # If it is, verify the version is allowed (non-SSPL)
-
-   if [[ $OS == "Ubuntu" ]] || [[ "$OS" =~ Debian.* ]]; then
-
-     if [[ -f "/usr/bin/mongod" ]]; then
-       version=$(/usr/bin/mongod --version --quiet | grep "db version" | sed -e "s/^db\ version\ v//")
-
-      if version_gt $version 4.0.0; then
-        if version_gt $version 4.0.3; then
-          echo -en "\e[41m[FAIL]\e[0m An SSPL version of MongoDB is present, ${version}"
-          ((FAIL++))
-           STATUS=2
-        else
-          echo -en "\e[32m[PASS]\e[0m The version of MongoDB installed, ${version} is not under the SSPL"
-          ((PASS++))
-        fi
-      else
-         if version_gt $version 3.6.8; then
-          echo -en "\e[41m[FAIL]\e[0m An SSPL version of MongoDB is present, ${version}"
-          ((FAIL++))
-           STATUS=2
-        else
-          echo -en "\e[32m[PASS]\e[0m The version of MongoDB installed, ${version} is not under the SSPL"
-          ((PASS++))
-        fi
-      fi
-
-
-     else
-       echo -en "\e[32m[PASS]\e[0m MongoDB is not installed"
-       ((PASS++))
-     fi
-
-   elif [[ $OS == "CentOS Linux" ]]; then
-
-    if [[ -f "/usr/bin/mongod" ]]; then
-       version=$(/usr/bin/mongod --version --quiet | grep "db version" | sed -e "s/^db\ version\ v//")
-
-
-       if version_gt $version 4.0.0; then
-        if version_gt $version 4.0.3; then
-          echo -en "\e[41m[FAIL]\e[0m An SSPL version of MongoDB is present"
-          ((FAIL++))
-           STATUS=2
-        else
-          echo -en "\e[32m[PASS]\e[0m The version of MongoDB installed is not under the SSPL"
-          ((PASS++))
-        fi
-      else
-         if version_gt $version 3.6.8; then
-          echo -en "\e[41m[FAIL]\e[0m An SSPL version of MongoDB is present"
-          ((FAIL++))
-           STATUS=2
-        else
-          echo -en "\e[32m[PASS]\e[0m The version of MongoDB installed is not under the SSPL"
-          ((PASS++))
-        fi
-      fi
-
-
-
-     else
-       echo -en "\e[32m[PASS]\e[0m MongoDB is not installed"
-       ((PASS++))
-     fi
-
-  else
-    echo "ERROR: Unable to identify distribution"
-    ((FAIL++))
-    STATUS 2
-    return 1
-  fi
-
-
-}
-
-function version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }
-
-
-clear
-echo "DigitalOcean Marketplace Image Validation Tool ${VERSION}"
-echo "Executed on: ${RUNDATE}"
-echo "Checking local system for Marketplace compatibility..."
-
-getDistro
-
-echo -en "\n\e[1mDistribution:\e[0m ${OS}\n"
-echo -en "\e[1mVersion:\e[0m ${VER}\n\n"
-
-ost=0
-osv=0
-
-if [[ $OS == "Ubuntu" ]]; then
-        ost=1
-    if [[ $VER == "20.04" ]]; then
-        osv=1
-    elif [[ $VER == "18.04" ]]; then
-        osv=1
-    elif [[ $VER == "16.04" ]]; then
-        osv=1
-    else
-        osv=0
-    fi
-
-elif [[ "$OS" =~ Debian.* ]]; then
-    ost=1
-    case "$VER" in
-        9)
-            osv=1
-            ;;
-        10)
-            osv=1
-            ;;
-        *)
-            osv=2
-            ;;
-    esac
-
-elif [[ $OS == "CentOS Linux" ]]; then
-        ost=1
-    if [[ $VER == "8" ]]; then
-        osv=1
-    elif [[ $VER == "7" ]]; then
-        osv=1
-    elif [[ $VER == "6" ]]; then
-        osv=1
-    else
-        osv=2
-    fi
-else
-    ost=0
-fi
-
-if [[ $ost == 1 ]]; then
-    echo -en "\e[32m[PASS]\e[0m Supported Operating System Detected: ${OS}\n"
-    ((PASS++))
-else
-    echo -en "\e[41m[FAIL]\e[0m ${OS} is not a supported Operating System\n"
-    ((FAIL++))
-    STATUS=2
-fi
-
-if [[ $osv == 1 ]]; then
-    echo -en "\e[32m[PASS]\e[0m Supported Release Detected: ${VER}\n"
-    ((PASS++))
-elif [[ $ost == 1 ]]; then
-    echo -en "\e[41m[FAIL]\e[0m ${OS} ${VER} is not a supported Operating System Version\n"
-    ((FAIL++))
-    STATUS=2
-else
-    echo "Exiting..."
-    exit 1
-fi
-
-checkCloudInit
-
-echo -en "${CI}"
-
-checkFirewall
-
-echo -en "${FW_VER}"
-
-checkUpdates
-
-loadPasswords
-
-checkLogs
-
-echo -en "\n\nChecking all user-created accounts...\n"
-checkUsers
-
-echo -en "\n\nChecking the root account...\n"
-checkRoot
-
-checkAgent
-
-checkMongoDB
-
-
-# Summary
-echo -en "\n\n---------------------------------------------------------------------------------------------------\n"
-
-if [[ $STATUS == 0 ]]; then
-    echo -en "Scan Complete.\n\e[32mAll Tests Passed!\e[0m\n"
-elif [[ $STATUS == 1 ]]; then
-    echo -en "Scan Complete. \n\e[93mSome non-critical tests failed.  Please review these items.\e[0m\e[0m\n"
-else
-    echo -en "Scan Complete. \n\e[41mOne or more tests failed.  Please review these items and re-test.\e[0m\n"
-fi
-echo "---------------------------------------------------------------------------------------------------"
-echo -en "\e[1m${PASS} Tests PASSED\e[0m\n"
-echo -en "\e[1m${WARN} WARNINGS\e[0m\n"
-echo -en "\e[1m${FAIL} Tests FAILED\e[0m\n"
-echo -en "---------------------------------------------------------------------------------------------------\n"
-
-if [[ $STATUS == 0 ]]; then
-    echo -en "We did not detect any issues with this image. Please be sure to manually ensure that all software installed on the base system is functional, secure and properly configured (or facilities for configuration on first-boot have been created).\n\n"
-    exit 0
-elif [[ $STATUS == 1 ]]; then
-    echo -en "Please review all [WARN] items above and ensure they are intended or resolved.  If you do not have a specific requirement, we recommend resolving these items before image submission\n\n"
-    exit 0
-else
-    echo -en "Some critical tests failed.  These items must be resolved and this scan re-run before you submit your image to the DigitalOcean Marketplace.\n\n"
-    exit 1
-fi
diff --git a/source/scripts/smp-server-linode.sh b/source/scripts/smp-server-linode.sh
deleted file mode 100644
index 2f57479..0000000
--- a/source/scripts/smp-server-linode.sh
+++ /dev/null
@@ -1,175 +0,0 @@
-#!/bin/bash
-
-# <UDF name="enable_store_log" label="Store log - persist SMP queues to append only log and restore them upon server restart." default="on" oneof="on, off" />
-# <UDF name="api_token" label="Linode API token - enable Linode to create tags with server address, fingerprint and version. Note: minimal permissions token should have are read/write access to `linodes` (to create tags) and `domains` (to add A record for the third level domain if FQDN is provided)." default="" />
-# <UDF name="fqdn" label="FQDN (Fully Qualified Domain Name) - provide third level domain name (e.g. smp.example.com). If provided use `smp://fingerprint@FQDN` as server address in the client. If FQDN is not provided use `smp://fingerprint@IP` instead." default="" />
-
-# Log all stdout output to stackscript.log
-exec &> >(tee -i /var/log/stackscript.log)
-
-# Uncomment next line to enable debugging features
-# set -xeo pipefail
-
-cd $HOME
-
-# https://superuser.com/questions/1638779/automatic-yess-to-linux-update-upgrade
-# https://superuser.com/questions/1412054/non-interactive-apt-upgrade
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  update
-
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  dist-upgrade
-
-# TODO install unattended-upgrades
-sudo DEBIAN_FRONTEND=noninteractive \
-  apt-get \
-  -o Dpkg::Options::=--force-confold \
-  -o Dpkg::Options::=--force-confdef \
-  -y --allow-downgrades --allow-remove-essential --allow-change-held-packages \
-  install jq
-
-# Add firewall
-echo "y" | ufw enable
-
-# Open ports
-ufw allow ssh
-ufw allow https
-ufw allow 5223
-
-# Increase file descriptors limit
-echo 'fs.file-max = 1000000' >> /etc/sysctl.conf
-echo 'fs.inode-max = 1000000' >> /etc/sysctl.conf
-echo 'root soft nofile unlimited' >> /etc/security/limits.conf
-echo 'root hard nofile unlimited' >> /etc/security/limits.conf
-
-# Download latest release
-bin_dir="/opt/simplex/bin"
-binary="$bin_dir/smp-server"
-mkdir -p $bin_dir
-curl -L -o $binary https://github.com/simplex-chat/simplexmq/releases/latest/download/smp-server-ubuntu-20_04-x86-64
-chmod +x $binary
-
-# / Add to PATH
-cat > /etc/profile.d/simplex.sh << EOF
-#!/bin/bash
-
-export PATH="$PATH:$bin_dir"
-
-EOF
-# Add to PATH /
-
-# Source and test PATH
-source /etc/profile.d/simplex.sh
-smp-server --version
-
-# Initialize server
-init_opts=()
-
-[[ $ENABLE_STORE_LOG == "on" ]] && init_opts+=(-l)
-
-ip_address=$(curl ifconfig.me)
-init_opts+=(--ip $ip_address)
-
-[[ -n "$FQDN" ]] && init_opts+=(-n $FQDN)
-
-smp-server init "${init_opts[@]}"
-
-# Server fingerprint
-fingerprint=$(cat /etc/opt/simplex/fingerprint)
-
-# Determine server address to specify in welcome script and Linode tag
-if [[ -n "$FQDN" ]]; then
-  server_address=$FQDN
-else
-  server_address=$ip_address
-fi
-
-# Set up welcome script
-on_login_script="/opt/simplex/on_login.sh"
-
-# / Welcome script
-cat > $on_login_script << EOF
-#!/bin/bash
-
-fingerprint=\$1
-server_address=\$2
-
-cat << EOF2
-********************************************************************************
-
-SMP server address: smp://\$fingerprint@\$server_address
-Check SMP server status with: systemctl status smp-server
-
-To keep this server secure, the UFW firewall is enabled.
-All ports are BLOCKED except 22 (SSH), 443 (HTTPS), 5223 (SMP server).
-
-********************************************************************************
-To stop seeing this message delete line - bash /opt/simplex/on_login.sh - from /root/.bashrc
-EOF2
-
-EOF
-# Welcome script /
-
-chmod +x $on_login_script
-echo "bash $on_login_script $fingerprint $server_address" >> /root/.bashrc
-
-# Create A record and update Linode's tags
-if [[ -n "$API_TOKEN" ]]; then
-  if [[ -n "$FQDN" ]]; then
-    domain_address=$(echo $FQDN | rev | cut -d "." -f 1,2 | rev)
-    domain_id=$(curl -H "Authorization: Bearer $API_TOKEN" https://api.linode.com/v4/domains \
-    | jq --arg da "$domain_address" '.data[] | select( .domain == $da ) | .id')
-    if [[ -n $domain_id ]]; then
-      curl \
-        -s -H "Content-Type: application/json" \
-        -H "Authorization: Bearer $API_TOKEN" \
-        -X POST -d "{\"type\":\"A\",\"name\":\"$FQDN\",\"target\":\"$ip_address\"}" \
-        https://api.linode.com/v4/domains/${domain_id}/records
-    fi
-  fi
-
-  version=$(smp-server --version | cut -d ' ' -f 3-)
-
-  curl \
-    -s -H "Content-Type: application/json" \
-    -H "Authorization: Bearer $API_TOKEN" \
-    -X PUT -d "{\"tags\":[\"$server_address\",\"$fingerprint\",\"$version\"]}" \
-    https://api.linode.com/v4/linode/instances/$LINODE_ID
-fi
-
-# / Create systemd service
-cat > /etc/systemd/system/smp-server.service << EOF
-[Unit]
-Description=SMP server
-
-[Service]
-Type=simple
-ExecStart=/bin/sh -c "exec $binary start >> /var/opt/simplex/smp-server.log 2>&1"
-KillSignal=SIGINT
-TimeoutStopSec=infinity
-Restart=always
-RestartSec=10
-LimitNOFILE=1000000
-LimitNOFILESoft=1000000
-
-[Install]
-WantedBy=multi-user.target
-
-EOF
-# Create systemd service /
-
-# Start systemd service
-chmod 644 /etc/systemd/system/smp-server.service
-sudo systemctl enable smp-server
-sudo systemctl start smp-server
-
-# Reboot Linode to apply upgrades
-sudo reboot
diff --git a/source/scripts/tor/README.md b/source/scripts/tor/README.md
deleted file mode 100644
index 20b0d5a..0000000
--- a/source/scripts/tor/README.md
+++ /dev/null
@@ -1,37 +0,0 @@
-1. Install `tor` following [official guide](https://community.torproject.org/onion-services/setup/install/).
-
-2. Modify `/etc/tor/torrc` configuration file:
-
-```sh
-...
-# Disable anonymous mode for better connectivity
-## Needed for HiddenServiceNonAnonymousMode
-SOCKSPort 0
-## Needed for HiddenServiceSingleHopMode
-HiddenServiceNonAnonymousMode 1
-## Flag to disable anonymous mode
-## This option reduces the latency of server connection, but it makes server itself not anonymous,
-## it only protects the anonymity of the users connecting to the server.
-## In case your server address has both public and onion hostnames it is not anonymous anyway,
-## so this is what you want.
-HiddenServiceSingleHopMode 1
-
-# Specify folder for smp-tor
-## Folder for keys, address, etc.
-HiddenServiceDir /var/lib/tor/simplex-smp/
-## Map smp port (5223) to tor
-HiddenServicePort 5223 localhost:5223
-...
-```
-
-3. Restart `tor` system service:
-
-```
-sudo systemctl restart tor
-```
-
-4. Onion address can be obtained from following file:
-
-```sh
-sudo cat /var/lib/tor/simplex-smp/hostname
-```
diff --git a/source/scripts/update-smp-server.sh b/source/scripts/update-smp-server.sh
deleted file mode 100755
index 2182eb5..0000000
--- a/source/scripts/update-smp-server.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/bash
-
-# systemd has to be configured to use SIGINT to save and restore undelivered messages after restart.
-# Add this to [Service] section:
-# KillSignal=SIGINT
-curl -L -o /opt/simplex/bin/smp-server-new https://github.com/simplex-chat/simplexmq/releases/latest/download/smp-server-ubuntu-20_04-x86-64
-systemctl stop smp-server
-cp /var/opt/simplex/smp-server-store.log /var/opt/simplex/smp-server-store.log.bak
-mv /opt/simplex/bin/smp-server /opt/simplex/bin/smp-server-old
-mv /opt/simplex/bin/smp-server-new /opt/simplex/bin/smp-server
-chmod +x /opt/simplex/bin/smp-server
-systemctl start smp-server
diff --git a/source/simplexmq.cabal b/source/simplexmq.cabal
deleted file mode 100644
index 8114386..0000000
--- a/source/simplexmq.cabal
+++ /dev/null
@@ -1,429 +0,0 @@
-cabal-version: 1.12
-
--- This file has been generated from package.yaml by hpack version 0.34.4.
---
--- see: https://github.com/sol/hpack
-
-name:           simplexmq
-version:        4.0.0
-synopsis:       SimpleXMQ message broker
-description:    This package includes <./docs/Simplex-Messaging-Server.html server>,
-                <./docs/Simplex-Messaging-Client.html client> and
-                <./docs/Simplex-Messaging-Agent.html agent> for SMP protocols:
-                .
-                * <https://github.com/simplex-chat/simplexmq/blob/master/protocol/simplex-messaging.md SMP protocol>
-                * <https://github.com/simplex-chat/simplexmq/blob/master/protocol/agent-protocol.md SMP agent protocol>
-                .
-                See <https://github.com/simplex-chat/simplex-chat terminal chat prototype> built with SimpleXMQ broker.
-category:       Chat, Network, Web, System, Cryptography
-homepage:       https://github.com/simplex-chat/simplexmq#readme
-author:         simplex.chat
-maintainer:     chat@simplex.chat
-copyright:      2020-2022 simplex.chat
-license:        AGPL-3
-license-file:   LICENSE
-build-type:     Simple
-extra-source-files:
-    README.md
-    CHANGELOG.md
-
-flag swift
-  description: Enable swift JSON format
-  manual: True
-  default: False
-
-library
-  exposed-modules:
-      Simplex.Messaging.Agent
-      Simplex.Messaging.Agent.Client
-      Simplex.Messaging.Agent.Env.SQLite
-      Simplex.Messaging.Agent.Lock
-      Simplex.Messaging.Agent.NtfSubSupervisor
-      Simplex.Messaging.Agent.Protocol
-      Simplex.Messaging.Agent.QueryString
-      Simplex.Messaging.Agent.RetryInterval
-      Simplex.Messaging.Agent.Server
-      Simplex.Messaging.Agent.Store
-      Simplex.Messaging.Agent.Store.SQLite
-      Simplex.Messaging.Agent.Store.SQLite.Migrations
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220101_initial
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220301_snd_queue_keys
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220322_notifications
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220608_v2
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220625_v2_ntf_mode
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220811_onion_hosts
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220817_connection_ntfs
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220905_commands
-      Simplex.Messaging.Agent.Store.SQLite.Migrations.M20220915_connection_queues
-      Simplex.Messaging.Agent.TRcvQueues
-      Simplex.Messaging.Client
-      Simplex.Messaging.Client.Agent
-      Simplex.Messaging.Crypto
-      Simplex.Messaging.Crypto.Ratchet
-      Simplex.Messaging.Encoding
-      Simplex.Messaging.Encoding.String
-      Simplex.Messaging.Notifications.Client
-      Simplex.Messaging.Notifications.Protocol
-      Simplex.Messaging.Notifications.Server
-      Simplex.Messaging.Notifications.Server.Env
-      Simplex.Messaging.Notifications.Server.Main
-      Simplex.Messaging.Notifications.Server.Push.APNS
-      Simplex.Messaging.Notifications.Server.Stats
-      Simplex.Messaging.Notifications.Server.Store
-      Simplex.Messaging.Notifications.Server.StoreLog
-      Simplex.Messaging.Notifications.Transport
-      Simplex.Messaging.Notifications.Types
-      Simplex.Messaging.Parsers
-      Simplex.Messaging.Protocol
-      Simplex.Messaging.Server
-      Simplex.Messaging.Server.CLI
-      Simplex.Messaging.Server.Env.STM
-      Simplex.Messaging.Server.Expiration
-      Simplex.Messaging.Server.Main
-      Simplex.Messaging.Server.MsgStore
-      Simplex.Messaging.Server.MsgStore.STM
-      Simplex.Messaging.Server.QueueStore
-      Simplex.Messaging.Server.QueueStore.STM
-      Simplex.Messaging.Server.Stats
-      Simplex.Messaging.Server.StoreLog
-      Simplex.Messaging.TMap
-      Simplex.Messaging.Transport
-      Simplex.Messaging.Transport.Client
-      Simplex.Messaging.Transport.HTTP2
-      Simplex.Messaging.Transport.HTTP2.Client
-      Simplex.Messaging.Transport.HTTP2.Server
-      Simplex.Messaging.Transport.KeepAlive
-      Simplex.Messaging.Transport.Server
-      Simplex.Messaging.Transport.WebSockets
-      Simplex.Messaging.Util
-      Simplex.Messaging.Version
-  other-modules:
-      Paths_simplexmq
-  hs-source-dirs:
-      src
-  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns
-  build-depends:
-      QuickCheck ==2.14.*
-    , aeson ==2.0.*
-    , ansi-terminal >=0.10 && <0.12
-    , asn1-encoding ==0.9.*
-    , asn1-types ==0.3.*
-    , async ==2.2.*
-    , attoparsec ==0.14.*
-    , base >=4.14 && <5
-    , base64-bytestring >=1.0 && <1.3
-    , bytestring ==0.10.*
-    , case-insensitive ==1.2.*
-    , composition ==1.0.*
-    , constraints >=0.12 && <0.14
-    , containers ==0.6.*
-    , cryptonite >=0.27 && <0.30
-    , cryptostore ==0.2.*
-    , data-default ==0.7.*
-    , direct-sqlcipher ==2.3.*
-    , directory ==1.3.*
-    , filepath ==1.4.*
-    , generic-random >=1.3 && <1.5
-    , http-types ==0.12.*
-    , http2 ==3.0.*
-    , ini ==0.4.1
-    , iso8601-time ==0.1.*
-    , memory ==0.15.*
-    , mtl ==2.2.*
-    , network >=3.1.2.7 && <3.2
-    , network-transport ==0.5.4
-    , optparse-applicative >=0.15 && <0.17
-    , process ==1.6.*
-    , random >=1.1 && <1.3
-    , simple-logger ==0.1.*
-    , socks ==0.6.*
-    , sqlcipher-simple ==0.4.*
-    , stm ==2.5.*
-    , template-haskell ==2.16.*
-    , text ==1.2.*
-    , time ==1.9.*
-    , time-compat ==1.9.*
-    , time-manager ==0.0.*
-    , tls >=1.6.0 && <1.7
-    , transformers ==0.5.*
-    , unliftio ==0.2.*
-    , unliftio-core ==0.2.*
-    , websockets ==0.12.*
-    , x509 ==1.7.*
-    , x509-store ==1.6.*
-    , x509-validation ==1.6.*
-  if flag(swift)
-    cpp-options: -DswiftJSON
-  default-language: Haskell2010
-
-executable ntf-server
-  main-is: Main.hs
-  other-modules:
-      Paths_simplexmq
-  hs-source-dirs:
-      apps/ntf-server
-  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns -threaded
-  build-depends:
-      QuickCheck ==2.14.*
-    , aeson ==2.0.*
-    , ansi-terminal >=0.10 && <0.12
-    , asn1-encoding ==0.9.*
-    , asn1-types ==0.3.*
-    , async ==2.2.*
-    , attoparsec ==0.14.*
-    , base >=4.14 && <5
-    , base64-bytestring >=1.0 && <1.3
-    , bytestring ==0.10.*
-    , case-insensitive ==1.2.*
-    , composition ==1.0.*
-    , constraints >=0.12 && <0.14
-    , containers ==0.6.*
-    , cryptonite >=0.27 && <0.30
-    , cryptostore ==0.2.*
-    , data-default ==0.7.*
-    , direct-sqlcipher ==2.3.*
-    , directory ==1.3.*
-    , filepath ==1.4.*
-    , generic-random >=1.3 && <1.5
-    , http-types ==0.12.*
-    , http2 ==3.0.*
-    , ini ==0.4.1
-    , iso8601-time ==0.1.*
-    , memory ==0.15.*
-    , mtl ==2.2.*
-    , network >=3.1.2.7 && <3.2
-    , network-transport ==0.5.4
-    , optparse-applicative >=0.15 && <0.17
-    , process ==1.6.*
-    , random >=1.1 && <1.3
-    , simple-logger ==0.1.*
-    , simplexmq
-    , socks ==0.6.*
-    , sqlcipher-simple ==0.4.*
-    , stm ==2.5.*
-    , template-haskell ==2.16.*
-    , text ==1.2.*
-    , time ==1.9.*
-    , time-compat ==1.9.*
-    , time-manager ==0.0.*
-    , tls >=1.6.0 && <1.7
-    , transformers ==0.5.*
-    , unliftio ==0.2.*
-    , unliftio-core ==0.2.*
-    , websockets ==0.12.*
-    , x509 ==1.7.*
-    , x509-store ==1.6.*
-    , x509-validation ==1.6.*
-  if flag(swift)
-    cpp-options: -DswiftJSON
-  default-language: Haskell2010
-
-executable smp-agent
-  main-is: Main.hs
-  other-modules:
-      Paths_simplexmq
-  hs-source-dirs:
-      apps/smp-agent
-  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns -threaded
-  build-depends:
-      QuickCheck ==2.14.*
-    , aeson ==2.0.*
-    , ansi-terminal >=0.10 && <0.12
-    , asn1-encoding ==0.9.*
-    , asn1-types ==0.3.*
-    , async ==2.2.*
-    , attoparsec ==0.14.*
-    , base >=4.14 && <5
-    , base64-bytestring >=1.0 && <1.3
-    , bytestring ==0.10.*
-    , case-insensitive ==1.2.*
-    , composition ==1.0.*
-    , constraints >=0.12 && <0.14
-    , containers ==0.6.*
-    , cryptonite >=0.27 && <0.30
-    , cryptostore ==0.2.*
-    , data-default ==0.7.*
-    , direct-sqlcipher ==2.3.*
-    , directory ==1.3.*
-    , filepath ==1.4.*
-    , generic-random >=1.3 && <1.5
-    , http-types ==0.12.*
-    , http2 ==3.0.*
-    , ini ==0.4.1
-    , iso8601-time ==0.1.*
-    , memory ==0.15.*
-    , mtl ==2.2.*
-    , network >=3.1.2.7 && <3.2
-    , network-transport ==0.5.4
-    , optparse-applicative >=0.15 && <0.17
-    , process ==1.6.*
-    , random >=1.1 && <1.3
-    , simple-logger ==0.1.*
-    , simplexmq
-    , socks ==0.6.*
-    , sqlcipher-simple ==0.4.*
-    , stm ==2.5.*
-    , template-haskell ==2.16.*
-    , text ==1.2.*
-    , time ==1.9.*
-    , time-compat ==1.9.*
-    , time-manager ==0.0.*
-    , tls >=1.6.0 && <1.7
-    , transformers ==0.5.*
-    , unliftio ==0.2.*
-    , unliftio-core ==0.2.*
-    , websockets ==0.12.*
-    , x509 ==1.7.*
-    , x509-store ==1.6.*
-    , x509-validation ==1.6.*
-  if flag(swift)
-    cpp-options: -DswiftJSON
-  default-language: Haskell2010
-
-executable smp-server
-  main-is: Main.hs
-  other-modules:
-      Paths_simplexmq
-  hs-source-dirs:
-      apps/smp-server
-  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns -threaded
-  build-depends:
-      QuickCheck ==2.14.*
-    , aeson ==2.0.*
-    , ansi-terminal >=0.10 && <0.12
-    , asn1-encoding ==0.9.*
-    , asn1-types ==0.3.*
-    , async ==2.2.*
-    , attoparsec ==0.14.*
-    , base >=4.14 && <5
-    , base64-bytestring >=1.0 && <1.3
-    , bytestring ==0.10.*
-    , case-insensitive ==1.2.*
-    , composition ==1.0.*
-    , constraints >=0.12 && <0.14
-    , containers ==0.6.*
-    , cryptonite >=0.27 && <0.30
-    , cryptostore ==0.2.*
-    , data-default ==0.7.*
-    , direct-sqlcipher ==2.3.*
-    , directory ==1.3.*
-    , filepath ==1.4.*
-    , generic-random >=1.3 && <1.5
-    , http-types ==0.12.*
-    , http2 ==3.0.*
-    , ini ==0.4.1
-    , iso8601-time ==0.1.*
-    , memory ==0.15.*
-    , mtl ==2.2.*
-    , network >=3.1.2.7 && <3.2
-    , network-transport ==0.5.4
-    , optparse-applicative >=0.15 && <0.17
-    , process ==1.6.*
-    , random >=1.1 && <1.3
-    , simple-logger ==0.1.*
-    , simplexmq
-    , socks ==0.6.*
-    , sqlcipher-simple ==0.4.*
-    , stm ==2.5.*
-    , template-haskell ==2.16.*
-    , text ==1.2.*
-    , time ==1.9.*
-    , time-compat ==1.9.*
-    , time-manager ==0.0.*
-    , tls >=1.6.0 && <1.7
-    , transformers ==0.5.*
-    , unliftio ==0.2.*
-    , unliftio-core ==0.2.*
-    , websockets ==0.12.*
-    , x509 ==1.7.*
-    , x509-store ==1.6.*
-    , x509-validation ==1.6.*
-  if flag(swift)
-    cpp-options: -DswiftJSON
-  default-language: Haskell2010
-
-test-suite smp-server-test
-  type: exitcode-stdio-1.0
-  main-is: Test.hs
-  other-modules:
-      AgentTests
-      AgentTests.ConnectionRequestTests
-      AgentTests.DoubleRatchetTests
-      AgentTests.FunctionalAPITests
-      AgentTests.NotificationTests
-      AgentTests.SchemaDump
-      AgentTests.SQLiteTests
-      CLITests
-      CoreTests.CryptoTests
-      CoreTests.EncodingTests
-      CoreTests.ProtocolErrorTests
-      CoreTests.VersionRangeTests
-      NtfClient
-      NtfServerTests
-      ServerTests
-      SMPAgentClient
-      SMPClient
-      Paths_simplexmq
-  hs-source-dirs:
-      tests
-  ghc-options: -Wall -Wcompat -Werror=incomplete-patterns -Wredundant-constraints -Wincomplete-record-updates -Wincomplete-uni-patterns -Wunused-type-patterns
-  build-depends:
-      HUnit ==1.6.*
-    , QuickCheck ==2.14.*
-    , aeson ==2.0.*
-    , ansi-terminal >=0.10 && <0.12
-    , asn1-encoding ==0.9.*
-    , asn1-types ==0.3.*
-    , async ==2.2.*
-    , attoparsec ==0.14.*
-    , base >=4.14 && <5
-    , base64-bytestring >=1.0 && <1.3
-    , bytestring ==0.10.*
-    , case-insensitive ==1.2.*
-    , composition ==1.0.*
-    , constraints >=0.12 && <0.14
-    , containers ==0.6.*
-    , cryptonite >=0.27 && <0.30
-    , cryptostore ==0.2.*
-    , data-default ==0.7.*
-    , direct-sqlcipher ==2.3.*
-    , directory ==1.3.*
-    , filepath ==1.4.*
-    , generic-random >=1.3 && <1.5
-    , hspec ==2.7.*
-    , hspec-core ==2.7.*
-    , http-types ==0.12.*
-    , http2 ==3.0.*
-    , ini ==0.4.1
-    , iso8601-time ==0.1.*
-    , main-tester ==0.2.*
-    , memory ==0.15.*
-    , mtl ==2.2.*
-    , network >=3.1.2.7 && <3.2
-    , network-transport ==0.5.4
-    , optparse-applicative >=0.15 && <0.17
-    , process ==1.6.*
-    , random >=1.1 && <1.3
-    , silently ==1.2.*
-    , simple-logger ==0.1.*
-    , simplexmq
-    , socks ==0.6.*
-    , sqlcipher-simple ==0.4.*
-    , stm ==2.5.*
-    , template-haskell ==2.16.*
-    , text ==1.2.*
-    , time ==1.9.*
-    , time-compat ==1.9.*
-    , time-manager ==0.0.*
-    , timeit ==2.0.*
-    , tls >=1.6.0 && <1.7
-    , transformers ==0.5.*
-    , unliftio ==0.2.*
-    , unliftio-core ==0.2.*
-    , websockets ==0.12.*
-    , x509 ==1.7.*
-    , x509-store ==1.6.*
-    , x509-validation ==1.6.*
-  if flag(swift)
-    cpp-options: -DswiftJSON
-  default-language: Haskell2010
diff --git a/source/src/Simplex/Messaging/Notifications/Server/Env.hs b/simplified/src/Simplex/Messaging/Notifications/Server/Env.hs
index 95f7c45..ec16335 100644
--- a/source/src/Simplex/Messaging/Notifications/Server/Env.hs
+++ b/simplified/src/Simplex/Messaging/Notifications/Server/Env.hs
@@ -72,7 +72,6 @@ data NtfEnv = NtfEnv
     store :: NtfStore,
     storeLog :: Maybe (StoreLog 'WriteMode),
     idsDrg :: TVar ChaChaDRG,
-    serverIdentity :: C.KeyHash,
     tlsServerParams :: T.ServerParams,
     serverIdentity :: C.KeyHash,
     serverStats :: NtfServerStats
diff --git a/source/stack.yaml b/source/stack.yaml
deleted file mode 100644
index 0cc6845..0000000
--- a/source/stack.yaml
+++ /dev/null
@@ -1,84 +0,0 @@
-# This file was automatically generated by 'stack init'
-#
-# Some commonly used options have been documented as comments in this file.
-# For advanced use and comprehensive documentation of the format, please see:
-# https://docs.haskellstack.org/en/stable/yaml_configuration/
-
-# Resolver to choose a 'specific' stackage snapshot or a compiler version.
-# A snapshot resolver dictates the compiler version and the set of packages
-# to be used for project dependencies. For example:
-#
-# resolver: lts-3.5
-# resolver: nightly-2015-09-21
-# resolver: ghc-7.10.2
-#
-# The location of a snapshot can be provided as a file or url. Stack assumes
-# a snapshot provided as a file might change, whereas a url resource does not.
-#
-# resolver: ./custom-snapshot.yaml
-# resolver: https://example.com/snapshots/2018-01-01.yaml
-resolver: lts-18.28
-
-# User packages to be built.
-# Various formats can be used as shown in the example below.
-#
-# packages:
-# - some-directory
-# - https://example.com/foo/bar/baz-0.0.2.tar.gz
-#   subdirs:
-#   - auto-update
-#   - wai
-packages:
-  - .
-# Dependency packages to be pulled from upstream that are not in the resolver.
-# These entries can reference officially published versions as well as
-# forks / in-progress versions pinned to a git hash. For example:
-#
-extra-deps:
-  - cryptostore-0.2.1.0@sha256:9896e2984f36a1c8790f057fd5ce3da4cbcaf8aa73eb2d9277916886978c5b19,3881
-  - network-3.1.2.7@sha256:e3d78b13db9512aeb106e44a334ab42b7aa48d26c097299084084cb8be5c5568,4888
-  - simple-logger-0.1.0@sha256:be8ede4bd251a9cac776533bae7fb643369ebd826eb948a9a18df1a8dd252ff8,1079
-  - tls-1.6.0@sha256:7ae39373fd2de27fb80e90f76d22aeeb9a074a0ddd120cbd02c9c52f516a9e55,6987
-  # below dependencies are to update Aeson to 2.0.3
-  - OneTuple-0.3.1@sha256:a848c096c9d29e82ffdd30a9998aa2931cbccb3a1bc137539d80f6174d31603e,2262
-  - attoparsec-0.14.4@sha256:79584bdada8b730cb5138fca8c35c76fbef75fc1d1e01e6b1d815a5ee9843191,5810
-  - hashable-1.4.0.2@sha256:0cddd0229d1aac305ea0404409c0bbfab81f075817bd74b8b2929eff58333e55,5005
-  - semialign-1.2.0.1@sha256:0e179b4d3a8eff79001d374d6c91917c6221696b9620f0a4d86852fc6a9b9501,2836
-  - text-short-0.1.5@sha256:962c6228555debdc46f758d0317dea16e5240d01419b42966674b08a5c3d8fa6,3498
-  - time-compat-1.9.6.1@sha256:42d8f2e08e965e1718917d54ad69e1d06bd4b87d66c41dc7410f59313dba4ed1,5033
-  - github: simplex-chat/aeson
-    commit: 3eb66f9a68f103b5f1489382aad89f5712a64db7
-  # - ../direct-sqlcipher
-  - github: simplex-chat/direct-sqlcipher
-    commit: 34309410eb2069b029b8fc1872deb1e0db123294
-  # - ../sqlcipher-simple
-  - github: simplex-chat/sqlcipher-simple
-    commit: 5e154a2aeccc33ead6c243ec07195ab673137221
-  # - ../hs-tls/core
-  # - github: simplex-chat/hs-tls
-  #   commit: f6cc753611f80af300401cfae63846e9d7c40d9e
-  #   subdirs:
-  #     - core
-# Override default flag values for local packages and extra-deps
-# flags: {}
-
-# Extra package databases containing global packages
-# extra-package-dbs: []
-
-# Control whether we use the GHC we find on the path
-# system-ghc: true
-#
-# Require a specific version of stack, using version ranges
-# require-stack-version: -any # Default
-# require-stack-version: ">=2.1"
-#
-# Override the architecture used by stack, especially useful on Windows
-# arch: i386
-# arch: x86_64
-#
-# Extra directories used by stack for building
-# extra-include-dirs: [/path/to/dir]
-# extra-lib-dirs: [/path/to/dir]
-#
-# Allow a newer minor version of GHC than the snapshot specifies
-# compiler-check: newer-minor
diff --git a/source/tests/AgentTests/ConnectionRequestTests.hs b/source/tests/AgentTests/ConnectionRequestTests.hs
deleted file mode 100644
index ea50834..0000000
--- a/source/tests/AgentTests/ConnectionRequestTests.hs
+++ /dev/null
@@ -1,179 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-
-module AgentTests.ConnectionRequestTests where
-
-import Data.ByteString (ByteString)
-import Network.HTTP.Types (urlEncode)
-import Simplex.Messaging.Agent.Protocol
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Crypto.Ratchet
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Protocol (ProtocolServer (..), supportedSMPClientVRange)
-import Simplex.Messaging.Version
-import Test.Hspec
-
-uri :: String
-uri = "smp.simplex.im"
-
-srv :: SMPServer
-srv = SMPServer "smp.simplex.im" "5223" (C.KeyHash "\215m\248\251")
-
-queueAddr :: SMPQueueAddress
-queueAddr =
-  SMPQueueAddress
-    { smpServer = srv,
-      senderId = "\223\142z\251",
-      dhPublicKey = testDhKey
-    }
-
-queueAddrNoPort :: SMPQueueAddress
-queueAddrNoPort = queueAddr {smpServer = srv {port = ""}}
-
-queue :: SMPQueueUri
-queue = SMPQueueUri supportedSMPClientVRange queueAddr
-
-queueV1 :: SMPQueueUri
-queueV1 = SMPQueueUri (mkVersionRange 1 1) queueAddr
-
-testDhKey :: C.PublicKeyX25519
-testDhKey = "MCowBQYDK2VuAyEAjiswwI3O/NlS8Fk3HJUW870EY2bAwmttMBsvRB9eV3o="
-
-testDhKeyStr :: ByteString
-testDhKeyStr = strEncode testDhKey
-
-testDhKeyStrUri :: ByteString
-testDhKeyStrUri = urlEncode True testDhKeyStr
-
-connReqData :: ConnReqUriData
-connReqData =
-  ConnReqUriData
-    { crScheme = simplexChat,
-      crAgentVRange = mkVersionRange 1 1,
-      crSmpQueues = [queueV1],
-      crClientData = Nothing
-    }
-
-testDhPubKey :: C.PublicKeyX448
-testDhPubKey = "MEIwBQYDK2VvAzkAmKuSYeQ/m0SixPDS8Wq8VBaTS1cW+Lp0n0h4Diu+kUpR+qXx4SDJ32YGEFoGFGSbGPry5Ychr6U="
-
-testE2ERatchetParams :: E2ERatchetParamsUri 'C.X448
-testE2ERatchetParams = E2ERatchetParamsUri (mkVersionRange 1 1) testDhPubKey testDhPubKey
-
-testE2ERatchetParams12 :: E2ERatchetParamsUri 'C.X448
-testE2ERatchetParams12 = E2ERatchetParamsUri supportedE2EEncryptVRange testDhPubKey testDhPubKey
-
-connectionRequest :: AConnectionRequestUri
-connectionRequest =
-  ACR SCMInvitation $
-    CRInvitationUri connReqData testE2ERatchetParams
-
-connectionRequest12 :: AConnectionRequestUri
-connectionRequest12 =
-  ACR SCMInvitation $
-    CRInvitationUri
-      connReqData {crAgentVRange = supportedSMPAgentVRange, crSmpQueues = [queueV1, queueV1]}
-      testE2ERatchetParams12
-
-connectionRequestClientDataEmpty :: AConnectionRequestUri
-connectionRequestClientDataEmpty =
-  ACR SCMInvitation $
-    CRInvitationUri connReqData {crClientData = Just "{}"} testE2ERatchetParams
-
-connectionRequestClientData :: AConnectionRequestUri
-connectionRequestClientData =
-  ACR SCMInvitation $
-    CRInvitationUri connReqData {crClientData = Just "{\"type\":\"group_link\", \"group_link_id\":\"abc\"}"} testE2ERatchetParams
-
-connectionRequestTests :: Spec
-connectionRequestTests =
-  describe "connection request parsing / serializing" $ do
-    it "should serialize SMP queue URIs" $ do
-      strEncode (queue :: SMPQueueUri) {queueAddress = queueAddrNoPort}
-        `shouldBe` "smp://1234-w==@smp.simplex.im/3456-w==#/?v=1-2&dh=" <> testDhKeyStrUri
-      strEncode queue {clientVRange = mkVersionRange 1 2}
-        `shouldBe` "smp://1234-w==@smp.simplex.im:5223/3456-w==#/?v=1-2&dh=" <> testDhKeyStrUri
-    it "should parse SMP queue URIs" $ do
-      strDecode ("smp://1234-w==@smp.simplex.im/3456-w==#/?v=1-2&dh=" <> testDhKeyStr)
-        `shouldBe` Right (queue :: SMPQueueUri) {queueAddress = queueAddrNoPort}
-      strDecode ("smp://1234-w==@smp.simplex.im/3456-w==#" <> testDhKeyStr)
-        `shouldBe` Right (queueV1 :: SMPQueueUri) {queueAddress = queueAddrNoPort}
-      strDecode ("smp://1234-w==@smp.simplex.im:5223/3456-w==#" <> testDhKeyStr)
-        `shouldBe` Right queueV1
-      strDecode ("smp://1234-w==@smp.simplex.im:5223/3456-w==#" <> testDhKeyStr <> "/?v=1-2&extra_param=abc")
-        `shouldBe` Right queue
-      strDecode ("smp://1234-w==@smp.simplex.im:5223/3456-w==#/?extra_param=abc&v=1&dh=" <> testDhKeyStr)
-        `shouldBe` Right queueV1
-      strDecode ("smp://1234-w==@smp.simplex.im:5223/3456-w==#" <> testDhKeyStr <> "/?v=1&extra_param=abc")
-        `shouldBe` Right queueV1
-    it "should serialize connection requests" $ do
-      strEncode connectionRequest
-        `shouldBe` "https://simplex.chat/invitation#/?v=1&smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-        <> urlEncode True testDhKeyStrUri
-        <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-      strEncode connectionRequest12
-        `shouldBe` "https://simplex.chat/invitation#/?v=1-2&smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-        <> urlEncode True testDhKeyStrUri
-        <> "%2Csmp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-        <> urlEncode True testDhKeyStrUri
-        <> "&e2e=v%3D1-2%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-      strEncode connectionRequestClientDataEmpty
-        `shouldBe` "https://simplex.chat/invitation#/?v=1&smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-        <> urlEncode True testDhKeyStrUri
-        <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-        <> "&data=%7B%7D"
-      strEncode connectionRequestClientData
-        `shouldBe` "https://simplex.chat/invitation#/?v=1&smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-        <> urlEncode True testDhKeyStrUri
-        <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-        <> "&data=%7B%22type%22%3A%22group_link%22%2C%20%22group_link_id%22%3A%22abc%22%7D"
-    it "should parse connection requests" $ do
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23"
-            <> testDhKeyStrUri
-            <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&v=1"
-        )
-        `shouldBe` Right connectionRequest
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-            <> testDhKeyStrUri
-            <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&v=1"
-        )
-        `shouldBe` Right connectionRequest
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-            <> testDhKeyStrUri
-            <> "&e2e=v%3D1-1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&v=1-1"
-        )
-        `shouldBe` Right connectionRequest
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26extra_param%3Dabc%26dh%3D"
-            <> testDhKeyStrUri
-            <> "%2Csmp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-            <> testDhKeyStrUri
-            <> "&e2e=extra_key%3Dnew%26v%3D1-2%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&some_new_param=abc"
-            <> "&v=1-2"
-        )
-        `shouldBe` Right connectionRequest12
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-            <> testDhKeyStrUri
-            <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&data=%7B%7D"
-            <> "&v=1-1"
-        )
-        `shouldBe` Right connectionRequestClientDataEmpty
-      strDecode
-        ( "https://simplex.chat/invitation#/?smp=smp%3A%2F%2F1234-w%3D%3D%40smp.simplex.im%3A5223%2F3456-w%3D%3D%23%2F%3Fv%3D1%26dh%3D"
-            <> testDhKeyStrUri
-            <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> "&data=%7B%22type%22%3A%22group_link%22%2C%20%22group_link_id%22%3A%22abc%22%7D"
-            <> "&v=1-1"
-        )
-        `shouldBe` Right connectionRequestClientData
diff --git a/source/tests/AgentTests/DoubleRatchetTests.hs b/source/tests/AgentTests/DoubleRatchetTests.hs
deleted file mode 100644
index a343c0b..0000000
--- a/source/tests/AgentTests/DoubleRatchetTests.hs
+++ /dev/null
@@ -1,243 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# LANGUAGE RankNTypes #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE TypeApplications #-}
-{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors #-}
-
-module AgentTests.DoubleRatchetTests where
-
-import Control.Concurrent.STM
-import Control.Monad.Except
-import Data.Aeson (FromJSON, ToJSON)
-import qualified Data.Aeson as J
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.ByteString.Char8 as B
-import qualified Data.Map.Strict as M
-import Simplex.Messaging.Crypto (Algorithm (..), AlgorithmI, CryptoError, DhAlgorithm)
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Crypto.Ratchet
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Parsers (parseAll)
-import Simplex.Messaging.Util ((<$$>))
-import Test.Hspec
-
-doubleRatchetTests :: Spec
-doubleRatchetTests = do
-  describe "double-ratchet encryption/decryption" $ do
-    it "should serialize and parse message header" testMessageHeader
-    it "should encrypt and decrypt messages" $ do
-      withRatchets @X25519 testEncryptDecrypt
-      withRatchets @X448 testEncryptDecrypt
-    it "should encrypt and decrypt skipped messages" $ do
-      withRatchets @X25519 testSkippedMessages
-      withRatchets @X448 testSkippedMessages
-    it "should encrypt and decrypt many messages" $ do
-      withRatchets @X25519 testManyMessages
-    it "should allow skipped after ratchet advance" $ do
-      withRatchets @X25519 testSkippedAfterRatchetAdvance
-    it "should encode/decode ratchet as JSON" $ do
-      testKeyJSON C.SX25519
-      testKeyJSON C.SX448
-      testRatchetJSON C.SX25519
-      testRatchetJSON C.SX448
-    it "should agree the same ratchet parameters" $ do
-      testX3dh C.SX25519
-      testX3dh C.SX448
-    it "should agree the same ratchet parameters with version 1" $ do
-      testX3dhV1 C.SX25519
-      testX3dhV1 C.SX448
-
-paddedMsgLen :: Int
-paddedMsgLen = 100
-
-fullMsgLen :: Int
-fullMsgLen = 1 + fullHeaderLen + C.authTagSize + paddedMsgLen
-
-testMessageHeader :: Expectation
-testMessageHeader = do
-  (k, _) <- C.generateKeyPair' @X25519
-  let hdr = MsgHeader {msgMaxVersion = currentE2EEncryptVersion, msgDHRs = k, msgPN = 0, msgNs = 0}
-  parseAll (smpP @(MsgHeader 'X25519)) (smpEncode hdr) `shouldBe` Right hdr
-
-pattern Decrypted :: ByteString -> Either CryptoError (Either CryptoError ByteString)
-pattern Decrypted msg <- Right (Right msg)
-
-type TestRatchets a = (AlgorithmI a, DhAlgorithm a) => TVar (Ratchet a, SkippedMsgKeys) -> TVar (Ratchet a, SkippedMsgKeys) -> IO ()
-
-testEncryptDecrypt :: TestRatchets a
-testEncryptDecrypt alice bob = do
-  (bob, "hello alice") #> alice
-  (alice, "hello bob") #> bob
-  Right b1 <- encrypt bob "how are you, alice?"
-  Right b2 <- encrypt bob "are you there?"
-  Right b3 <- encrypt bob "hey?"
-  Right a1 <- encrypt alice "how are you, bob?"
-  Right a2 <- encrypt alice "are you there?"
-  Right a3 <- encrypt alice "hey?"
-  Decrypted "how are you, alice?" <- decrypt alice b1
-  Decrypted "are you there?" <- decrypt alice b2
-  Decrypted "hey?" <- decrypt alice b3
-  Decrypted "how are you, bob?" <- decrypt bob a1
-  Decrypted "are you there?" <- decrypt bob a2
-  Decrypted "hey?" <- decrypt bob a3
-  (bob, "I'm here, all good") #> alice
-  (alice, "I'm here too, same") #> bob
-  pure ()
-
-testSkippedMessages :: TestRatchets a
-testSkippedMessages alice bob = do
-  Right msg1 <- encrypt bob "hello alice"
-  Right msg2 <- encrypt bob "hello there again"
-  Right msg3 <- encrypt bob "are you there?"
-  Decrypted "are you there?" <- decrypt alice msg3
-  Right (Left C.CERatchetDuplicateMessage) <- decrypt alice msg3
-  Decrypted "hello there again" <- decrypt alice msg2
-  Decrypted "hello alice" <- decrypt alice msg1
-  pure ()
-
-testManyMessages :: TestRatchets a
-testManyMessages alice bob = do
-  (bob, "b1") #> alice
-  (bob, "b2") #> alice
-  (bob, "b3") #> alice
-  (bob, "b4") #> alice
-  (alice, "a5") #> bob
-  (alice, "a6") #> bob
-  (alice, "a7") #> bob
-  (bob, "b8") #> alice
-  (alice, "a9") #> bob
-  (alice, "a10") #> bob
-  (bob, "b11") #> alice
-  (bob, "b12") #> alice
-  (alice, "a14") #> bob
-  (bob, "b15") #> alice
-  (bob, "b16") #> alice
-
-testSkippedAfterRatchetAdvance :: TestRatchets a
-testSkippedAfterRatchetAdvance alice bob = do
-  (bob, "b1") #> alice
-  Right b2 <- encrypt bob "b2"
-  Right b3 <- encrypt bob "b3"
-  Right b4 <- encrypt bob "b4"
-  (alice, "a5") #> bob
-  Right b5 <- encrypt bob "b5"
-  Right b6 <- encrypt bob "b6"
-  (bob, "b7") #> alice
-  Right b8 <- encrypt bob "b8"
-  Right b9 <- encrypt bob "b9"
-  (alice, "a10") #> bob
-  Right b11 <- encrypt bob "b11"
-  Right b12 <- encrypt bob "b12"
-  (alice, "a14") #> bob
-  Decrypted "b12" <- decrypt alice b12
-  Decrypted "b2" <- decrypt alice b2
-  -- fails on duplicate message
-  Left C.CERatchetHeader <- decrypt alice b2
-  (alice, "a15") #> bob
-  Right a16 <- encrypt bob "a16"
-  Right a17 <- encrypt bob "a17"
-  Decrypted "b8" <- decrypt alice b8
-  Decrypted "b3" <- decrypt alice b3
-  Decrypted "b4" <- decrypt alice b4
-  Decrypted "b5" <- decrypt alice b5
-  Decrypted "b6" <- decrypt alice b6
-  (alice, "a18") #> bob
-  Decrypted "a16" <- decrypt alice a16
-  Decrypted "a17" <- decrypt alice a17
-  Decrypted "b9" <- decrypt alice b9
-  Decrypted "b11" <- decrypt alice b11
-  pure ()
-
-testKeyJSON :: forall a. AlgorithmI a => C.SAlgorithm a -> IO ()
-testKeyJSON _ = do
-  (k, pk) <- C.generateKeyPair' @a
-  testEncodeDecode k
-  testEncodeDecode pk
-
-testRatchetJSON :: forall a. (AlgorithmI a, DhAlgorithm a) => C.SAlgorithm a -> IO ()
-testRatchetJSON _ = do
-  (alice, bob) <- initRatchets @a
-  testEncodeDecode alice
-  testEncodeDecode bob
-
-testEncodeDecode :: (Eq a, Show a, ToJSON a, FromJSON a) => a -> Expectation
-testEncodeDecode x = do
-  let j = J.encode x
-      x' = J.eitherDecode' j
-  x' `shouldBe` Right x
-
-testX3dh :: forall a. (AlgorithmI a, DhAlgorithm a) => C.SAlgorithm a -> IO ()
-testX3dh _ = do
-  (pkBob1, pkBob2, e2eBob) <- generateE2EParams @a currentE2EEncryptVersion
-  (pkAlice1, pkAlice2, e2eAlice) <- generateE2EParams @a currentE2EEncryptVersion
-  let paramsBob = x3dhSnd pkBob1 pkBob2 e2eAlice
-      paramsAlice = x3dhRcv pkAlice1 pkAlice2 e2eBob
-  paramsAlice `shouldBe` paramsBob
-
-testX3dhV1 :: forall a. (AlgorithmI a, DhAlgorithm a) => C.SAlgorithm a -> IO ()
-testX3dhV1 _ = do
-  (pkBob1, pkBob2, e2eBob) <- generateE2EParams @a 1
-  (pkAlice1, pkAlice2, e2eAlice) <- generateE2EParams @a 1
-  let paramsBob = x3dhSnd pkBob1 pkBob2 e2eAlice
-      paramsAlice = x3dhRcv pkAlice1 pkAlice2 e2eBob
-  paramsAlice `shouldBe` paramsBob
-
-(#>) :: (AlgorithmI a, DhAlgorithm a) => (TVar (Ratchet a, SkippedMsgKeys), ByteString) -> TVar (Ratchet a, SkippedMsgKeys) -> Expectation
-(alice, msg) #> bob = do
-  Right msg' <- encrypt alice msg
-  Decrypted msg'' <- decrypt bob msg'
-  msg'' `shouldBe` msg
-
-withRatchets :: forall a. (AlgorithmI a, DhAlgorithm a) => (TVar (Ratchet a, SkippedMsgKeys) -> TVar (Ratchet a, SkippedMsgKeys) -> IO ()) -> Expectation
-withRatchets test = do
-  (a, b) <- initRatchets @a
-  alice <- newTVarIO (a, M.empty)
-  bob <- newTVarIO (b, M.empty)
-  test alice bob `shouldReturn` ()
-
-initRatchets :: (AlgorithmI a, DhAlgorithm a) => IO (Ratchet a, Ratchet a)
-initRatchets = do
-  (pkBob1, pkBob2, e2eBob) <- generateE2EParams currentE2EEncryptVersion
-  (pkAlice1, pkAlice2, e2eAlice) <- generateE2EParams currentE2EEncryptVersion
-  let paramsBob = x3dhSnd pkBob1 pkBob2 e2eAlice
-      paramsAlice = x3dhRcv pkAlice1 pkAlice2 e2eBob
-  (_, pkBob3) <- C.generateKeyPair'
-  let bob = initSndRatchet supportedE2EEncryptVRange (C.publicKey pkAlice2) pkBob3 paramsBob
-      alice = initRcvRatchet supportedE2EEncryptVRange pkAlice2 paramsAlice
-  pure (alice, bob)
-
-encrypt_ :: AlgorithmI a => (Ratchet a, SkippedMsgKeys) -> ByteString -> IO (Either CryptoError (ByteString, Ratchet a, SkippedMsgDiff))
-encrypt_ (rc, _) msg =
-  runExceptT (rcEncrypt rc paddedMsgLen msg)
-    >>= either (pure . Left) checkLength
-  where
-    checkLength (msg', rc') = do
-      B.length msg' `shouldBe` fullMsgLen
-      pure $ Right (msg', rc', SMDNoChange)
-
-decrypt_ :: (AlgorithmI a, DhAlgorithm a) => (Ratchet a, SkippedMsgKeys) -> ByteString -> IO (Either CryptoError (Either CryptoError ByteString, Ratchet a, SkippedMsgDiff))
-decrypt_ (rc, smks) msg = runExceptT $ rcDecrypt rc smks msg
-
-encrypt :: AlgorithmI a => TVar (Ratchet a, SkippedMsgKeys) -> ByteString -> IO (Either CryptoError ByteString)
-encrypt = withTVar encrypt_
-
-decrypt :: (AlgorithmI a, DhAlgorithm a) => TVar (Ratchet a, SkippedMsgKeys) -> ByteString -> IO (Either CryptoError (Either CryptoError ByteString))
-decrypt = withTVar decrypt_
-
-withTVar ::
-  AlgorithmI a =>
-  ((Ratchet a, SkippedMsgKeys) -> ByteString -> IO (Either e (r, Ratchet a, SkippedMsgDiff))) ->
-  TVar (Ratchet a, SkippedMsgKeys) ->
-  ByteString ->
-  IO (Either e r)
-withTVar op rcVar msg =
-  readTVarIO rcVar
-    >>= (\(rc, smks) -> applyDiff smks <$$> (testEncodeDecode rc >> op (rc, smks) msg))
-    >>= \case
-      Right (res, rc', smks') -> atomically (writeTVar rcVar (rc', smks')) >> pure (Right res)
-      Left e -> pure $ Left e
-  where
-    applyDiff smks (res, rc', smDiff) = (res, rc', applySMDiff smks smDiff)
diff --git a/source/tests/AgentTests/FunctionalAPITests.hs b/source/tests/AgentTests/FunctionalAPITests.hs
deleted file mode 100644
index 7f69070..0000000
--- a/source/tests/AgentTests/FunctionalAPITests.hs
+++ /dev/null
@@ -1,866 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# LANGUAGE RankNTypes #-}
-{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}
-
-module AgentTests.FunctionalAPITests
-  ( functionalAPITests,
-    testServerMatrix2,
-    makeConnection,
-    exchangeGreetingsMsgId,
-    switchComplete,
-    get,
-    (##>),
-    (=##>),
-    pattern Msg,
-  )
-where
-
-import Control.Concurrent (killThread, threadDelay)
-import Control.Monad
-import Control.Monad.Except (ExceptT, MonadError (throwError), runExceptT)
-import Control.Monad.IO.Unlift
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.ByteString.Char8 as B
-import Data.Int (Int64)
-import qualified Data.Map as M
-import Data.Maybe (isNothing)
-import qualified Data.Set as S
-import Data.Time.Clock.System (SystemTime (..), getSystemTime)
-import SMPAgentClient
-import SMPClient (cfg, testPort, testPort2, testStoreLogFile2, withSmpServer, withSmpServerConfigOn, withSmpServerOn, withSmpServerStoreLogOn, withSmpServerStoreMsgLogOn)
-import Simplex.Messaging.Agent
-import Simplex.Messaging.Agent.Client (SMPTestFailure (..), SMPTestStep (..))
-import Simplex.Messaging.Agent.Env.SQLite (AgentConfig (..), InitialAgentServers (..))
-import Simplex.Messaging.Agent.Protocol
-import Simplex.Messaging.Client (ProtocolClientConfig (..), defaultClientConfig)
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Protocol (BasicAuth, ErrorType (..), MsgBody, ProtocolServer (..))
-import qualified Simplex.Messaging.Protocol as SMP
-import Simplex.Messaging.Server.Env.STM (ServerConfig (..))
-import Simplex.Messaging.Server.Expiration
-import Simplex.Messaging.Transport (ATransport (..))
-import Simplex.Messaging.Util (tryError)
-import Simplex.Messaging.Version
-import Test.Hspec
-import UnliftIO
-
-(##>) :: MonadIO m => m (ATransmission 'Agent) -> ATransmission 'Agent -> m ()
-a ##> t = a >>= \t' -> liftIO (t' `shouldBe` t)
-
-(=##>) :: MonadIO m => m (ATransmission 'Agent) -> (ATransmission 'Agent -> Bool) -> m ()
-a =##> p = a >>= \t -> liftIO (t `shouldSatisfy` p)
-
-get :: MonadIO m => AgentClient -> m (ATransmission 'Agent)
-get c = do
-  t@(_, _, cmd) <- atomically (readTBQueue $ subQ c)
-  case cmd of
-    CONNECT {} -> get c
-    DISCONNECT {} -> get c
-    _ -> pure t
-
-pattern Msg :: MsgBody -> ACommand 'Agent
-pattern Msg msgBody <- MSG MsgMeta {integrity = MsgOk} _ msgBody
-
-smpCfgV1 :: ProtocolClientConfig
-smpCfgV1 = (smpCfg agentCfg) {smpServerVRange = vr11}
-
-agentCfgV1 :: AgentConfig
-agentCfgV1 = agentCfg {smpAgentVRange = vr11, smpClientVRange = vr11, e2eEncryptVRange = vr11, smpCfg = smpCfgV1}
-
-agentCfgRatchetV1 :: AgentConfig
-agentCfgRatchetV1 = agentCfg {e2eEncryptVRange = vr11}
-
-vr11 :: VersionRange
-vr11 = mkVersionRange 1 1
-
-functionalAPITests :: ATransport -> Spec
-functionalAPITests t = do
-  describe "Establishing duplex connection" $
-    testMatrix2 t runAgentClientTest
-  describe "Establishing duplex connection v2, different Ratchet versions" $
-    testRatchetMatrix2 t runAgentClientTest
-  describe "Establish duplex connection via contact address" $
-    testMatrix2 t runAgentClientContactTest
-  describe "Establish duplex connection via contact address v2, different Ratchet versions" $
-    testRatchetMatrix2 t runAgentClientContactTest
-  describe "Establishing connection asynchronously" $ do
-    it "should connect with initiating client going offline" $
-      withSmpServer t testAsyncInitiatingOffline
-    it "should connect with joining client going offline before its queue activation" $
-      withSmpServer t testAsyncJoiningOfflineBeforeActivation
-    it "should connect with both clients going offline" $
-      withSmpServer t testAsyncBothOffline
-    it "should connect on the second attempt if server was offline" $
-      testAsyncServerOffline t
-    it "should notify after HELLO timeout" $
-      withSmpServer t testAsyncHelloTimeout
-  describe "Duplicate message delivery" $
-    it "should deliver messages to the user once, even if repeat delivery is made by the server (no ACK)" $
-      testDuplicateMessage t
-  describe "Inactive client disconnection" $ do
-    it "should disconnect clients if it was inactive longer than TTL" $
-      testInactiveClientDisconnected t
-    it "should NOT disconnect active clients" $
-      testActiveClientNotDisconnected t
-  describe "Suspending agent" $ do
-    it "should update client when agent is suspended" $
-      withSmpServer t testSuspendingAgent
-    it "should complete sending messages when agent is suspended" $
-      testSuspendingAgentCompleteSending t
-    it "should suspend agent on timeout, even if pending messages not sent" $
-      testSuspendingAgentTimeout t
-  describe "Batching SMP commands" $ do
-    it "should subscribe to multiple subscriptions with batching" $
-      testBatchedSubscriptions t
-  describe "Async agent commands" $ do
-    it "should connect using async agent commands" $
-      withSmpServer t testAsyncCommands
-    it "should restore and complete async commands on restart" $
-      testAsyncCommandsRestore t
-    it "should accept connection using async command" $
-      withSmpServer t testAcceptContactAsync
-  describe "Queue rotation" $ do
-    describe "should switch delivery to the new queue" $
-      testServerMatrix2 t testSwitchConnection
-    describe "should switch to new queue asynchronously" $
-      testServerMatrix2 t testSwitchAsync
-    describe "should delete connection during rotation" $
-      testServerMatrix2 t testSwitchDelete
-  describe "SMP basic auth" $ do
-    describe "with server auth" $ do
-      --                                       allow NEW | server auth, v | clnt1 auth, v  | clnt2 auth, v    |  2 - success, 1 - JOIN fail, 0 - NEW fail
-      it "success                " $ testBasicAuth t True (Just "abcd", 5) (Just "abcd", 5) (Just "abcd", 5) `shouldReturn` 2
-      it "disabled               " $ testBasicAuth t False (Just "abcd", 5) (Just "abcd", 5) (Just "abcd", 5) `shouldReturn` 0
-      it "NEW fail, no auth      " $ testBasicAuth t True (Just "abcd", 5) (Nothing, 5) (Just "abcd", 5) `shouldReturn` 0
-      it "NEW fail, bad auth     " $ testBasicAuth t True (Just "abcd", 5) (Just "wrong", 5) (Just "abcd", 5) `shouldReturn` 0
-      it "NEW fail, version      " $ testBasicAuth t True (Just "abcd", 5) (Just "abcd", 4) (Just "abcd", 5) `shouldReturn` 0
-      it "JOIN fail, no auth     " $ testBasicAuth t True (Just "abcd", 5) (Just "abcd", 5) (Nothing, 5) `shouldReturn` 1
-      it "JOIN fail, bad auth    " $ testBasicAuth t True (Just "abcd", 5) (Just "abcd", 5) (Just "wrong", 5) `shouldReturn` 1
-      it "JOIN fail, version     " $ testBasicAuth t True (Just "abcd", 5) (Just "abcd", 5) (Just "abcd", 4) `shouldReturn` 1
-    describe "no server auth" $ do
-      it "success     " $ testBasicAuth t True (Nothing, 5) (Nothing, 5) (Nothing, 5) `shouldReturn` 2
-      it "srv disabled" $ testBasicAuth t False (Nothing, 5) (Nothing, 5) (Nothing, 5) `shouldReturn` 0
-      it "version srv " $ testBasicAuth t True (Nothing, 4) (Nothing, 5) (Nothing, 5) `shouldReturn` 2
-      it "version fst " $ testBasicAuth t True (Nothing, 5) (Nothing, 4) (Nothing, 5) `shouldReturn` 2
-      it "version snd " $ testBasicAuth t True (Nothing, 5) (Nothing, 5) (Nothing, 4) `shouldReturn` 2
-      it "version both" $ testBasicAuth t True (Nothing, 5) (Nothing, 4) (Nothing, 4) `shouldReturn` 2
-      it "version all " $ testBasicAuth t True (Nothing, 4) (Nothing, 4) (Nothing, 4) `shouldReturn` 2
-      it "auth fst    " $ testBasicAuth t True (Nothing, 5) (Just "abcd", 5) (Nothing, 5) `shouldReturn` 2
-      it "auth fst 2  " $ testBasicAuth t True (Nothing, 4) (Just "abcd", 5) (Nothing, 5) `shouldReturn` 2
-      it "auth snd    " $ testBasicAuth t True (Nothing, 5) (Nothing, 5) (Just "abcd", 5) `shouldReturn` 2
-      it "auth both   " $ testBasicAuth t True (Nothing, 5) (Just "abcd", 5) (Just "abcd", 5) `shouldReturn` 2
-      it "auth, disabled" $ testBasicAuth t False (Nothing, 5) (Just "abcd", 5) (Just "abcd", 5) `shouldReturn` 0
-  describe "SMP server test via agent API" $ do
-    it "should pass without basic auth" $ testSMPServerConnectionTest t Nothing (noAuthSrv testSMPServer2) `shouldReturn` Nothing
-    let srv1 = testSMPServer2 {keyHash = "1234"}
-    it "should fail with incorrect fingerprint" $ do
-      testSMPServerConnectionTest t Nothing (noAuthSrv srv1) `shouldReturn` Just (SMPTestFailure TSConnect $ BROKER (B.unpack $ strEncode srv1) NETWORK)
-    describe "server with password" $ do
-      let auth = Just "abcd"
-          srv = ProtoServerWithAuth testSMPServer2
-          authErr = Just (SMPTestFailure TSCreateQueue $ SMP AUTH)
-      it "should pass with correct password" $ testSMPServerConnectionTest t auth (srv auth) `shouldReturn` Nothing
-      it "should fail without password" $ testSMPServerConnectionTest t auth (srv Nothing) `shouldReturn` authErr
-      it "should fail with incorrect password" $ testSMPServerConnectionTest t auth (srv $ Just "wrong") `shouldReturn` authErr
-  describe "getRatchetAdHash" $
-    it "should return the same data for both peers" $
-      withSmpServer t testRatchetAdHash
-
-testBasicAuth :: ATransport -> Bool -> (Maybe BasicAuth, Version) -> (Maybe BasicAuth, Version) -> (Maybe BasicAuth, Version) -> IO Int
-testBasicAuth t allowNewQueues srv@(srvAuth, srvVersion) clnt1 clnt2 = do
-  let testCfg = cfg {allowNewQueues, newQueueBasicAuth = srvAuth, smpServerVRange = mkVersionRange 4 srvVersion}
-      canCreate1 = canCreateQueue allowNewQueues srv clnt1
-      canCreate2 = canCreateQueue allowNewQueues srv clnt2
-      expected
-        | canCreate1 && canCreate2 = 2
-        | canCreate1 = 1
-        | otherwise = 0
-  created <- withSmpServerConfigOn t testCfg testPort $ \_ -> testCreateQueueAuth clnt1 clnt2
-  created `shouldBe` expected
-  pure created
-
-canCreateQueue :: Bool -> (Maybe BasicAuth, Version) -> (Maybe BasicAuth, Version) -> Bool
-canCreateQueue allowNew (srvAuth, srvVersion) (clntAuth, clntVersion) =
-  allowNew && (isNothing srvAuth || (srvVersion == 5 && clntVersion == 5 && srvAuth == clntAuth))
-
-testMatrix2 :: ATransport -> (AgentClient -> AgentClient -> AgentMsgId -> IO ()) -> Spec
-testMatrix2 t runTest = do
-  it "v2" $ withSmpServer t $ runTestCfg2 agentCfg agentCfg 3 runTest
-  it "v1" $ withSmpServer t $ runTestCfg2 agentCfgV1 agentCfgV1 4 runTest
-  it "v1 to v2" $ withSmpServer t $ runTestCfg2 agentCfgV1 agentCfg 4 runTest
-  it "v2 to v1" $ withSmpServer t $ runTestCfg2 agentCfg agentCfgV1 4 runTest
-
-testRatchetMatrix2 :: ATransport -> (AgentClient -> AgentClient -> AgentMsgId -> IO ()) -> Spec
-testRatchetMatrix2 t runTest = do
-  it "ratchet v2" $ withSmpServer t $ runTestCfg2 agentCfg agentCfg 3 runTest
-  it "ratchet v1" $ withSmpServer t $ runTestCfg2 agentCfgRatchetV1 agentCfgRatchetV1 3 runTest
-  it "ratchets v1 to v2" $ withSmpServer t $ runTestCfg2 agentCfgRatchetV1 agentCfg 3 runTest
-  it "ratchets v2 to v1" $ withSmpServer t $ runTestCfg2 agentCfg agentCfgRatchetV1 3 runTest
-
-testServerMatrix2 :: ATransport -> (InitialAgentServers -> IO ()) -> Spec
-testServerMatrix2 t runTest = do
-  it "1 server" $ withSmpServer t $ runTest initAgentServers
-  it "2 servers" $ withSmpServer t . withSmpServerOn t testPort2 $ runTest initAgentServers2
-
-runTestCfg2 :: AgentConfig -> AgentConfig -> AgentMsgId -> (AgentClient -> AgentClient -> AgentMsgId -> IO ()) -> IO ()
-runTestCfg2 aliceCfg bobCfg baseMsgId runTest = do
-  alice <- getSMPAgentClient aliceCfg initAgentServers
-  bob <- getSMPAgentClient bobCfg {database = testDB2} initAgentServers
-  runTest alice bob baseMsgId
-
-runAgentClientTest :: AgentClient -> AgentClient -> AgentMsgId -> IO ()
-runAgentClientTest alice bob baseId = do
-  Right () <- runExceptT $ do
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get bob ##> ("", aliceId, CON)
-    -- message IDs 1 to 3 (or 1 to 4 in v1) get assigned to control messages, so first MSG is assigned ID 4
-    1 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "hello"
-    get alice ##> ("", bobId, SENT $ baseId + 1)
-    2 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "how are you?"
-    get alice ##> ("", bobId, SENT $ baseId + 2)
-    get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 1
-    get bob =##> \case ("", c, Msg "how are you?") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 2
-    3 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "hello too"
-    get bob ##> ("", aliceId, SENT $ baseId + 3)
-    4 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 1"
-    get bob ##> ("", aliceId, SENT $ baseId + 4)
-    get alice =##> \case ("", c, Msg "hello too") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 3
-    get alice =##> \case ("", c, Msg "message 1") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 4
-    suspendConnection alice bobId
-    5 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 2"
-    get bob ##> ("", aliceId, MERR (baseId + 5) (SMP AUTH))
-    deleteConnection alice bobId
-    liftIO $ noMessages alice "nothing else should be delivered to alice"
-  pure ()
-  where
-    msgId = subtract baseId
-
-runAgentClientContactTest :: AgentClient -> AgentClient -> AgentMsgId -> IO ()
-runAgentClientContactTest alice bob baseId = do
-  Right () <- runExceptT $ do
-    (_, qInfo) <- createConnection alice True SCMContact Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, REQ invId _ "bob's connInfo") <- get alice
-    bobId <- acceptContact alice True invId "alice's connInfo"
-    ("", _, CONF confId _ "alice's connInfo") <- get bob
-    allowConnection bob aliceId confId "bob's connInfo"
-    get alice ##> ("", bobId, INFO "bob's connInfo")
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, CON)
-    -- message IDs 1 to 3 (or 1 to 4 in v1) get assigned to control messages, so first MSG is assigned ID 4
-    1 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "hello"
-    get alice ##> ("", bobId, SENT $ baseId + 1)
-    2 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "how are you?"
-    get alice ##> ("", bobId, SENT $ baseId + 2)
-    get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 1
-    get bob =##> \case ("", c, Msg "how are you?") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 2
-    3 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "hello too"
-    get bob ##> ("", aliceId, SENT $ baseId + 3)
-    4 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 1"
-    get bob ##> ("", aliceId, SENT $ baseId + 4)
-    get alice =##> \case ("", c, Msg "hello too") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 3
-    get alice =##> \case ("", c, Msg "message 1") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 4
-    suspendConnection alice bobId
-    5 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 2"
-    get bob ##> ("", aliceId, MERR (baseId + 5) (SMP AUTH))
-    deleteConnection alice bobId
-    liftIO $ noMessages alice "nothing else should be delivered to alice"
-  pure ()
-  where
-    msgId = subtract baseId
-
-noMessages :: AgentClient -> String -> Expectation
-noMessages c err = tryGet `shouldReturn` ()
-  where
-    tryGet =
-      10000 `timeout` get c >>= \case
-        Just _ -> error err
-        _ -> return ()
-
-testAsyncInitiatingOffline :: IO ()
-testAsyncInitiatingOffline = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (bobId, cReq) <- createConnection alice True SCMInvitation Nothing
-    disconnectAgentClient alice
-    aliceId <- joinConnection bob True cReq "bob's connInfo"
-    alice' <- liftIO $ getSMPAgentClient agentCfg initAgentServers
-    subscribeConnection alice' bobId
-    ("", _, CONF confId _ "bob's connInfo") <- get alice'
-    allowConnection alice' bobId confId "alice's connInfo"
-    get alice' ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get bob ##> ("", aliceId, CON)
-    exchangeGreetings alice' bobId bob aliceId
-  pure ()
-
-testAsyncJoiningOfflineBeforeActivation :: IO ()
-testAsyncJoiningOfflineBeforeActivation = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    disconnectAgentClient bob
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    bob' <- liftIO $ getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-    subscribeConnection bob' aliceId
-    get alice ##> ("", bobId, CON)
-    get bob' ##> ("", aliceId, INFO "alice's connInfo")
-    get bob' ##> ("", aliceId, CON)
-    exchangeGreetings alice bobId bob' aliceId
-  pure ()
-
-testAsyncBothOffline :: IO ()
-testAsyncBothOffline = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (bobId, cReq) <- createConnection alice True SCMInvitation Nothing
-    disconnectAgentClient alice
-    aliceId <- joinConnection bob True cReq "bob's connInfo"
-    disconnectAgentClient bob
-    alice' <- liftIO $ getSMPAgentClient agentCfg initAgentServers
-    subscribeConnection alice' bobId
-    ("", _, CONF confId _ "bob's connInfo") <- get alice'
-    allowConnection alice' bobId confId "alice's connInfo"
-    bob' <- liftIO $ getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-    subscribeConnection bob' aliceId
-    get alice' ##> ("", bobId, CON)
-    get bob' ##> ("", aliceId, INFO "alice's connInfo")
-    get bob' ##> ("", aliceId, CON)
-    exchangeGreetings alice' bobId bob' aliceId
-  pure ()
-
-testAsyncServerOffline :: ATransport -> IO ()
-testAsyncServerOffline t = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  -- create connection and shutdown the server
-  Right (bobId, cReq) <- withSmpServerStoreLogOn t testPort $ \_ ->
-    runExceptT $ createConnection alice True SCMInvitation Nothing
-  -- connection fails
-  Left (BROKER _ NETWORK) <- runExceptT $ joinConnection bob True cReq "bob's connInfo"
-  ("", "", DOWN srv conns) <- get alice
-  srv `shouldBe` testSMPServer
-  conns `shouldBe` [bobId]
-  -- connection succeeds after server start
-  Right () <- withSmpServerStoreLogOn t testPort $ \_ -> runExceptT $ do
-    ("", "", UP srv1 conns1) <- get alice
-    liftIO $ do
-      srv1 `shouldBe` testSMPServer
-      conns1 `shouldBe` [bobId]
-    aliceId <- joinConnection bob True cReq "bob's connInfo"
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get bob ##> ("", aliceId, CON)
-    exchangeGreetings alice bobId bob aliceId
-  pure ()
-
-testAsyncHelloTimeout :: IO ()
-testAsyncHelloTimeout = do
-  -- this test would only work if any of the agent is v1, there is no HELLO timeout in v2
-  alice <- getSMPAgentClient agentCfgV1 initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2, helloTimeout = 1} initAgentServers
-  Right () <- runExceptT $ do
-    (_, cReq) <- createConnection alice True SCMInvitation Nothing
-    disconnectAgentClient alice
-    aliceId <- joinConnection bob True cReq "bob's connInfo"
-    get bob ##> ("", aliceId, ERR $ CONN NOT_ACCEPTED)
-  pure ()
-
-testDuplicateMessage :: ATransport -> IO ()
-testDuplicateMessage t = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  (aliceId, bobId, bob1) <- withSmpServerStoreMsgLogOn t testPort $ \_ -> do
-    Right (aliceId, bobId) <- runExceptT $ makeConnection alice bob
-    Right () <- runExceptT $ do
-      4 <- sendMessage alice bobId SMP.noMsgFlags "hello"
-      get alice ##> ("", bobId, SENT 4)
-      get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-    disconnectAgentClient bob
-
-    -- if the agent user did not send ACK, the message will be delivered again
-    bob1 <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-    Right () <- runExceptT $ do
-      subscribeConnection bob1 aliceId
-      get bob1 =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-      ackMessage bob1 aliceId 4
-      5 <- sendMessage alice bobId SMP.noMsgFlags "hello 2"
-      get alice ##> ("", bobId, SENT 5)
-      get bob1 =##> \case ("", c, Msg "hello 2") -> c == aliceId; _ -> False
-
-    pure (aliceId, bobId, bob1)
-
-  get alice =##> \case ("", "", DOWN _ [c]) -> c == bobId; _ -> False
-  get bob1 =##> \case ("", "", DOWN _ [c]) -> c == aliceId; _ -> False
-  -- commenting two lines below and uncommenting further two lines would also pass,
-  -- it is the scenario tested above, when the message was not acknowledged by the user
-  threadDelay 200000
-  Left (BROKER _ TIMEOUT) <- runExceptT $ ackMessage bob1 aliceId 5
-
-  disconnectAgentClient alice
-  disconnectAgentClient bob1
-
-  alice2 <- getSMPAgentClient agentCfg initAgentServers
-  bob2 <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-
-  withSmpServerStoreMsgLogOn t testPort $ \_ -> do
-    Right () <- runExceptT $ do
-      subscribeConnection bob2 aliceId
-      subscribeConnection alice2 bobId
-      -- get bob2 =##> \case ("", c, Msg "hello 2") -> c == aliceId; _ -> False
-      -- ackMessage bob2 aliceId 5
-      -- message 2 is not delivered again, even though it was delivered to the agent
-      6 <- sendMessage alice2 bobId SMP.noMsgFlags "hello 3"
-      get alice2 ##> ("", bobId, SENT 6)
-      get bob2 =##> \case ("", c, Msg "hello 3") -> c == aliceId; _ -> False
-    pure ()
-
-makeConnection :: AgentClient -> AgentClient -> ExceptT AgentErrorType IO (ConnId, ConnId)
-makeConnection alice bob = do
-  (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-  aliceId <- joinConnection bob True qInfo "bob's connInfo"
-  ("", _, CONF confId _ "bob's connInfo") <- get alice
-  allowConnection alice bobId confId "alice's connInfo"
-  get alice ##> ("", bobId, CON)
-  get bob ##> ("", aliceId, INFO "alice's connInfo")
-  get bob ##> ("", aliceId, CON)
-  pure (aliceId, bobId)
-
-testInactiveClientDisconnected :: ATransport -> IO ()
-testInactiveClientDisconnected t = do
-  let cfg' = cfg {inactiveClientExpiration = Just ExpirationConfig {ttl = 1, checkInterval = 1}}
-  withSmpServerConfigOn t cfg' testPort $ \_ -> do
-    alice <- getSMPAgentClient agentCfg initAgentServers
-    Right () <- runExceptT $ do
-      (connId, _cReq) <- createConnection alice True SCMInvitation Nothing
-      get alice ##> ("", "", DOWN testSMPServer [connId])
-    pure ()
-
-testActiveClientNotDisconnected :: ATransport -> IO ()
-testActiveClientNotDisconnected t = do
-  let cfg' = cfg {inactiveClientExpiration = Just ExpirationConfig {ttl = 1, checkInterval = 1}}
-  withSmpServerConfigOn t cfg' testPort $ \_ -> do
-    alice <- getSMPAgentClient agentCfg initAgentServers
-    ts <- getSystemTime
-    Right () <- runExceptT $ do
-      (connId, _cReq) <- createConnection alice True SCMInvitation Nothing
-      keepSubscribing alice connId ts
-    pure ()
-  where
-    keepSubscribing :: AgentClient -> ConnId -> SystemTime -> ExceptT AgentErrorType IO ()
-    keepSubscribing alice connId ts = do
-      ts' <- liftIO getSystemTime
-      if milliseconds ts' - milliseconds ts < 2200
-        then do
-          -- keep sending SUB for 2.2 seconds
-          liftIO $ threadDelay 200000
-          subscribeConnection alice connId
-          keepSubscribing alice connId ts
-        else do
-          -- check that nothing is sent from agent
-          Nothing <- 800000 `timeout` get alice
-          liftIO $ threadDelay 1200000
-          -- and after 2 sec of inactivity DOWN is sent
-          get alice ##> ("", "", DOWN testSMPServer [connId])
-    milliseconds ts = systemSeconds ts * 1000 + fromIntegral (systemNanoseconds ts `div` 1000000)
-
-testSuspendingAgent :: IO ()
-testSuspendingAgent = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  b <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    4 <- sendMessage a bId SMP.noMsgFlags "hello"
-    get a ##> ("", bId, SENT 4)
-    get b =##> \case ("", c, Msg "hello") -> c == aId; _ -> False
-    ackMessage b aId 4
-    suspendAgent b 1000000
-    get b ##> ("", "", SUSPENDED)
-    5 <- sendMessage a bId SMP.noMsgFlags "hello 2"
-    get a ##> ("", bId, SENT 5)
-    Nothing <- 100000 `timeout` get b
-    activateAgent b
-    get b =##> \case ("", c, Msg "hello 2") -> c == aId; _ -> False
-  pure ()
-
-testSuspendingAgentCompleteSending :: ATransport -> IO ()
-testSuspendingAgentCompleteSending t = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  b <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (aId, bId) <- withSmpServerStoreLogOn t testPort $ \_ -> runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    4 <- sendMessage a bId SMP.noMsgFlags "hello"
-    get a ##> ("", bId, SENT 4)
-    get b =##> \case ("", c, Msg "hello") -> c == aId; _ -> False
-    ackMessage b aId 4
-    pure (aId, bId)
-
-  Right () <- runExceptT $ do
-    ("", "", DOWN {}) <- get a
-    ("", "", DOWN {}) <- get b
-    5 <- sendMessage b aId SMP.noMsgFlags "hello too"
-    6 <- sendMessage b aId SMP.noMsgFlags "how are you?"
-    liftIO $ threadDelay 100000
-    suspendAgent b 5000000
-
-  Right () <- withSmpServerStoreLogOn t testPort $ \_ -> runExceptT $ do
-    get b =##> \case ("", c, SENT 5) -> c == aId; ("", "", UP {}) -> True; _ -> False
-    get b =##> \case ("", c, SENT 5) -> c == aId; ("", "", UP {}) -> True; _ -> False
-    get b =##> \case ("", c, SENT 6) -> c == aId; ("", "", UP {}) -> True; _ -> False
-    ("", "", SUSPENDED) <- get b
-
-    r <- get a
-    liftIO $ print r
-    ("", "", UP {}) <- pure r
-    get a =##> \case ("", c, Msg "hello too") -> c == bId; _ -> False
-    ackMessage a bId 5
-    get a =##> \case ("", c, Msg "how are you?") -> c == bId; _ -> False
-    ackMessage a bId 6
-
-  pure ()
-
-testSuspendingAgentTimeout :: ATransport -> IO ()
-testSuspendingAgentTimeout t = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  b <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (aId, _) <- withSmpServer t . runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    4 <- sendMessage a bId SMP.noMsgFlags "hello"
-    get a ##> ("", bId, SENT 4)
-    get b =##> \case ("", c, Msg "hello") -> c == aId; _ -> False
-    ackMessage b aId 4
-    pure (aId, bId)
-
-  Right () <- runExceptT $ do
-    ("", "", DOWN {}) <- get a
-    ("", "", DOWN {}) <- get b
-    5 <- sendMessage b aId SMP.noMsgFlags "hello too"
-    6 <- sendMessage b aId SMP.noMsgFlags "how are you?"
-    suspendAgent b 100000
-    ("", "", SUSPENDED) <- get b
-    pure ()
-
-  pure ()
-
-testBatchedSubscriptions :: ATransport -> IO ()
-testBatchedSubscriptions t = do
-  a <- getSMPAgentClient agentCfg initAgentServers2
-  b <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers2
-  Right conns <- runServers $ do
-    conns <- forM [1 .. 200 :: Int] . const $ makeConnection a b
-    forM_ conns $ \(aId, bId) -> exchangeGreetings a bId b aId
-    forM_ (take 10 conns) $ \(aId, bId) -> do
-      deleteConnection a bId
-      deleteConnection b aId
-    liftIO $ threadDelay 1000000
-    pure conns
-  ("", "", DOWN {}) <- get a
-  ("", "", DOWN {}) <- get a
-  ("", "", DOWN {}) <- get b
-  ("", "", DOWN {}) <- get b
-  Right () <- runServers $ do
-    ("", "", UP {}) <- get a
-    ("", "", UP {}) <- get a
-    ("", "", UP {}) <- get b
-    ("", "", UP {}) <- get b
-    liftIO $ threadDelay 1000000
-    subscribe a $ map snd conns
-    subscribe b $ map fst conns
-    forM_ (drop 10 conns) $ \(aId, bId) -> exchangeGreetingsMsgId 6 a bId b aId
-  pure ()
-  where
-    subscribe :: AgentClient -> [ConnId] -> ExceptT AgentErrorType IO ()
-    subscribe c cs = do
-      r <- subscribeConnections c cs
-      liftIO $ do
-        let dc = S.fromList $ take 10 cs
-        all (== Right ()) (M.withoutKeys r dc) `shouldBe` True
-        all (== Left (CONN NOT_FOUND)) (M.restrictKeys r dc) `shouldBe` True
-        M.keys r `shouldMatchList` cs
-    runServers :: ExceptT AgentErrorType IO a -> IO (Either AgentErrorType a)
-    runServers a = do
-      withSmpServerStoreLogOn t testPort $ \t1 -> do
-        res <- withSmpServerConfigOn t cfg {storeLogFile = Just testStoreLogFile2} testPort2 $ \t2 -> do
-          res <- runExceptT a
-          killThread t2
-          pure res
-        killThread t1
-        pure res
-
-testAsyncCommands :: IO ()
-testAsyncCommands = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    bobId <- createConnectionAsync alice "1" True SCMInvitation
-    ("1", bobId', INV (ACR _ qInfo)) <- get alice
-    liftIO $ bobId' `shouldBe` bobId
-    aliceId <- joinConnectionAsync bob "2" True qInfo "bob's connInfo"
-    ("2", aliceId', OK) <- get bob
-    liftIO $ aliceId' `shouldBe` aliceId
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnectionAsync alice "3" bobId confId "alice's connInfo"
-    ("3", _, OK) <- get alice
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get bob ##> ("", aliceId, CON)
-    -- message IDs 1 to 3 get assigned to control messages, so first MSG is assigned ID 4
-    1 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "hello"
-    get alice ##> ("", bobId, SENT $ baseId + 1)
-    2 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "how are you?"
-    get alice ##> ("", bobId, SENT $ baseId + 2)
-    get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-    ackMessageAsync bob "4" aliceId $ baseId + 1
-    ("4", _, OK) <- get bob
-    get bob =##> \case ("", c, Msg "how are you?") -> c == aliceId; _ -> False
-    ackMessageAsync bob "5" aliceId $ baseId + 2
-    ("5", _, OK) <- get bob
-    3 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "hello too"
-    get bob ##> ("", aliceId, SENT $ baseId + 3)
-    4 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 1"
-    get bob ##> ("", aliceId, SENT $ baseId + 4)
-    get alice =##> \case ("", c, Msg "hello too") -> c == bobId; _ -> False
-    ackMessageAsync alice "6" bobId $ baseId + 3
-    ("6", _, OK) <- get alice
-    get alice =##> \case ("", c, Msg "message 1") -> c == bobId; _ -> False
-    ackMessageAsync alice "7" bobId $ baseId + 4
-    ("7", _, OK) <- get alice
-    deleteConnectionAsync alice "8" bobId
-    ("8", _, OK) <- get alice
-    liftIO $ noMessages alice "nothing else should be delivered to alice"
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-testAsyncCommandsRestore :: ATransport -> IO ()
-testAsyncCommandsRestore t = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  Right bobId <- runExceptT $ createConnectionAsync alice "1" True SCMInvitation
-  liftIO $ noMessages alice "alice doesn't receive INV because server is down"
-  disconnectAgentClient alice
-  alice' <- liftIO $ getSMPAgentClient agentCfg initAgentServers
-  withSmpServerStoreLogOn t testPort $ \_ -> do
-    Right () <- runExceptT $ do
-      subscribeConnection alice' bobId
-      ("1", _, INV _) <- get alice'
-      pure ()
-    pure ()
-
-testAcceptContactAsync :: IO ()
-testAcceptContactAsync = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (_, qInfo) <- createConnection alice True SCMContact Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, REQ invId _ "bob's connInfo") <- get alice
-    bobId <- acceptContactAsync alice "1" True invId "alice's connInfo"
-    ("1", bobId', OK) <- get alice
-    liftIO $ bobId' `shouldBe` bobId
-    ("", _, CONF confId _ "alice's connInfo") <- get bob
-    allowConnection bob aliceId confId "bob's connInfo"
-    get alice ##> ("", bobId, INFO "bob's connInfo")
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, CON)
-    -- message IDs 1 to 3 (or 1 to 4 in v1) get assigned to control messages, so first MSG is assigned ID 4
-    1 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "hello"
-    get alice ##> ("", bobId, SENT $ baseId + 1)
-    2 <- msgId <$> sendMessage alice bobId SMP.noMsgFlags "how are you?"
-    get alice ##> ("", bobId, SENT $ baseId + 2)
-    get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 1
-    get bob =##> \case ("", c, Msg "how are you?") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 2
-    3 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "hello too"
-    get bob ##> ("", aliceId, SENT $ baseId + 3)
-    4 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 1"
-    get bob ##> ("", aliceId, SENT $ baseId + 4)
-    get alice =##> \case ("", c, Msg "hello too") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 3
-    get alice =##> \case ("", c, Msg "message 1") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 4
-    suspendConnection alice bobId
-    5 <- msgId <$> sendMessage bob aliceId SMP.noMsgFlags "message 2"
-    get bob ##> ("", aliceId, MERR (baseId + 5) (SMP AUTH))
-    deleteConnection alice bobId
-    liftIO $ noMessages alice "nothing else should be delivered to alice"
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-testSwitchConnection :: InitialAgentServers -> IO ()
-testSwitchConnection servers = do
-  a <- getSMPAgentClient agentCfg servers
-  b <- getSMPAgentClient agentCfg {database = testDB2, initialClientId = 1} servers
-  Right () <- runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    exchangeGreetingsMsgId 4 a bId b aId
-    switchConnectionAsync a "" bId
-    switchComplete a bId b aId
-    exchangeGreetingsMsgId 10 a bId b aId
-  pure ()
-
-switchComplete :: AgentClient -> ByteString -> AgentClient -> ByteString -> ExceptT AgentErrorType IO ()
-switchComplete a bId b aId = do
-  phase a bId QDRcv SPStarted
-  phase b aId QDSnd SPStarted
-  phase a bId QDRcv SPConfirmed
-  phase b aId QDSnd SPConfirmed
-  phase b aId QDSnd SPCompleted
-  phase a bId QDRcv SPCompleted
-
-phase :: AgentClient -> ByteString -> QueueDirection -> SwitchPhase -> ExceptT AgentErrorType IO ()
-phase c connId d p =
-  get c >>= \(_, connId', msg) -> do
-    liftIO $ connId `shouldBe` connId'
-    case msg of
-      SWITCH d' p' _ -> liftIO $ do
-        d `shouldBe` d'
-        p `shouldBe` p'
-      ERR (AGENT A_DUPLICATE) -> phase c connId d p
-      r -> do
-        liftIO . putStrLn $ "expected: " <> show p <> ", received: " <> show r
-        SWITCH _ _ _ <- pure r
-        pure ()
-
-testSwitchAsync :: InitialAgentServers -> IO ()
-testSwitchAsync servers = do
-  Right (aId, bId) <- withA $ \a -> withB $ \b -> runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    exchangeGreetingsMsgId 4 a bId b aId
-    pure (aId, bId)
-  let withA' = session withA bId
-      withB' = session withB aId
-  withA' $ \a -> do
-    switchConnectionAsync a "" bId
-    phase a bId QDRcv SPStarted
-  withB' $ \b -> phase b aId QDSnd SPStarted
-  withA' $ \a -> phase a bId QDRcv SPConfirmed
-  withB' $ \b -> do
-    phase b aId QDSnd SPConfirmed
-    phase b aId QDSnd SPCompleted
-  withA' $ \a -> phase a bId QDRcv SPCompleted
-  Right () <- withA $ \a -> withB $ \b -> runExceptT $ do
-    subscribeConnection a bId
-    subscribeConnection b aId
-    exchangeGreetingsMsgId 10 a bId b aId
-  pure ()
-  where
-    withAgent :: AgentConfig -> (AgentClient -> IO a) -> IO a
-    withAgent cfg' = bracket (getSMPAgentClient cfg' servers) disconnectAgentClient
-    session :: (forall a. (AgentClient -> IO a) -> IO a) -> ConnId -> (AgentClient -> ExceptT AgentErrorType IO ()) -> IO ()
-    session withC connId a = do
-      Right () <- withC $ \c -> runExceptT $ do
-        subscribeConnection c connId
-        r <- a c
-        liftIO $ threadDelay 500000
-        pure r
-      pure ()
-    withA = withAgent agentCfg
-    withB = withAgent agentCfg {database = testDB2, initialClientId = 1}
-
-testSwitchDelete :: InitialAgentServers -> IO ()
-testSwitchDelete servers = do
-  a <- getSMPAgentClient agentCfg servers
-  b <- getSMPAgentClient agentCfg {database = testDB2, initialClientId = 1} servers
-  Right () <- runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    exchangeGreetingsMsgId 4 a bId b aId
-    disconnectAgentClient b
-    switchConnectionAsync a "" bId
-    phase a bId QDRcv SPStarted
-    deleteConnectionAsync a "1" bId
-    ("1", bId', OK) <- get a
-    liftIO $ bId `shouldBe` bId'
-  pure ()
-
-testCreateQueueAuth :: (Maybe BasicAuth, Version) -> (Maybe BasicAuth, Version) -> IO Int
-testCreateQueueAuth clnt1 clnt2 = do
-  a <- getClient clnt1
-  b <- getClient clnt2
-  Right created <- runExceptT $ do
-    tryError (createConnection a True SCMInvitation Nothing) >>= \case
-      Left (SMP AUTH) -> pure 0
-      Left e -> throwError e
-      Right (bId, qInfo) ->
-        tryError (joinConnection b True qInfo "bob's connInfo") >>= \case
-          Left (SMP AUTH) -> pure 1
-          Left e -> throwError e
-          Right aId -> do
-            ("", _, CONF confId _ "bob's connInfo") <- get a
-            allowConnection a bId confId "alice's connInfo"
-            get a ##> ("", bId, CON)
-            get b ##> ("", aId, INFO "alice's connInfo")
-            get b ##> ("", aId, CON)
-            exchangeGreetings a bId b aId
-            pure 2
-  pure created
-  where
-    getClient (clntAuth, clntVersion) =
-      let servers = initAgentServers {smp = [ProtoServerWithAuth testSMPServer clntAuth]}
-          smpCfg = (defaultClientConfig :: ProtocolClientConfig) {smpServerVRange = mkVersionRange 4 clntVersion}
-       in getSMPAgentClient agentCfg {smpCfg} servers
-
-testSMPServerConnectionTest :: ATransport -> Maybe BasicAuth -> SMPServerWithAuth -> IO (Maybe SMPTestFailure)
-testSMPServerConnectionTest t newQueueBasicAuth srv =
-  withSmpServerConfigOn t cfg {newQueueBasicAuth} testPort2 $ \_ -> do
-    a <- getSMPAgentClient agentCfg initAgentServers -- initially passed server is not running
-    Right r <- runExceptT $ testSMPServerConnection a srv
-    pure r
-
-testRatchetAdHash :: IO ()
-testRatchetAdHash = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  b <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    ad1 <- getConnectionRatchetAdHash a bId
-    ad2 <- getConnectionRatchetAdHash b aId
-    liftIO $ ad1 `shouldBe` ad2
-  pure ()
-
-exchangeGreetings :: AgentClient -> ConnId -> AgentClient -> ConnId -> ExceptT AgentErrorType IO ()
-exchangeGreetings = exchangeGreetingsMsgId 4
-
-exchangeGreetingsMsgId :: Int64 -> AgentClient -> ConnId -> AgentClient -> ConnId -> ExceptT AgentErrorType IO ()
-exchangeGreetingsMsgId msgId alice bobId bob aliceId = do
-  msgId1 <- sendMessage alice bobId SMP.noMsgFlags "hello"
-  liftIO $ msgId1 `shouldBe` msgId
-  get alice ##> ("", bobId, SENT msgId)
-  get bob =##> \case ("", c, Msg "hello") -> c == aliceId; _ -> False
-  ackMessage bob aliceId msgId
-  msgId2 <- sendMessage bob aliceId SMP.noMsgFlags "hello too"
-  let msgId' = msgId + 1
-  liftIO $ msgId2 `shouldBe` msgId'
-  get bob ##> ("", aliceId, SENT msgId')
-  get alice =##> \case ("", c, Msg "hello too") -> c == bobId; _ -> False
-  ackMessage alice bobId msgId'
diff --git a/source/tests/AgentTests/NotificationTests.hs b/source/tests/AgentTests/NotificationTests.hs
deleted file mode 100644
index d340a35..0000000
--- a/source/tests/AgentTests/NotificationTests.hs
+++ /dev/null
@@ -1,535 +0,0 @@
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}
-
-module AgentTests.NotificationTests where
-
--- import Control.Logger.Simple (LogConfig (..), LogLevel (..), setLogLevel, withGlobalLogging)
-import AgentTests.FunctionalAPITests (exchangeGreetingsMsgId, get, makeConnection, switchComplete, testServerMatrix2, (##>), (=##>), pattern Msg)
-import Control.Concurrent (killThread, threadDelay)
-import Control.Monad.Except
-import qualified Data.Aeson as J
-import qualified Data.Aeson.Types as JT
-import Data.Bifunctor (bimap, first)
-import qualified Data.ByteString.Base64.URL as U
-import Data.ByteString.Char8 (ByteString)
-import Data.Text.Encoding (encodeUtf8)
-import NtfClient
-import SMPAgentClient (agentCfg, initAgentServers, testDB, testDB2)
-import SMPClient (testPort, withSmpServer, withSmpServerStoreLogOn)
-import Simplex.Messaging.Agent
-import Simplex.Messaging.Agent.Env.SQLite (AgentConfig (..), InitialAgentServers, databaseFile)
-import Simplex.Messaging.Agent.Protocol
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Notifications.Protocol
-import Simplex.Messaging.Notifications.Server.Push.APNS
-import Simplex.Messaging.Notifications.Types (NtfToken (..))
-import Simplex.Messaging.Protocol (ErrorType (AUTH), MsgFlags (MsgFlags), SMPMsgMeta (..))
-import qualified Simplex.Messaging.Protocol as SMP
-import Simplex.Messaging.Transport (ATransport)
-import Simplex.Messaging.Util (tryE)
-import System.Directory (doesFileExist, removeFile)
-import Test.Hspec
-import UnliftIO
-
-removeFileIfExists :: FilePath -> IO ()
-removeFileIfExists filePath = do
-  fileExists <- doesFileExist filePath
-  when fileExists $ removeFile filePath
-
-notificationTests :: ATransport -> Spec
-notificationTests t =
-  after_ (removeFile (databaseFile testDB) >> removeFileIfExists (databaseFile testDB2)) $ do
-    describe "Managing notification tokens" $ do
-      it "should register and verify notification token" $
-        withAPNSMockServer $ \apns ->
-          withNtfServer t $ testNotificationToken apns
-      it "should allow repeated registration with the same credentials" $ \_ ->
-        withAPNSMockServer $ \apns ->
-          withNtfServer t $ testNtfTokenRepeatRegistration apns
-      it "should allow the second registration with different credentials and delete the first after verification" $ \_ ->
-        withAPNSMockServer $ \apns ->
-          withNtfServer t $ testNtfTokenSecondRegistration apns
-      it "should re-register token when notification server is restarted" $ \_ ->
-        withAPNSMockServer $ \apns ->
-          testNtfTokenServerRestart t apns
-    describe "Managing notification subscriptions" $ do
-      it "should create notification subscription for existing connection" $ \_ ->
-        withSmpServer t $
-          withAPNSMockServer $ \apns ->
-            withNtfServer t $ testNotificationSubscriptionExistingConnection apns
-      it "should create notification subscription for new connection" $ \_ ->
-        withSmpServer t $
-          withAPNSMockServer $ \apns ->
-            withNtfServer t $ testNotificationSubscriptionNewConnection apns
-      it "should change notifications mode" $ \_ ->
-        withSmpServer t $
-          withAPNSMockServer $ \apns ->
-            withNtfServer t $ testChangeNotificationsMode apns
-      it "should change token" $ \_ ->
-        withSmpServer t $
-          withAPNSMockServer $ \apns ->
-            withNtfServer t $ testChangeToken apns
-    describe "Notifications server store log" $
-      it "should save and restore tokens and subscriptions" $ \_ ->
-        withSmpServer t $
-          withAPNSMockServer $ \apns ->
-            testNotificationsStoreLog t apns
-    describe "Notifications after SMP server restart" $
-      it "should resume subscriptions after SMP server is restarted" $ \_ ->
-        withAPNSMockServer $ \apns ->
-          withNtfServer t $ testNotificationsSMPRestart t apns
-    describe "should switch notifications to the new queue" $
-      testServerMatrix2 t $ \servers ->
-        withAPNSMockServer $ \apns ->
-          withNtfServer t $ testSwitchNotifications servers apns
-
-testNotificationToken :: APNSMockServer -> IO ()
-testNotificationToken APNSMockServer {apnsQ} = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  Right () <- runExceptT $ do
-    let tkn = DeviceToken PPApnsTest "abcd"
-    NTRegistered <- registerNtfToken a tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse} <-
-      atomically $ readTBQueue apnsQ
-    verification <- ntfData .-> "verification"
-    nonce <- C.cbNonce <$> ntfData .-> "nonce"
-    liftIO $ sendApnsResponse APNSRespOk
-    verifyNtfToken a tkn nonce verification
-    NTActive <- checkNtfToken a tkn
-    deleteNtfToken a tkn
-    -- agent deleted this token
-    Left (CMD PROHIBITED) <- tryE $ checkNtfToken a tkn
-    pure ()
-  pure ()
-
-(.->) :: J.Value -> J.Key -> ExceptT AgentErrorType IO ByteString
-v .-> key = do
-  J.Object o <- pure v
-  liftEither . bimap INTERNAL (U.decodeLenient . encodeUtf8) $ JT.parseEither (J..: key) o
-
--- logCfg :: LogConfig
--- logCfg = LogConfig {lc_file = Nothing, lc_stderr = True}
-
-testNtfTokenRepeatRegistration :: APNSMockServer -> IO ()
-testNtfTokenRepeatRegistration APNSMockServer {apnsQ} = do
-  -- setLogLevel LogError -- LogDebug
-  -- withGlobalLogging logCfg $ do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  Right () <- runExceptT $ do
-    let tkn = DeviceToken PPApnsTest "abcd"
-    NTRegistered <- registerNtfToken a tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse} <-
-      atomically $ readTBQueue apnsQ
-    verification <- ntfData .-> "verification"
-    nonce <- C.cbNonce <$> ntfData .-> "nonce"
-    liftIO $ sendApnsResponse APNSRespOk
-    NTRegistered <- registerNtfToken a tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData'}, sendApnsResponse = sendApnsResponse'} <-
-      atomically $ readTBQueue apnsQ
-    _ <- ntfData' .-> "verification"
-    _ <- C.cbNonce <$> ntfData' .-> "nonce"
-    liftIO $ sendApnsResponse' APNSRespOk
-    -- can still use the first verification code, it is the same after decryption
-    verifyNtfToken a tkn nonce verification
-    NTActive <- checkNtfToken a tkn
-    pure ()
-  pure ()
-
-testNtfTokenSecondRegistration :: APNSMockServer -> IO ()
-testNtfTokenSecondRegistration APNSMockServer {apnsQ} = do
-  -- setLogLevel LogError -- LogDebug
-  -- withGlobalLogging logCfg $ do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  a' <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    let tkn = DeviceToken PPApnsTest "abcd"
-    NTRegistered <- registerNtfToken a tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse} <-
-      atomically $ readTBQueue apnsQ
-    verification <- ntfData .-> "verification"
-    nonce <- C.cbNonce <$> ntfData .-> "nonce"
-    liftIO $ sendApnsResponse APNSRespOk
-    verifyNtfToken a tkn nonce verification
-
-    NTRegistered <- registerNtfToken a' tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData'}, sendApnsResponse = sendApnsResponse'} <-
-      atomically $ readTBQueue apnsQ
-    verification' <- ntfData' .-> "verification"
-    nonce' <- C.cbNonce <$> ntfData' .-> "nonce"
-    liftIO $ sendApnsResponse' APNSRespOk
-
-    -- at this point the first token is still active
-    NTActive <- checkNtfToken a tkn
-    -- and the second is not yet verified
-    liftIO $ threadDelay 50000
-    NTConfirmed <- checkNtfToken a' tkn
-    -- now the second token registration is verified
-    verifyNtfToken a' tkn nonce' verification'
-    -- the first registration is removed
-    Left (NTF AUTH) <- tryE $ checkNtfToken a tkn
-    -- and the second is active
-    NTActive <- checkNtfToken a' tkn
-    pure ()
-  pure ()
-
-testNtfTokenServerRestart :: ATransport -> APNSMockServer -> IO ()
-testNtfTokenServerRestart t APNSMockServer {apnsQ} = do
-  a <- getSMPAgentClient agentCfg initAgentServers
-  let tkn = DeviceToken PPApnsTest "abcd"
-  Right ntfData <- withNtfServer t . runExceptT $ do
-    NTRegistered <- registerNtfToken a tkn NMPeriodic
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse} <-
-      atomically $ readTBQueue apnsQ
-    liftIO $ sendApnsResponse APNSRespOk
-    pure ntfData
-  -- the new agent is created as otherwise when running the tests in CI the old agent was keeping the connection to the server
-  threadDelay 1000000
-  disconnectAgentClient a
-  a' <- getSMPAgentClient agentCfg initAgentServers
-  -- server stopped before token is verified, so now the attempt to verify it will return AUTH error but re-register token,
-  -- so that repeat verification happens without restarting the clients, when notification arrives
-  Right () <- withNtfServer t . runExceptT $ do
-    verification <- ntfData .-> "verification"
-    nonce <- C.cbNonce <$> ntfData .-> "nonce"
-    Left (NTF AUTH) <- tryE $ verifyNtfToken a' tkn nonce verification
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData'}, sendApnsResponse = sendApnsResponse'} <-
-      atomically $ readTBQueue apnsQ
-    verification' <- ntfData' .-> "verification"
-    nonce' <- C.cbNonce <$> ntfData' .-> "nonce"
-    liftIO $ sendApnsResponse' APNSRespOk
-    verifyNtfToken a' tkn nonce' verification'
-    NTActive <- checkNtfToken a' tkn
-    pure ()
-  pure ()
-
-testNotificationSubscriptionExistingConnection :: APNSMockServer -> IO ()
-testNotificationSubscriptionExistingConnection APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (bobId, aliceId, nonce, message) <- runExceptT $ do
-    -- establish connection
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, CON)
-    -- register notification token
-    let tkn = DeviceToken PPApnsTest "abcd"
-    NTRegistered <- registerNtfToken alice tkn NMInstant
-    APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse} <-
-      atomically $ readTBQueue apnsQ
-    verification <- ntfData .-> "verification"
-    vNonce <- C.cbNonce <$> ntfData .-> "nonce"
-    liftIO $ sendApnsResponse APNSRespOk
-    verifyNtfToken alice tkn vNonce verification
-    NTActive <- checkNtfToken alice tkn
-    -- send message
-    liftIO $ threadDelay 50000
-    1 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT $ baseId + 1)
-    -- notification
-    (nonce, message) <- messageNotification apnsQ
-    pure (bobId, aliceId, nonce, message)
-
-  -- alice client already has subscription for the connection
-  Left (CMD PROHIBITED) <- runExceptT $ getNotificationMessage alice nonce message
-
-  -- aliceNtf client doesn't have subscription and is allowed to get notification message
-  aliceNtf <- getSMPAgentClient agentCfg initAgentServers
-  Right () <- runExceptT $ do
-    (_, [SMPMsgMeta {msgFlags = MsgFlags True}]) <- getNotificationMessage aliceNtf nonce message
-    pure ()
-  disconnectAgentClient aliceNtf
-
-  Right () <- runExceptT $ do
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 1
-    -- delete notification subscription
-    toggleConnectionNtfs alice bobId False
-    liftIO $ threadDelay 250000
-    -- send message
-    2 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello again"
-    get bob ##> ("", aliceId, SENT $ baseId + 2)
-    -- no notifications should follow
-    noNotification apnsQ
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-testNotificationSubscriptionNewConnection :: APNSMockServer -> IO ()
-testNotificationSubscriptionNewConnection APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    -- alice registers notification token
-    DeviceToken {} <- registerTestToken alice "abcd" NMInstant apnsQ
-    -- bob registers notification token
-    DeviceToken {} <- registerTestToken bob "bcde" NMInstant apnsQ
-    -- establish connection
-    liftIO $ threadDelay 50000
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    liftIO $ threadDelay 1000000
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    liftIO $ threadDelay 750000
-    void $ messageNotification apnsQ
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    liftIO $ threadDelay 500000
-    allowConnection alice bobId confId "alice's connInfo"
-    void $ messageNotification apnsQ
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    void $ messageNotification apnsQ
-    get alice ##> ("", bobId, CON)
-    void $ messageNotification apnsQ
-    get bob ##> ("", aliceId, CON)
-    -- bob sends message
-    1 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT $ baseId + 1)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 1
-    -- alice sends message
-    2 <- msgId <$> sendMessage alice bobId (SMP.MsgFlags True) "hey there"
-    get alice ##> ("", bobId, SENT $ baseId + 2)
-    void $ messageNotification apnsQ
-    get bob =##> \case ("", c, Msg "hey there") -> c == aliceId; _ -> False
-    ackMessage bob aliceId $ baseId + 2
-    -- no unexpected notifications should follow
-    noNotification apnsQ
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-registerTestToken :: AgentClient -> ByteString -> NotificationsMode -> TBQueue APNSMockRequest -> ExceptT AgentErrorType IO DeviceToken
-registerTestToken a token mode apnsQ = do
-  let tkn = DeviceToken PPApnsTest token
-  NTRegistered <- registerNtfToken a tkn mode
-  APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData'}, sendApnsResponse = sendApnsResponse'} <-
-    atomically $ readTBQueue apnsQ
-  verification' <- ntfData' .-> "verification"
-  nonce' <- C.cbNonce <$> ntfData' .-> "nonce"
-  liftIO $ sendApnsResponse' APNSRespOk
-  verifyNtfToken a tkn nonce' verification'
-  NTActive <- checkNtfToken a tkn
-  pure tkn
-
-testChangeNotificationsMode :: APNSMockServer -> IO ()
-testChangeNotificationsMode APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right () <- runExceptT $ do
-    -- establish connection
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, CON)
-    -- register notification token, set mode to NMInstant
-    tkn <- registerTestToken alice "abcd" NMInstant apnsQ
-    -- send message, receive notification
-    liftIO $ threadDelay 500000
-    1 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT $ baseId + 1)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 1
-    -- set mode to NMPeriodic
-    NTActive <- registerNtfToken alice tkn NMPeriodic
-    -- send message, no notification
-    liftIO $ threadDelay 750000
-    2 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello again"
-    get bob ##> ("", aliceId, SENT $ baseId + 2)
-    noNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello again") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 2
-    -- set mode to NMInstant
-    NTActive <- registerNtfToken alice tkn NMInstant
-    -- send message, receive notification
-    liftIO $ threadDelay 500000
-    3 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello there"
-    get bob ##> ("", aliceId, SENT $ baseId + 3)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello there") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 3
-    -- turn off notifications
-    deleteNtfToken alice tkn
-    -- send message, no notification
-    liftIO $ threadDelay 500000
-    4 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "why hello there"
-    get bob ##> ("", aliceId, SENT $ baseId + 4)
-    noNotification apnsQ
-    get alice =##> \case ("", c, Msg "why hello there") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 4
-    -- turn on notifications, set mode to NMInstant
-    void $ registerTestToken alice "abcd" NMInstant apnsQ
-    -- send message, receive notification
-    liftIO $ threadDelay 500000
-    5 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hey"
-    get bob ##> ("", aliceId, SENT $ baseId + 5)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hey") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 5
-    -- no notifications should follow
-    noNotification apnsQ
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-testChangeToken :: APNSMockServer -> IO ()
-testChangeToken APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (aliceId, bobId) <- runExceptT $ do
-    -- establish connection
-    (bobId, qInfo) <- createConnection alice True SCMInvitation Nothing
-    aliceId <- joinConnection bob True qInfo "bob's connInfo"
-    ("", _, CONF confId _ "bob's connInfo") <- get alice
-    allowConnection alice bobId confId "alice's connInfo"
-    get bob ##> ("", aliceId, INFO "alice's connInfo")
-    get alice ##> ("", bobId, CON)
-    get bob ##> ("", aliceId, CON)
-    -- register notification token, set mode to NMInstant
-    void $ registerTestToken alice "abcd" NMInstant apnsQ
-    -- send message, receive notification
-    liftIO $ threadDelay 500000
-    1 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT $ baseId + 1)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId $ baseId + 1
-    pure (aliceId, bobId)
-  disconnectAgentClient alice
-
-  alice1 <- getSMPAgentClient agentCfg initAgentServers
-  Right () <- runExceptT $ do
-    subscribeConnection alice1 bobId
-    -- change notification token
-    void $ registerTestToken alice1 "bcde" NMInstant apnsQ
-    -- send message, receive notification
-    liftIO $ threadDelay 500000
-    2 <- msgId <$> sendMessage bob aliceId (SMP.MsgFlags True) "hello there"
-    get bob ##> ("", aliceId, SENT $ baseId + 2)
-    void $ messageNotification apnsQ
-    get alice1 =##> \case ("", c, Msg "hello there") -> c == bobId; _ -> False
-    ackMessage alice1 bobId $ baseId + 2
-    -- no notifications should follow
-    noNotification apnsQ
-  pure ()
-  where
-    baseId = 3
-    msgId = subtract baseId
-
-testNotificationsStoreLog :: ATransport -> APNSMockServer -> IO ()
-testNotificationsStoreLog t APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (aliceId, bobId) <- withNtfServerStoreLog t $ \threadId -> runExceptT $ do
-    (aliceId, bobId) <- makeConnection alice bob
-    _ <- registerTestToken alice "abcd" NMInstant apnsQ
-    liftIO $ threadDelay 250000
-    4 <- sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT 4)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId 4
-    liftIO $ killThread threadId
-    pure (aliceId, bobId)
-
-  liftIO $ threadDelay 250000
-
-  Right () <- withNtfServerStoreLog t $ \threadId -> runExceptT $ do
-    liftIO $ threadDelay 250000
-    5 <- sendMessage bob aliceId (SMP.MsgFlags True) "hello again"
-    get bob ##> ("", aliceId, SENT 5)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello again") -> c == bobId; _ -> False
-    liftIO $ killThread threadId
-  pure ()
-
-testNotificationsSMPRestart :: ATransport -> APNSMockServer -> IO ()
-testNotificationsSMPRestart t APNSMockServer {apnsQ} = do
-  alice <- getSMPAgentClient agentCfg initAgentServers
-  bob <- getSMPAgentClient agentCfg {database = testDB2} initAgentServers
-  Right (aliceId, bobId) <- withSmpServerStoreLogOn t testPort $ \threadId -> runExceptT $ do
-    (aliceId, bobId) <- makeConnection alice bob
-    _ <- registerTestToken alice "abcd" NMInstant apnsQ
-    liftIO $ threadDelay 250000
-    4 <- sendMessage bob aliceId (SMP.MsgFlags True) "hello"
-    get bob ##> ("", aliceId, SENT 4)
-    void $ messageNotification apnsQ
-    get alice =##> \case ("", c, Msg "hello") -> c == bobId; _ -> False
-    ackMessage alice bobId 4
-    liftIO $ killThread threadId
-    pure (aliceId, bobId)
-
-  Right () <- runExceptT $ do
-    get alice =##> \case ("", "", DOWN _ [c]) -> c == bobId; _ -> False
-    get bob =##> \case ("", "", DOWN _ [c]) -> c == aliceId; _ -> False
-
-  Right () <- withSmpServerStoreLogOn t testPort $ \threadId -> runExceptT $ do
-    get alice =##> \case ("", "", UP _ [c]) -> c == bobId; _ -> False
-    get bob =##> \case ("", "", UP _ [c]) -> c == aliceId; _ -> False
-    liftIO $ threadDelay 1000000
-    5 <- sendMessage bob aliceId (SMP.MsgFlags True) "hello again"
-    get bob ##> ("", aliceId, SENT 5)
-    _ <- messageNotificationData alice apnsQ
-    get alice =##> \case ("", c, Msg "hello again") -> c == bobId; _ -> False
-    liftIO $ killThread threadId
-  pure ()
-
-testSwitchNotifications :: InitialAgentServers -> APNSMockServer -> IO ()
-testSwitchNotifications servers APNSMockServer {apnsQ} = do
-  a <- getSMPAgentClient agentCfg servers
-  b <- getSMPAgentClient agentCfg {database = testDB2, initialClientId = 1} servers
-  Right () <- runExceptT $ do
-    (aId, bId) <- makeConnection a b
-    exchangeGreetingsMsgId 4 a bId b aId
-    _ <- registerTestToken a "abcd" NMInstant apnsQ
-    liftIO $ threadDelay 250000
-    let testMessage msg = do
-          msgId <- sendMessage b aId (SMP.MsgFlags True) msg
-          get b ##> ("", aId, SENT msgId)
-          void $ messageNotification apnsQ
-          get a =##> \case ("", c, Msg msg') -> c == bId && msg == msg'; _ -> False
-          ackMessage a bId msgId
-    testMessage "hello"
-    switchConnectionAsync a "" bId
-    switchComplete a bId b aId
-    liftIO $ threadDelay 500000
-    testMessage "hello again"
-  pure ()
-
-messageNotification :: TBQueue APNSMockRequest -> ExceptT AgentErrorType IO (C.CbNonce, ByteString)
-messageNotification apnsQ = do
-  750000 `timeout` atomically (readTBQueue apnsQ) >>= \case
-    Nothing -> error "no notification"
-    Just APNSMockRequest {notification = APNSNotification {aps = APNSMutableContent {}, notificationData = Just ntfData}, sendApnsResponse} -> do
-      nonce <- C.cbNonce <$> ntfData .-> "nonce"
-      message <- ntfData .-> "message"
-      liftIO $ sendApnsResponse APNSRespOk
-      pure (nonce, message)
-    _ -> error "bad notification"
-
-messageNotificationData :: AgentClient -> TBQueue APNSMockRequest -> ExceptT AgentErrorType IO PNMessageData
-messageNotificationData c apnsQ = do
-  (nonce, message) <- messageNotification apnsQ
-  NtfToken {ntfDhSecret = Just dhSecret} <- getNtfTokenData c
-  Right pnMsgData <- liftEither . first INTERNAL $ Right . strDecode =<< first show (C.cbDecrypt dhSecret nonce message)
-  pure pnMsgData
-
-noNotification :: TBQueue APNSMockRequest -> ExceptT AgentErrorType IO ()
-noNotification apnsQ = do
-  500000 `timeout` atomically (readTBQueue apnsQ) >>= \case
-    Nothing -> pure ()
-    _ -> error "unexpected notification"
diff --git a/source/tests/AgentTests/SQLiteTests.hs b/source/tests/AgentTests/SQLiteTests.hs
deleted file mode 100644
index 0720214..0000000
--- a/source/tests/AgentTests/SQLiteTests.hs
+++ /dev/null
@@ -1,495 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE QuasiQuotes #-}
-{-# LANGUAGE RecordWildCards #-}
-
-module AgentTests.SQLiteTests (storeTests) where
-
-import Control.Concurrent.Async (concurrently_)
-import Control.Concurrent.STM
-import Control.Monad (replicateM_)
-import Crypto.Random (drgNew)
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.Text as T
-import Data.Text.Encoding (encodeUtf8)
-import Data.Time
-import Data.Word (Word32)
-import qualified Database.SQLite.Simple as DB
-import Database.SQLite.Simple.QQ (sql)
-import SMPClient (testKeyHash)
-import Simplex.Messaging.Agent.Client ()
-import Simplex.Messaging.Agent.Protocol
-import Simplex.Messaging.Agent.Store
-import Simplex.Messaging.Agent.Store.SQLite
-import qualified Simplex.Messaging.Agent.Store.SQLite.Migrations as Migrations
-import qualified Simplex.Messaging.Crypto as C
-import qualified Simplex.Messaging.Protocol as SMP
-import System.Random
-import Test.Hspec
-import UnliftIO.Directory (removeFile)
-
-testDB :: String
-testDB = "tests/tmp/smp-agent.test.db"
-
-withStore :: SpecWith SQLiteStore -> Spec
-withStore = before createStore . after removeStore
-
-withStore2 :: SpecWith (SQLiteStore, SQLiteStore) -> Spec
-withStore2 = before connect2 . after (removeStore . fst)
-  where
-    connect2 :: IO (SQLiteStore, SQLiteStore)
-    connect2 = do
-      s1 <- createStore
-      s2 <- connectSQLiteStore (dbFilePath s1) ""
-      pure (s1, s2)
-
-createStore :: IO SQLiteStore
-createStore = do
-  -- Randomize DB file name to avoid SQLite IO errors supposedly caused by asynchronous
-  -- IO operations on multiple similarly named files; error seems to be environment specific
-  r <- randomIO :: IO Word32
-  createSQLiteStore (testDB <> show r) "" Migrations.app True
-
-removeStore :: SQLiteStore -> IO ()
-removeStore db = do
-  close db
-  removeFile $ dbFilePath db
-  where
-    close :: SQLiteStore -> IO ()
-    close st = mapM_ DB.close =<< atomically (tryTakeTMVar $ dbConnection st)
-
--- TODO add null port tests
-storeTests :: Spec
-storeTests = do
-  withStore2 $ do
-    describe "stress test" testConcurrentWrites
-  withStore $ do
-    describe "db setup" $ do
-      testCompiledThreadsafe
-      testForeignKeysEnabled
-    describe "db methods" $ do
-      describe "Queue and Connection management" $ do
-        describe "createRcvConn" $ do
-          testCreateRcvConn
-          testCreateRcvConnRandomId
-          testCreateRcvConnDuplicate
-        describe "createSndConn" $ do
-          testCreateSndConn
-          testCreateSndConnRandomID
-          testCreateSndConnDuplicate
-        describe "getRcvConn" testGetRcvConn
-        describe "deleteConn" $ do
-          testDeleteRcvConn
-          testDeleteSndConn
-          testDeleteDuplexConn
-        describe "upgradeRcvConnToDuplex" $ do
-          testUpgradeRcvConnToDuplex
-        describe "upgradeSndConnToDuplex" $ do
-          testUpgradeSndConnToDuplex
-        describe "set Queue status" $ do
-          describe "setRcvQueueStatus" $ do
-            testSetRcvQueueStatus
-          describe "setSndQueueStatus" $ do
-            testSetSndQueueStatus
-          testSetQueueStatusDuplex
-      describe "Msg management" $ do
-        describe "create Msg" $ do
-          testCreateRcvMsg
-          testCreateSndMsg
-          testCreateRcvAndSndMsgs
-
-testConcurrentWrites :: SpecWith (SQLiteStore, SQLiteStore)
-testConcurrentWrites =
-  it "should complete multiple concurrent write transactions w/t sqlite busy errors" $ \(s1, s2) -> do
-    g <- newTVarIO =<< drgNew
-    _ <- withTransaction s1 $ \db ->
-      createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    let ConnData {connId} = cData1
-    concurrently_ (runTest s1 connId) (runTest s2 connId)
-  where
-    runTest :: SQLiteStore -> ConnId -> IO ()
-    runTest st connId = replicateM_ 100 . withTransaction st $ \db -> do
-      (internalId, internalRcvId, _, _) <- updateRcvIds db connId
-      let rcvMsgData = mkRcvMsgData internalId internalRcvId 0 "0" "hash_dummy"
-      createRcvMsg db connId rcvQueue1 rcvMsgData
-
-testCompiledThreadsafe :: SpecWith SQLiteStore
-testCompiledThreadsafe =
-  it "compiled sqlite library should be threadsafe" . withStoreTransaction $ \db -> do
-    compileOptions <- DB.query_ db "pragma COMPILE_OPTIONS;" :: IO [[T.Text]]
-    compileOptions `shouldNotContain` [["THREADSAFE=0"]]
-
-withStoreTransaction :: (DB.Connection -> IO a) -> SQLiteStore -> IO a
-withStoreTransaction = flip withTransaction
-
-testForeignKeysEnabled :: SpecWith SQLiteStore
-testForeignKeysEnabled =
-  it "foreign keys should be enabled" . withStoreTransaction $ \db -> do
-    let inconsistentQuery =
-          [sql|
-            INSERT INTO snd_queues
-              ( host, port, snd_id, conn_id, snd_private_key, e2e_dh_secret, status)
-            VALUES
-              ('smp.simplex.im', '5223', '1234', '2345', x'', x'', 'new');
-          |]
-    DB.execute_ db inconsistentQuery
-      `shouldThrow` (\e -> DB.sqlError e == DB.ErrorConstraint)
-
-cData1 :: ConnData
-cData1 = ConnData {connId = "conn1", connAgentVersion = 1, enableNtfs = True, duplexHandshake = Nothing, deleted = False}
-
-testPrivateSignKey :: C.APrivateSignKey
-testPrivateSignKey = C.APrivateSignKey C.SEd25519 "MC4CAQAwBQYDK2VwBCIEIDfEfevydXXfKajz3sRkcQ7RPvfWUPoq6pu1TYHV1DEe"
-
-testPrivDhKey :: C.PrivateKeyX25519
-testPrivDhKey = "MC4CAQAwBQYDK2VuBCIEINCzbVFaCiYHoYncxNY8tSIfn0pXcIAhLBfFc0m+gOpk"
-
-testDhSecret :: C.DhSecretX25519
-testDhSecret = "01234567890123456789012345678901"
-
-rcvQueue1 :: RcvQueue
-rcvQueue1 =
-  RcvQueue
-    { connId = "conn1",
-      server = SMPServer "smp.simplex.im" "5223" testKeyHash,
-      rcvId = "1234",
-      rcvPrivateKey = testPrivateSignKey,
-      rcvDhSecret = testDhSecret,
-      e2ePrivKey = testPrivDhKey,
-      e2eDhSecret = Nothing,
-      sndId = "2345",
-      status = New,
-      dbQueueId = 1,
-      primary = True,
-      dbReplaceQueueId = Nothing,
-      smpClientVersion = 1,
-      clientNtfCreds = Nothing
-    }
-
-sndQueue1 :: SndQueue
-sndQueue1 =
-  SndQueue
-    { connId = "conn1",
-      server = SMPServer "smp.simplex.im" "5223" testKeyHash,
-      sndId = "3456",
-      sndPublicKey = Nothing,
-      sndPrivateKey = testPrivateSignKey,
-      e2ePubKey = Nothing,
-      e2eDhSecret = testDhSecret,
-      status = New,
-      dbQueueId = 1,
-      primary = True,
-      dbReplaceQueueId = Nothing,
-      smpClientVersion = 1
-    }
-
-testCreateRcvConn :: SpecWith SQLiteStore
-testCreateRcvConn =
-  it "should create RcvConnection and add SndQueue" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    createRcvConn db g cData1 rcvQueue1 SCMInvitation
-      `shouldReturn` Right "conn1"
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCRcv (RcvConnection cData1 rcvQueue1))
-    upgradeRcvConnToDuplex db "conn1" sndQueue1
-      `shouldReturn` Right 1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rcvQueue1] [sndQueue1]))
-
-testCreateRcvConnRandomId :: SpecWith SQLiteStore
-testCreateRcvConnRandomId =
-  it "should create RcvConnection and add SndQueue with random ID" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    Right connId <- createRcvConn db g cData1 {connId = ""} rcvQueue1 SCMInvitation
-    let rq' = (rcvQueue1 :: RcvQueue) {connId}
-        sq' = (sndQueue1 :: SndQueue) {connId}
-    getConn db connId
-      `shouldReturn` Right (SomeConn SCRcv (RcvConnection cData1 {connId} rq'))
-    upgradeRcvConnToDuplex db connId sndQueue1
-      `shouldReturn` Right 1
-    getConn db connId
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 {connId} [rq'] [sq']))
-
-testCreateRcvConnDuplicate :: SpecWith SQLiteStore
-testCreateRcvConnDuplicate =
-  it "should throw error on attempt to create duplicate RcvConnection" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    createRcvConn db g cData1 rcvQueue1 SCMInvitation
-      `shouldReturn` Left SEConnDuplicate
-
-testCreateSndConn :: SpecWith SQLiteStore
-testCreateSndConn =
-  it "should create SndConnection and add RcvQueue" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    createSndConn db g cData1 sndQueue1
-      `shouldReturn` Right "conn1"
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCSnd (SndConnection cData1 sndQueue1))
-    upgradeSndConnToDuplex db "conn1" rcvQueue1
-      `shouldReturn` Right 1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rcvQueue1] [sndQueue1]))
-
-testCreateSndConnRandomID :: SpecWith SQLiteStore
-testCreateSndConnRandomID =
-  it "should create SndConnection and add RcvQueue with random ID" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    Right connId <- createSndConn db g cData1 {connId = ""} sndQueue1
-    let rq' = (rcvQueue1 :: RcvQueue) {connId}
-        sq' = (sndQueue1 :: SndQueue) {connId}
-    getConn db connId
-      `shouldReturn` Right (SomeConn SCSnd (SndConnection cData1 {connId} sq'))
-    upgradeSndConnToDuplex db connId rcvQueue1
-      `shouldReturn` Right 1
-    getConn db connId
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 {connId} [rq'] [sq']))
-
-testCreateSndConnDuplicate :: SpecWith SQLiteStore
-testCreateSndConnDuplicate =
-  it "should throw error on attempt to create duplicate SndConnection" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createSndConn db g cData1 sndQueue1
-    createSndConn db g cData1 sndQueue1
-      `shouldReturn` Left SEConnDuplicate
-
-testGetRcvConn :: SpecWith SQLiteStore
-testGetRcvConn =
-  it "should get connection using rcv queue id and server" . withStoreTransaction $ \db -> do
-    let smpServer = SMPServer "smp.simplex.im" "5223" testKeyHash
-    let recipientId = "1234"
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    getRcvConn db smpServer recipientId
-      `shouldReturn` Right (rcvQueue1, SomeConn SCRcv (RcvConnection cData1 rcvQueue1))
-
-testDeleteRcvConn :: SpecWith SQLiteStore
-testDeleteRcvConn =
-  it "should create RcvConnection and delete it" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCRcv (RcvConnection cData1 rcvQueue1))
-    deleteConn db "conn1"
-      `shouldReturn` ()
-    -- TODO check queues are deleted as well
-    getConn db "conn1"
-      `shouldReturn` Left SEConnNotFound
-
-testDeleteSndConn :: SpecWith SQLiteStore
-testDeleteSndConn =
-  it "should create SndConnection and delete it" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createSndConn db g cData1 sndQueue1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCSnd (SndConnection cData1 sndQueue1))
-    deleteConn db "conn1"
-      `shouldReturn` ()
-    -- TODO check queues are deleted as well
-    getConn db "conn1"
-      `shouldReturn` Left SEConnNotFound
-
-testDeleteDuplexConn :: SpecWith SQLiteStore
-testDeleteDuplexConn =
-  it "should create DuplexConnection and delete it" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    _ <- upgradeRcvConnToDuplex db "conn1" sndQueue1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rcvQueue1] [sndQueue1]))
-    deleteConn db "conn1"
-      `shouldReturn` ()
-    -- TODO check queues are deleted as well
-    getConn db "conn1"
-      `shouldReturn` Left SEConnNotFound
-
-testUpgradeRcvConnToDuplex :: SpecWith SQLiteStore
-testUpgradeRcvConnToDuplex =
-  it "should throw error on attempt to add SndQueue to SndConnection or DuplexConnection" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createSndConn db g cData1 sndQueue1
-    let anotherSndQueue =
-          SndQueue
-            { connId = "conn1",
-              server = SMPServer "smp.simplex.im" "5223" testKeyHash,
-              sndId = "2345",
-              sndPublicKey = Nothing,
-              sndPrivateKey = testPrivateSignKey,
-              e2ePubKey = Nothing,
-              e2eDhSecret = testDhSecret,
-              status = New,
-              dbQueueId = 1,
-              primary = True,
-              dbReplaceQueueId = Nothing,
-              smpClientVersion = 1
-            }
-    upgradeRcvConnToDuplex db "conn1" anotherSndQueue
-      `shouldReturn` Left (SEBadConnType CSnd)
-    _ <- upgradeSndConnToDuplex db "conn1" rcvQueue1
-    upgradeRcvConnToDuplex db "conn1" anotherSndQueue
-      `shouldReturn` Left (SEBadConnType CDuplex)
-
-testUpgradeSndConnToDuplex :: SpecWith SQLiteStore
-testUpgradeSndConnToDuplex =
-  it "should throw error on attempt to add RcvQueue to RcvConnection or DuplexConnection" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    let anotherRcvQueue =
-          RcvQueue
-            { connId = "conn1",
-              server = SMPServer "smp.simplex.im" "5223" testKeyHash,
-              rcvId = "3456",
-              rcvPrivateKey = testPrivateSignKey,
-              rcvDhSecret = testDhSecret,
-              e2ePrivKey = testPrivDhKey,
-              e2eDhSecret = Nothing,
-              sndId = "4567",
-              status = New,
-              dbQueueId = 1,
-              primary = True,
-              dbReplaceQueueId = Nothing,
-              smpClientVersion = 1,
-              clientNtfCreds = Nothing
-            }
-    upgradeSndConnToDuplex db "conn1" anotherRcvQueue
-      `shouldReturn` Left (SEBadConnType CRcv)
-    _ <- upgradeRcvConnToDuplex db "conn1" sndQueue1
-    upgradeSndConnToDuplex db "conn1" anotherRcvQueue
-      `shouldReturn` Left (SEBadConnType CDuplex)
-
-testSetRcvQueueStatus :: SpecWith SQLiteStore
-testSetRcvQueueStatus =
-  it "should update status of RcvQueue" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCRcv (RcvConnection cData1 rcvQueue1))
-    setRcvQueueStatus db rcvQueue1 Confirmed
-      `shouldReturn` ()
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCRcv (RcvConnection cData1 rcvQueue1 {status = Confirmed}))
-
-testSetSndQueueStatus :: SpecWith SQLiteStore
-testSetSndQueueStatus =
-  it "should update status of SndQueue" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createSndConn db g cData1 sndQueue1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCSnd (SndConnection cData1 sndQueue1))
-    setSndQueueStatus db sndQueue1 Confirmed
-      `shouldReturn` ()
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCSnd (SndConnection cData1 sndQueue1 {status = Confirmed}))
-
-testSetQueueStatusDuplex :: SpecWith SQLiteStore
-testSetQueueStatusDuplex =
-  it "should update statuses of RcvQueue and SndQueue in DuplexConnection" . withStoreTransaction $ \db -> do
-    g <- newTVarIO =<< drgNew
-    _ <- createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    _ <- upgradeRcvConnToDuplex db "conn1" sndQueue1
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rcvQueue1] [sndQueue1]))
-    setRcvQueueStatus db rcvQueue1 Secured
-      `shouldReturn` ()
-    let rq' = (rcvQueue1 :: RcvQueue) {status = Secured}
-        sq' = (sndQueue1 :: SndQueue) {status = Confirmed}
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rq'] [sndQueue1]))
-    setSndQueueStatus db sndQueue1 Confirmed
-      `shouldReturn` ()
-    getConn db "conn1"
-      `shouldReturn` Right (SomeConn SCDuplex (DuplexConnection cData1 [rq'] [sq']))
-
-hw :: ByteString
-hw = encodeUtf8 "Hello world!"
-
-ts :: UTCTime
-ts = UTCTime (fromGregorian 2021 02 24) (secondsToDiffTime 0)
-
-mkRcvMsgData :: InternalId -> InternalRcvId -> ExternalSndId -> BrokerId -> MsgHash -> RcvMsgData
-mkRcvMsgData internalId internalRcvId externalSndId brokerId internalHash =
-  RcvMsgData
-    { internalRcvId,
-      msgMeta =
-        MsgMeta
-          { integrity = MsgOk,
-            recipient = (unId internalId, ts),
-            sndMsgId = externalSndId,
-            broker = (brokerId, ts)
-          },
-      msgType = AM_A_MSG_,
-      msgFlags = SMP.noMsgFlags,
-      msgBody = hw,
-      internalHash,
-      externalPrevSndHash = "hash_from_sender"
-    }
-
-testCreateRcvMsg_ :: DB.Connection -> PrevExternalSndId -> PrevRcvMsgHash -> ConnId -> RcvQueue -> RcvMsgData -> Expectation
-testCreateRcvMsg_ db expectedPrevSndId expectedPrevHash connId rq rcvMsgData@RcvMsgData {..} = do
-  let MsgMeta {recipient = (internalId, _)} = msgMeta
-  updateRcvIds db connId
-    `shouldReturn` (InternalId internalId, internalRcvId, expectedPrevSndId, expectedPrevHash)
-  createRcvMsg db connId rq rcvMsgData
-    `shouldReturn` ()
-
-testCreateRcvMsg :: SpecWith SQLiteStore
-testCreateRcvMsg =
-  it "should reserve internal ids and create a RcvMsg" $ \st -> do
-    g <- newTVarIO =<< drgNew
-    let ConnData {connId} = cData1
-    _ <- withTransaction st $ \db -> do
-      createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    withTransaction st $ \db -> do
-      testCreateRcvMsg_ db 0 "" connId rcvQueue1 $ mkRcvMsgData (InternalId 1) (InternalRcvId 1) 1 "1" "hash_dummy"
-      testCreateRcvMsg_ db 1 "hash_dummy" connId rcvQueue1 $ mkRcvMsgData (InternalId 2) (InternalRcvId 2) 2 "2" "new_hash_dummy"
-
-mkSndMsgData :: InternalId -> InternalSndId -> MsgHash -> SndMsgData
-mkSndMsgData internalId internalSndId internalHash =
-  SndMsgData
-    { internalId,
-      internalSndId,
-      internalTs = ts,
-      msgType = AM_A_MSG_,
-      msgFlags = SMP.noMsgFlags,
-      msgBody = hw,
-      internalHash,
-      prevMsgHash = internalHash
-    }
-
-testCreateSndMsg_ :: DB.Connection -> PrevSndMsgHash -> ConnId -> SndMsgData -> Expectation
-testCreateSndMsg_ db expectedPrevHash connId sndMsgData@SndMsgData {..} = do
-  updateSndIds db connId
-    `shouldReturn` (internalId, internalSndId, expectedPrevHash)
-  createSndMsg db connId sndMsgData
-    `shouldReturn` ()
-
-testCreateSndMsg :: SpecWith SQLiteStore
-testCreateSndMsg =
-  it "should create a SndMsg and return InternalId and PrevSndMsgHash" $ \st -> do
-    g <- newTVarIO =<< drgNew
-    let ConnData {connId} = cData1
-    _ <- withTransaction st $ \db -> do
-      createSndConn db g cData1 sndQueue1
-    withTransaction st $ \db -> do
-      testCreateSndMsg_ db "" connId $ mkSndMsgData (InternalId 1) (InternalSndId 1) "hash_dummy"
-      testCreateSndMsg_ db "hash_dummy" connId $ mkSndMsgData (InternalId 2) (InternalSndId 2) "new_hash_dummy"
-
-testCreateRcvAndSndMsgs :: SpecWith SQLiteStore
-testCreateRcvAndSndMsgs =
-  it "should create multiple RcvMsg and SndMsg, correctly ordering internal Ids and returning previous state" $ \st -> do
-    let ConnData {connId} = cData1
-    _ <- withTransaction st $ \db -> do
-      g <- newTVarIO =<< drgNew
-      createRcvConn db g cData1 rcvQueue1 SCMInvitation
-    withTransaction st $ \db -> do
-      _ <- upgradeRcvConnToDuplex db "conn1" sndQueue1
-      testCreateRcvMsg_ db 0 "" connId rcvQueue1 $ mkRcvMsgData (InternalId 1) (InternalRcvId 1) 1 "1" "rcv_hash_1"
-      testCreateRcvMsg_ db 1 "rcv_hash_1" connId rcvQueue1 $ mkRcvMsgData (InternalId 2) (InternalRcvId 2) 2 "2" "rcv_hash_2"
-      testCreateSndMsg_ db "" connId $ mkSndMsgData (InternalId 3) (InternalSndId 1) "snd_hash_1"
-      testCreateRcvMsg_ db 2 "rcv_hash_2" connId rcvQueue1 $ mkRcvMsgData (InternalId 4) (InternalRcvId 3) 3 "3" "rcv_hash_3"
-      testCreateSndMsg_ db "snd_hash_1" connId $ mkSndMsgData (InternalId 5) (InternalSndId 2) "snd_hash_2"
-      testCreateSndMsg_ db "snd_hash_2" connId $ mkSndMsgData (InternalId 6) (InternalSndId 3) "snd_hash_3"
diff --git a/source/tests/AgentTests/SchemaDump.hs b/source/tests/AgentTests/SchemaDump.hs
deleted file mode 100644
index 43c67a3..0000000
--- a/source/tests/AgentTests/SchemaDump.hs
+++ /dev/null
@@ -1,29 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-
-module AgentTests.SchemaDump where
-
-import Control.Monad (void)
-import Simplex.Messaging.Agent.Store.SQLite
-import qualified Simplex.Messaging.Agent.Store.SQLite.Migrations as Migrations
-import System.Process (readCreateProcess, shell)
-import Test.Hspec
-
-testDB :: FilePath
-testDB = "tests/tmp/test_agent_schema.db"
-
-schema :: FilePath
-schema = "src/Simplex/Messaging/Agent/Store/SQLite/Migrations/agent_schema.sql"
-
-schemaDumpTest :: Spec
-schemaDumpTest =
-  it "verify and overwrite schema dump" testVerifySchemaDump
-
-testVerifySchemaDump :: IO ()
-testVerifySchemaDump = do
-  void $ createSQLiteStore testDB "" Migrations.app False
-  void $ readCreateProcess (shell $ "touch " <> schema) ""
-  savedSchema <- readFile schema
-  savedSchema `seq` pure ()
-  void $ readCreateProcess (shell $ "sqlite3 " <> testDB <> " '.schema --indent' > " <> schema) ""
-  currentSchema <- readFile schema
-  savedSchema `shouldBe` currentSchema
diff --git a/source/tests/AgentTests.hs b/source/tests/AgentTests.hs
deleted file mode 100644
index 1568eda..0000000
--- a/source/tests/AgentTests.hs
+++ /dev/null
@@ -1,503 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# LANGUAGE PostfixOperators #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}
-
-module AgentTests (agentTests) where
-
-import AgentTests.ConnectionRequestTests
-import AgentTests.DoubleRatchetTests (doubleRatchetTests)
-import AgentTests.FunctionalAPITests (functionalAPITests)
-import AgentTests.NotificationTests (notificationTests)
-import AgentTests.SQLiteTests (storeTests)
-import AgentTests.SchemaDump (schemaDumpTest)
-import Control.Concurrent
-import Control.Monad (forM_)
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.ByteString.Char8 as B
-import Network.HTTP.Types (urlEncode)
-import SMPAgentClient
-import SMPClient (testKeyHash, testPort, testPort2, testStoreLogFile, withSmpServer, withSmpServerStoreLogOn)
-import Simplex.Messaging.Agent.Env.SQLite (AgentDatabase, databaseFile)
-import Simplex.Messaging.Agent.Protocol
-import qualified Simplex.Messaging.Agent.Protocol as A
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Protocol (ErrorType (..), MsgBody)
-import Simplex.Messaging.Transport (ATransport (..), TProxy (..), Transport (..))
-import Simplex.Messaging.Util (bshow)
-import System.Directory (removeFile)
-import System.Timeout
-import Test.Hspec
-
-agentTests :: ATransport -> Spec
-agentTests (ATransport t) = do
-  describe "Connection request" connectionRequestTests
-  describe "Double ratchet tests" doubleRatchetTests
-  describe "Functional API" $ functionalAPITests (ATransport t)
-  describe "Notification tests" $ notificationTests (ATransport t)
-  describe "SQLite store" storeTests
-  describe "SQLite schema dump" schemaDumpTest
-  describe "SMP agent protocol syntax" $ syntaxTests t
-  describe "Establishing duplex connection" $ do
-    it "should connect via one server and one agent" $
-      smpAgentTest2_1_1 $ testDuplexConnection t
-    it "should connect via one server and one agent (random IDs)" $
-      smpAgentTest2_1_1 $ testDuplexConnRandomIds t
-    it "should connect via one server and 2 agents" $
-      smpAgentTest2_2_1 $ testDuplexConnection t
-    it "should connect via one server and 2 agents (random IDs)" $
-      smpAgentTest2_2_1 $ testDuplexConnRandomIds t
-    it "should connect via 2 servers and 2 agents" $
-      smpAgentTest2_2_2 $ testDuplexConnection t
-    it "should connect via 2 servers and 2 agents (random IDs)" $
-      smpAgentTest2_2_2 $ testDuplexConnRandomIds t
-  describe "Establishing connections via `contact connection`" $ do
-    it "should connect via contact connection with one server and 3 agents" $
-      smpAgentTest3 $ testContactConnection t
-    it "should connect via contact connection with one server and 2 agents (random IDs)" $
-      smpAgentTest2_2_1 $ testContactConnRandomIds t
-    it "should support rejecting contact request" $
-      smpAgentTest2_2_1 $ testRejectContactRequest t
-  describe "Connection subscriptions" $ do
-    it "should connect via one server and one agent" $
-      smpAgentTest3_1_1 $ testSubscription t
-    it "should send notifications to client when server disconnects" $
-      smpAgentServerTest $ testSubscrNotification t
-  describe "Message delivery and server reconnection" $ do
-    it "should deliver messages after losing server connection and re-connecting" $
-      smpAgentTest2_2_2_needs_server $ testMsgDeliveryServerRestart t
-    it "should connect to the server when server goes up if it initially was down" $
-      smpAgentTestN [] $ testServerConnectionAfterError t
-    it "should deliver pending messages after agent restarting" $
-      smpAgentTest1_1_1 $ testMsgDeliveryAgentRestart t
-    it "should concurrently deliver messages to connections without blocking" $
-      smpAgentTest2_2_1 $ testConcurrentMsgDelivery t
-    it "should deliver messages if one of connections has quota exceeded" $
-      smpAgentTest2_2_1 $ testMsgDeliveryQuotaExceeded t
-
-tGetAgent :: Transport c => c -> IO (ATransmissionOrError 'Agent)
-tGetAgent h = do
-  t@(_, _, cmd) <- tGet SAgent h
-  case cmd of
-    Right CONNECT {} -> tGetAgent h
-    Right DISCONNECT {} -> tGetAgent h
-    _ -> pure t
-
--- | receive message to handle `h`
-(<#:) :: Transport c => c -> IO (ATransmissionOrError 'Agent)
-(<#:) = tGetAgent
-
--- | send transmission `t` to handle `h` and get response
-(#:) :: Transport c => c -> (ByteString, ByteString, ByteString) -> IO (ATransmissionOrError 'Agent)
-h #: t = tPutRaw h t >> (<#:) h
-
--- | action and expected response
--- `h #:t #> r` is the test that sends `t` to `h` and validates that the response is `r`
-(#>) :: IO (ATransmissionOrError 'Agent) -> ATransmission 'Agent -> Expectation
-action #> (corrId, connId, cmd) = action `shouldReturn` (corrId, connId, Right cmd)
-
--- | action and predicate for the response
--- `h #:t =#> p` is the test that sends `t` to `h` and validates the response using `p`
-(=#>) :: IO (ATransmissionOrError 'Agent) -> (ATransmission 'Agent -> Bool) -> Expectation
-action =#> p = action >>= (`shouldSatisfy` p . correctTransmission)
-
-correctTransmission :: ATransmissionOrError a -> ATransmission a
-correctTransmission (corrId, connId, cmdOrErr) = case cmdOrErr of
-  Right cmd -> (corrId, connId, cmd)
-  Left e -> error $ show e
-
--- | receive message to handle `h` and validate that it is the expected one
-(<#) :: Transport c => c -> ATransmission 'Agent -> Expectation
-h <# (corrId, connId, cmd) = (h <#:) `shouldReturn` (corrId, connId, Right cmd)
-
--- | receive message to handle `h` and validate it using predicate `p`
-(<#=) :: Transport c => c -> (ATransmission 'Agent -> Bool) -> Expectation
-h <#= p = (h <#:) >>= (`shouldSatisfy` p . correctTransmission)
-
--- | test that nothing is delivered to handle `h` during 10ms
-(#:#) :: Transport c => c -> String -> Expectation
-h #:# err = tryGet `shouldReturn` ()
-  where
-    tryGet =
-      10000 `timeout` tGetAgent h >>= \case
-        Just _ -> error err
-        _ -> return ()
-
-pattern Msg :: MsgBody -> ACommand 'Agent
-pattern Msg msgBody <- MSG MsgMeta {integrity = MsgOk} _ msgBody
-
-testDuplexConnection :: Transport c => TProxy c -> c -> c -> IO ()
-testDuplexConnection _ alice bob = do
-  ("1", "bob", Right (INV cReq)) <- alice #: ("1", "bob", "NEW T INV")
-  let cReq' = strEncode cReq
-  bob #: ("11", "alice", "JOIN T " <> cReq' <> " 14\nbob's connInfo") #> ("11", "alice", OK)
-  ("", "bob", Right (CONF confId _ "bob's connInfo")) <- (alice <#:)
-  alice #: ("2", "bob", "LET " <> confId <> " 16\nalice's connInfo") #> ("2", "bob", OK)
-  bob <# ("", "alice", INFO "alice's connInfo")
-  bob <# ("", "alice", CON)
-  alice <# ("", "bob", CON)
-  -- message IDs 1 to 3 get assigned to control messages, so first MSG is assigned ID 4
-  alice #: ("3", "bob", "SEND F :hello") #> ("3", "bob", MID 4)
-  alice <# ("", "bob", SENT 4)
-  bob <#= \case ("", "alice", Msg "hello") -> True; _ -> False
-  bob #: ("12", "alice", "ACK 4") #> ("12", "alice", OK)
-  alice #: ("4", "bob", "SEND F :how are you?") #> ("4", "bob", MID 5)
-  alice <# ("", "bob", SENT 5)
-  bob <#= \case ("", "alice", Msg "how are you?") -> True; _ -> False
-  bob #: ("13", "alice", "ACK 5") #> ("13", "alice", OK)
-  bob #: ("14", "alice", "SEND F 9\nhello too") #> ("14", "alice", MID 6)
-  bob <# ("", "alice", SENT 6)
-  alice <#= \case ("", "bob", Msg "hello too") -> True; _ -> False
-  alice #: ("3a", "bob", "ACK 6") #> ("3a", "bob", OK)
-  bob #: ("15", "alice", "SEND F 9\nmessage 1") #> ("15", "alice", MID 7)
-  bob <# ("", "alice", SENT 7)
-  alice <#= \case ("", "bob", Msg "message 1") -> True; _ -> False
-  alice #: ("4a", "bob", "ACK 7") #> ("4a", "bob", OK)
-  alice #: ("5", "bob", "OFF") #> ("5", "bob", OK)
-  bob #: ("17", "alice", "SEND F 9\nmessage 3") #> ("17", "alice", MID 8)
-  bob <# ("", "alice", MERR 8 (SMP AUTH))
-  alice #: ("6", "bob", "DEL") #> ("6", "bob", OK)
-  alice #:# "nothing else should be delivered to alice"
-
-testDuplexConnRandomIds :: Transport c => TProxy c -> c -> c -> IO ()
-testDuplexConnRandomIds _ alice bob = do
-  ("1", bobConn, Right (INV cReq)) <- alice #: ("1", "", "NEW T INV")
-  let cReq' = strEncode cReq
-  ("11", aliceConn, Right OK) <- bob #: ("11", "", "JOIN T " <> cReq' <> " 14\nbob's connInfo")
-  ("", bobConn', Right (CONF confId _ "bob's connInfo")) <- (alice <#:)
-  bobConn' `shouldBe` bobConn
-  alice #: ("2", bobConn, "LET " <> confId <> " 16\nalice's connInfo") =#> \case ("2", c, OK) -> c == bobConn; _ -> False
-  bob <# ("", aliceConn, INFO "alice's connInfo")
-  bob <# ("", aliceConn, CON)
-  alice <# ("", bobConn, CON)
-  alice #: ("2", bobConn, "SEND F :hello") #> ("2", bobConn, MID 4)
-  alice <# ("", bobConn, SENT 4)
-  bob <#= \case ("", c, Msg "hello") -> c == aliceConn; _ -> False
-  bob #: ("12", aliceConn, "ACK 4") #> ("12", aliceConn, OK)
-  alice #: ("3", bobConn, "SEND F :how are you?") #> ("3", bobConn, MID 5)
-  alice <# ("", bobConn, SENT 5)
-  bob <#= \case ("", c, Msg "how are you?") -> c == aliceConn; _ -> False
-  bob #: ("13", aliceConn, "ACK 5") #> ("13", aliceConn, OK)
-  bob #: ("14", aliceConn, "SEND F 9\nhello too") #> ("14", aliceConn, MID 6)
-  bob <# ("", aliceConn, SENT 6)
-  alice <#= \case ("", c, Msg "hello too") -> c == bobConn; _ -> False
-  alice #: ("3a", bobConn, "ACK 6") #> ("3a", bobConn, OK)
-  bob #: ("15", aliceConn, "SEND F 9\nmessage 1") #> ("15", aliceConn, MID 7)
-  bob <# ("", aliceConn, SENT 7)
-  alice <#= \case ("", c, Msg "message 1") -> c == bobConn; _ -> False
-  alice #: ("4a", bobConn, "ACK 7") #> ("4a", bobConn, OK)
-  alice #: ("5", bobConn, "OFF") #> ("5", bobConn, OK)
-  bob #: ("17", aliceConn, "SEND F 9\nmessage 3") #> ("17", aliceConn, MID 8)
-  bob <# ("", aliceConn, MERR 8 (SMP AUTH))
-  alice #: ("6", bobConn, "DEL") #> ("6", bobConn, OK)
-  alice #:# "nothing else should be delivered to alice"
-
-testContactConnection :: Transport c => TProxy c -> c -> c -> c -> IO ()
-testContactConnection _ alice bob tom = do
-  ("1", "alice_contact", Right (INV cReq)) <- alice #: ("1", "alice_contact", "NEW T CON")
-  let cReq' = strEncode cReq
-
-  bob #: ("11", "alice", "JOIN T " <> cReq' <> " 14\nbob's connInfo") #> ("11", "alice", OK)
-  ("", "alice_contact", Right (REQ aInvId _ "bob's connInfo")) <- (alice <#:)
-  alice #: ("2", "bob", "ACPT " <> aInvId <> " 16\nalice's connInfo") #> ("2", "bob", OK)
-  ("", "alice", Right (CONF bConfId _ "alice's connInfo")) <- (bob <#:)
-  bob #: ("12", "alice", "LET " <> bConfId <> " 16\nbob's connInfo 2") #> ("12", "alice", OK)
-  alice <# ("", "bob", INFO "bob's connInfo 2")
-  alice <# ("", "bob", CON)
-  bob <# ("", "alice", CON)
-  alice #: ("3", "bob", "SEND F :hi") #> ("3", "bob", MID 4)
-  alice <# ("", "bob", SENT 4)
-  bob <#= \case ("", "alice", Msg "hi") -> True; _ -> False
-  bob #: ("13", "alice", "ACK 4") #> ("13", "alice", OK)
-
-  tom #: ("21", "alice", "JOIN T " <> cReq' <> " 14\ntom's connInfo") #> ("21", "alice", OK)
-  ("", "alice_contact", Right (REQ aInvId' _ "tom's connInfo")) <- (alice <#:)
-  alice #: ("4", "tom", "ACPT " <> aInvId' <> " 16\nalice's connInfo") #> ("4", "tom", OK)
-  ("", "alice", Right (CONF tConfId _ "alice's connInfo")) <- (tom <#:)
-  tom #: ("22", "alice", "LET " <> tConfId <> " 16\ntom's connInfo 2") #> ("22", "alice", OK)
-  alice <# ("", "tom", INFO "tom's connInfo 2")
-  alice <# ("", "tom", CON)
-  tom <# ("", "alice", CON)
-  alice #: ("5", "tom", "SEND F :hi there") #> ("5", "tom", MID 4)
-  alice <# ("", "tom", SENT 4)
-  tom <#= \case ("", "alice", Msg "hi there") -> True; _ -> False
-  tom #: ("23", "alice", "ACK 4") #> ("23", "alice", OK)
-
-testContactConnRandomIds :: Transport c => TProxy c -> c -> c -> IO ()
-testContactConnRandomIds _ alice bob = do
-  ("1", aliceContact, Right (INV cReq)) <- alice #: ("1", "", "NEW T CON")
-  let cReq' = strEncode cReq
-
-  ("11", aliceConn, Right OK) <- bob #: ("11", "", "JOIN T " <> cReq' <> " 14\nbob's connInfo")
-  ("", aliceContact', Right (REQ aInvId _ "bob's connInfo")) <- (alice <#:)
-  aliceContact' `shouldBe` aliceContact
-
-  ("2", bobConn, Right OK) <- alice #: ("2", "", "ACPT " <> aInvId <> " 16\nalice's connInfo")
-  ("", aliceConn', Right (CONF bConfId _ "alice's connInfo")) <- (bob <#:)
-  aliceConn' `shouldBe` aliceConn
-
-  bob #: ("12", aliceConn, "LET " <> bConfId <> " 16\nbob's connInfo 2") #> ("12", aliceConn, OK)
-  alice <# ("", bobConn, INFO "bob's connInfo 2")
-  alice <# ("", bobConn, CON)
-  bob <# ("", aliceConn, CON)
-
-  alice #: ("3", bobConn, "SEND F :hi") #> ("3", bobConn, MID 4)
-  alice <# ("", bobConn, SENT 4)
-  bob <#= \case ("", c, Msg "hi") -> c == aliceConn; _ -> False
-  bob #: ("13", aliceConn, "ACK 4") #> ("13", aliceConn, OK)
-
-testRejectContactRequest :: Transport c => TProxy c -> c -> c -> IO ()
-testRejectContactRequest _ alice bob = do
-  ("1", "a_contact", Right (INV cReq)) <- alice #: ("1", "a_contact", "NEW T CON")
-  let cReq' = strEncode cReq
-  bob #: ("11", "alice", "JOIN T " <> cReq' <> " 10\nbob's info") #> ("11", "alice", OK)
-  ("", "a_contact", Right (REQ aInvId _ "bob's info")) <- (alice <#:)
-  -- RJCT must use correct contact connection
-  alice #: ("2a", "bob", "RJCT " <> aInvId) #> ("2a", "bob", ERR $ CONN NOT_FOUND)
-  alice #: ("2b", "a_contact", "RJCT " <> aInvId) #> ("2b", "a_contact", OK)
-  alice #: ("3", "bob", "ACPT " <> aInvId <> " 12\nalice's info") #> ("3", "bob", ERR $ A.CMD PROHIBITED)
-  bob #:# "nothing should be delivered to bob"
-
-testSubscription :: Transport c => TProxy c -> c -> c -> c -> IO ()
-testSubscription _ alice1 alice2 bob = do
-  (alice1, "alice") `connect` (bob, "bob")
-  bob #: ("12", "alice", "SEND F 5\nhello") #> ("12", "alice", MID 4)
-  bob <# ("", "alice", SENT 4)
-  alice1 <#= \case ("", "bob", Msg "hello") -> True; _ -> False
-  alice1 #: ("1", "bob", "ACK 4") #> ("1", "bob", OK)
-  bob #: ("13", "alice", "SEND F 11\nhello again") #> ("13", "alice", MID 5)
-  bob <# ("", "alice", SENT 5)
-  alice1 <#= \case ("", "bob", Msg "hello again") -> True; _ -> False
-  alice1 #: ("2", "bob", "ACK 5") #> ("2", "bob", OK)
-  alice2 #: ("21", "bob", "SUB") #> ("21", "bob", OK)
-  alice1 <# ("", "bob", END)
-  bob #: ("14", "alice", "SEND F 2\nhi") #> ("14", "alice", MID 6)
-  bob <# ("", "alice", SENT 6)
-  alice2 <#= \case ("", "bob", Msg "hi") -> True; _ -> False
-  alice2 #: ("22", "bob", "ACK 6") #> ("22", "bob", OK)
-  alice1 #:# "nothing else should be delivered to alice1"
-
-testSubscrNotification :: Transport c => TProxy c -> (ThreadId, ThreadId) -> c -> IO ()
-testSubscrNotification t (server, _) client = do
-  client #: ("1", "conn1", "NEW T INV") =#> \case ("1", "conn1", INV {}) -> True; _ -> False
-  client #:# "nothing should be delivered to client before the server is killed"
-  killThread server
-  client <# ("", "", DOWN testSMPServer ["conn1"])
-  withSmpServer (ATransport t) $
-    client <# ("", "conn1", ERR (SMP AUTH)) -- this new server does not have the queue
-
-testMsgDeliveryServerRestart :: Transport c => TProxy c -> c -> c -> IO ()
-testMsgDeliveryServerRestart t alice bob = do
-  withServer $ do
-    connect (alice, "alice") (bob, "bob")
-    bob #: ("1", "alice", "SEND F 2\nhi") #> ("1", "alice", MID 4)
-    bob <# ("", "alice", SENT 4)
-    alice <#= \case ("", "bob", Msg "hi") -> True; _ -> False
-    alice #: ("11", "bob", "ACK 4") #> ("11", "bob", OK)
-    alice #:# "nothing else delivered before the server is killed"
-
-  let server = (SMPServer "localhost" testPort2 testKeyHash)
-  alice <# ("", "", DOWN server ["bob"])
-  bob #: ("2", "alice", "SEND F 11\nhello again") #> ("2", "alice", MID 5)
-  bob #:# "nothing else delivered before the server is restarted"
-  alice #:# "nothing else delivered before the server is restarted"
-
-  withServer $ do
-    bob <# ("", "alice", SENT 5)
-    alice <# ("", "", UP server ["bob"])
-    alice <#= \case ("", "bob", Msg "hello again") -> True; _ -> False
-    alice #: ("12", "bob", "ACK 5") #> ("12", "bob", OK)
-
-  removeFile testStoreLogFile
-  where
-    withServer test' = withSmpServerStoreLogOn (ATransport t) testPort2 (const test') `shouldReturn` ()
-
-testServerConnectionAfterError :: forall c. Transport c => TProxy c -> [c] -> IO ()
-testServerConnectionAfterError t _ = do
-  withAgent1 $ \bob -> do
-    withAgent2 $ \alice -> do
-      withServer $ do
-        connect (bob, "bob") (alice, "alice")
-
-      bob <# ("", "", DOWN server ["alice"])
-      alice <# ("", "", DOWN server ["bob"])
-      alice #: ("1", "bob", "SEND F 5\nhello") #> ("1", "bob", MID 4)
-      alice #:# "nothing else delivered before the server is restarted"
-      bob #:# "nothing else delivered before the server is restarted"
-
-  withAgent1 $ \bob -> do
-    withAgent2 $ \alice -> do
-      bob #: ("1", "alice", "SUB") =#> \("1", "alice", ERR (BROKER _ e)) -> e == NETWORK || e == TIMEOUT
-      alice #: ("1", "bob", "SUB") =#> \("1", "bob", ERR (BROKER _ e)) -> e == NETWORK || e == TIMEOUT
-      withServer $ do
-        alice <#= \case ("", "bob", SENT 4) -> True; ("", "", UP s ["bob"]) -> s == server; _ -> False
-        alice <#= \case ("", "bob", SENT 4) -> True; ("", "", UP s ["bob"]) -> s == server; _ -> False
-        bob <# ("", "", UP server ["alice"])
-        bob <#= \case ("", "alice", Msg "hello") -> True; _ -> False
-        bob #: ("2", "alice", "ACK 4") #> ("2", "alice", OK)
-        alice #: ("1", "bob", "SEND F 11\nhello again") #> ("1", "bob", MID 5)
-        alice <# ("", "bob", SENT 5)
-        bob <#= \case ("", "alice", Msg "hello again") -> True; _ -> False
-
-  removeFile testStoreLogFile
-  removeFile $ databaseFile testDB
-  removeFile $ databaseFile testDB2
-  where
-    server = SMPServer "localhost" testPort2 testKeyHash
-    withServer test' = withSmpServerStoreLogOn (ATransport t) testPort2 (const test') `shouldReturn` ()
-    withAgent1 = withAgent agentTestPort testDB
-    withAgent2 = withAgent agentTestPort2 testDB2
-    withAgent :: String -> AgentDatabase -> (c -> IO a) -> IO a
-    withAgent agentPort agentDB = withSmpAgentThreadOn_ (ATransport t) (agentPort, testPort2, agentDB) (pure ()) . const . testSMPAgentClientOn agentPort
-
-testMsgDeliveryAgentRestart :: Transport c => TProxy c -> c -> IO ()
-testMsgDeliveryAgentRestart t bob = do
-  let server = SMPServer "localhost" testPort2 testKeyHash
-  withAgent $ \alice -> do
-    withServer $ do
-      connect (bob, "bob") (alice, "alice")
-      alice #: ("1", "bob", "SEND F 5\nhello") #> ("1", "bob", MID 4)
-      alice <# ("", "bob", SENT 4)
-      bob <#= \case ("", "alice", Msg "hello") -> True; _ -> False
-      bob #: ("11", "alice", "ACK 4") #> ("11", "alice", OK)
-      bob #:# "nothing else delivered before the server is down"
-
-    bob <# ("", "", DOWN server ["alice"])
-    alice #: ("2", "bob", "SEND F 11\nhello again") #> ("2", "bob", MID 5)
-    alice #:# "nothing else delivered before the server is restarted"
-    bob #:# "nothing else delivered before the server is restarted"
-
-  withAgent $ \alice -> do
-    withServer $ do
-      tPutRaw alice ("3", "bob", "SUB")
-      alice <#= \case
-        (corrId, "bob", cmd) ->
-          (corrId == "3" && cmd == OK)
-            || (corrId == "" && cmd == SENT 5)
-        _ -> False
-      bob <# ("", "", UP server ["alice"])
-      bob <#= \case ("", "alice", Msg "hello again") -> True; _ -> False
-      bob #: ("12", "alice", "ACK 5") #> ("12", "alice", OK)
-
-  removeFile testStoreLogFile
-  removeFile $ databaseFile testDB
-  where
-    withServer test' = withSmpServerStoreLogOn (ATransport t) testPort2 (const test') `shouldReturn` ()
-    withAgent = withSmpAgentThreadOn_ (ATransport t) (agentTestPort, testPort, testDB) (pure ()) . const . testSMPAgentClientOn agentTestPort
-
-testConcurrentMsgDelivery :: Transport c => TProxy c -> c -> c -> IO ()
-testConcurrentMsgDelivery _ alice bob = do
-  connect (alice, "alice") (bob, "bob")
-
-  ("1", "bob2", Right (INV cReq)) <- alice #: ("1", "bob2", "NEW T INV")
-  let cReq' = strEncode cReq
-  bob #: ("11", "alice2", "JOIN T " <> cReq' <> " 14\nbob's connInfo") #> ("11", "alice2", OK)
-  ("", "bob2", Right (CONF _confId _ "bob's connInfo")) <- (alice <#:)
-  -- below commands would be needed to accept bob's connection, but alice does not
-  -- alice #: ("2", "bob", "LET " <> _confId <> " 16\nalice's connInfo") #> ("2", "bob", OK)
-  -- bob <# ("", "alice", INFO "alice's connInfo")
-  -- bob <# ("", "alice", CON)
-  -- alice <# ("", "bob", CON)
-
-  -- the first connection should not be blocked by the second one
-  sendMessage (alice, "alice") (bob, "bob") "hello"
-  -- alice #: ("2", "bob", "SEND F :hello") #> ("2", "bob", MID 1)
-  -- alice <# ("", "bob", SENT 1)
-  -- bob <#= \case ("", "alice", Msg "hello") -> True; _ -> False
-  -- bob #: ("12", "alice", "ACK 1") #> ("12", "alice", OK)
-  bob #: ("14", "alice", "SEND F 9\nhello too") #> ("14", "alice", MID 5)
-  bob <# ("", "alice", SENT 5)
-  -- if delivery is blocked it won't go further
-  alice <#= \case ("", "bob", Msg "hello too") -> True; _ -> False
-  alice #: ("3", "bob", "ACK 5") #> ("3", "bob", OK)
-
-testMsgDeliveryQuotaExceeded :: Transport c => TProxy c -> c -> c -> IO ()
-testMsgDeliveryQuotaExceeded _ alice bob = do
-  connect (alice, "alice") (bob, "bob")
-  connect (alice, "alice2") (bob, "bob2")
-  forM_ [1 .. 4 :: Int] $ \i -> do
-    let corrId = bshow i
-        msg = "message " <> bshow i
-    (_, "bob", Right (MID mId)) <- alice #: (corrId, "bob", "SEND F :" <> msg)
-    alice <#= \case ("", "bob", SENT m) -> m == mId; _ -> False
-  (_, "bob", Right (MID _)) <- alice #: ("5", "bob", "SEND F :over quota")
-
-  alice #: ("1", "bob2", "SEND F :hello") #> ("1", "bob2", MID 4)
-  -- if delivery is blocked it won't go further
-  alice <# ("", "bob2", SENT 4)
-
-connect :: forall c. Transport c => (c, ByteString) -> (c, ByteString) -> IO ()
-connect (h1, name1) (h2, name2) = do
-  ("c1", _, Right (INV cReq)) <- h1 #: ("c1", name2, "NEW T INV")
-  let cReq' = strEncode cReq
-  h2 #: ("c2", name1, "JOIN T " <> cReq' <> " 5\ninfo2") #> ("c2", name1, OK)
-  ("", _, Right (CONF connId _ "info2")) <- (h1 <#:)
-  h1 #: ("c3", name2, "LET " <> connId <> " 5\ninfo1") #> ("c3", name2, OK)
-  h2 <# ("", name1, INFO "info1")
-  h2 <# ("", name1, CON)
-  h1 <# ("", name2, CON)
-
-sendMessage :: Transport c => (c, ConnId) -> (c, ConnId) -> ByteString -> IO ()
-sendMessage (h1, name1) (h2, name2) msg = do
-  ("m1", name2', Right (MID mId)) <- h1 #: ("m1", name2, "SEND F :" <> msg)
-  name2' `shouldBe` name2
-  h1 <#= \case ("", n, SENT m) -> n == name2 && m == mId; _ -> False
-  ("", name1', Right (MSG MsgMeta {recipient = (msgId', _)} _ msg')) <- (h2 <#:)
-  name1' `shouldBe` name1
-  msg' `shouldBe` msg
-  h2 #: ("m2", name1, "ACK " <> bshow msgId') =#> \case ("m2", n, OK) -> n == name1; _ -> False
-
--- connect' :: forall c. Transport c => c -> c -> IO (ByteString, ByteString)
--- connect' h1 h2 = do
---   ("c1", conn2, Right (INV cReq)) <- h1 #: ("c1", "", "NEW T INV")
---   let cReq' = strEncode cReq
---   ("c2", conn1, Right OK) <- h2 #: ("c2", "", "JOIN T " <> cReq' <> " 5\ninfo2")
---   ("", _, Right (REQ connId _ "info2")) <- (h1 <#:)
---   h1 #: ("c3", conn2, "ACPT " <> connId <> " 5\ninfo1") =#> \case ("c3", c, OK) -> c == conn2; _ -> False
---   h2 <# ("", conn1, INFO "info1")
---   h2 <# ("", conn1, CON)
---   h1 <# ("", conn2, CON)
---   pure (conn1, conn2)
-
-sampleDhKey :: ByteString
-sampleDhKey = "MCowBQYDK2VuAyEAjiswwI3O_NlS8Fk3HJUW870EY2bAwmttMBsvRB9eV3o="
-
-syntaxTests :: forall c. Transport c => TProxy c -> Spec
-syntaxTests t = do
-  it "unknown command" $ ("1", "5678", "HELLO") >#> ("1", "5678", "ERR CMD SYNTAX")
-  describe "NEW" $ do
-    describe "valid" $ do
-      -- TODO: add tests with defined connection id
-      it "with correct parameter" $ ("211", "", "NEW T INV") >#>= \case ("211", _, "INV" : _) -> True; _ -> False
-    describe "invalid" $ do
-      -- TODO: add tests with defined connection id
-      it "with incorrect parameter" $ ("222", "", "NEW T hi") >#> ("222", "", "ERR CMD SYNTAX")
-
-  describe "JOIN" $ do
-    describe "valid" $ do
-      it "using same server as in invitation" $
-        ( "311",
-          "a",
-          "JOIN T https://simpex.chat/invitation#/?smp=smp%3A%2F%2F"
-            <> urlEncode True "LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI="
-            <> "%40localhost%3A5001%2F3456-w%3D%3D%23"
-            <> urlEncode True sampleDhKey
-            <> "&v=1"
-            <> "&e2e=v%3D1%26x3dh%3DMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D%2CMEIwBQYDK2VvAzkAmKuSYeQ_m0SixPDS8Wq8VBaTS1cW-Lp0n0h4Diu-kUpR-qXx4SDJ32YGEFoGFGSbGPry5Ychr6U%3D"
-            <> " 14\nbob's connInfo"
-        )
-          >#> ("311", "a", "ERR SMP AUTH")
-    describe "invalid" $ do
-      it "no parameters" $ ("321", "", "JOIN") >#> ("321", "", "ERR CMD SYNTAX")
-  where
-    -- simple test for one command with the expected response
-    (>#>) :: ARawTransmission -> ARawTransmission -> Expectation
-    command >#> response = smpAgentTest t command `shouldReturn` response
-
-    -- simple test for one command with a predicate for the expected response
-    (>#>=) :: ARawTransmission -> ((ByteString, ByteString, [ByteString]) -> Bool) -> Expectation
-    command >#>= p = smpAgentTest t command >>= (`shouldSatisfy` p . \(cId, connId, cmd) -> (cId, connId, B.words cmd))
diff --git a/source/tests/CLITests.hs b/source/tests/CLITests.hs
deleted file mode 100644
index 1834bf6..0000000
--- a/source/tests/CLITests.hs
+++ /dev/null
@@ -1,79 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-
-module CLITests where
-
-import Data.Ini (lookupValue, readIniFile)
-import Data.List (isPrefixOf)
-import Simplex.Messaging.Notifications.Server.Main
-import Simplex.Messaging.Server.Main
-import Simplex.Messaging.Util (catchAll_)
-import System.Directory (doesFileExist)
-import System.Environment (withArgs)
-import System.IO.Silently (capture_)
-import System.Timeout (timeout)
-import Test.Hspec
-import Test.Main (withStdin)
-
-cfgPath :: FilePath
-cfgPath = "tests/tmp/cli/etc/opt/simplex"
-
-logPath :: FilePath
-logPath = "tests/tmp/cli/etc/var/simplex"
-
-ntfCfgPath :: FilePath
-ntfCfgPath = "tests/tmp/cli/etc/opt/simplex-notifications"
-
-ntfLogPath :: FilePath
-ntfLogPath = "tests/tmp/cli/etc/var/simplex-notifications"
-
-cliTests :: Spec
-cliTests = do
-  describe "SMP server CLI" $ do
-    describe "initialize, start and delete the server" $ do
-      it "no store log, random password (default)" $ smpServerTest False True
-      it "with store log, random password (default)" $ smpServerTest True True
-      it "no store log, no password" $ smpServerTest False False
-      it "with store log, no password" $ smpServerTest True False
-  describe "Ntf server CLI" $ do
-    it "should initialize, start and delete the server (no store log)" $ ntfServerTest False
-    it "should initialize, start and delete the server (with store log)" $ ntfServerTest True
-
-smpServerTest :: Bool -> Bool -> IO ()
-smpServerTest storeLog basicAuth = do
-  capture_ (withArgs (["init", "-y"] <> ["-l" | storeLog] <> ["--no-password" | not basicAuth]) $ smpServerCLI cfgPath logPath)
-    >>= (`shouldSatisfy` (("Server initialized, you can modify configuration in " <> cfgPath <> "/smp-server.ini") `isPrefixOf`))
-  Right ini <- readIniFile $ cfgPath <> "/smp-server.ini"
-  lookupValue "STORE_LOG" "enable" ini `shouldBe` Right (if storeLog then "on" else "off")
-  lookupValue "STORE_LOG" "log_stats" ini `shouldBe` Right "off"
-  lookupValue "TRANSPORT" "port" ini `shouldBe` Right "5223"
-  lookupValue "TRANSPORT" "websockets" ini `shouldBe` Right "off"
-  lookupValue "AUTH" "new_queues" ini `shouldBe` Right "on"
-  lookupValue "INACTIVE_CLIENTS" "disconnect" ini `shouldBe` Right "off"
-  doesFileExist (cfgPath <> "/ca.key") `shouldReturn` True
-  r <- lines <$> capture_ (withArgs ["start"] $ (100000 `timeout` smpServerCLI cfgPath logPath) `catchAll_` pure (Just ()))
-  r `shouldContain` ["SMP server v4.0.0"]
-  r `shouldContain` (if storeLog then ["Store log: " <> logPath <> "/smp-server-store.log"] else ["Store log disabled."])
-  r `shouldContain` ["Listening on port 5223 (TLS)..."]
-  r `shouldContain` ["not expiring inactive clients"]
-  r `shouldContain` (if basicAuth then ["creating new queues requires password"] else ["creating new queues allowed"])
-  capture_ (withStdin "Y" . withArgs ["delete"] $ smpServerCLI cfgPath logPath)
-    >>= (`shouldSatisfy` ("WARNING: deleting the server will make all queues inaccessible" `isPrefixOf`))
-  doesFileExist (cfgPath <> "/ca.key") `shouldReturn` False
-
-ntfServerTest :: Bool -> IO ()
-ntfServerTest storeLog = do
-  capture_ (withArgs (["init"] <> ["-l" | storeLog]) $ ntfServerCLI ntfCfgPath ntfLogPath)
-    >>= (`shouldSatisfy` (("Server initialized, you can modify configuration in " <> ntfCfgPath <> "/ntf-server.ini") `isPrefixOf`))
-  Right ini <- readIniFile $ ntfCfgPath <> "/ntf-server.ini"
-  lookupValue "STORE_LOG" "enable" ini `shouldBe` Right (if storeLog then "on" else "off")
-  lookupValue "STORE_LOG" "log_stats" ini `shouldBe` Right "off"
-  lookupValue "TRANSPORT" "port" ini `shouldBe` Right "443"
-  lookupValue "TRANSPORT" "websockets" ini `shouldBe` Right "off"
-  doesFileExist (ntfCfgPath <> "/ca.key") `shouldReturn` True
-  r <- lines <$> capture_ (withArgs ["start"] $ (100000 `timeout` ntfServerCLI ntfCfgPath ntfLogPath) `catchAll_` pure (Just ()))
-  r `shouldContain` ["SMP notifications server v1.2.0"]
-  r `shouldContain` (if storeLog then ["Store log: " <> ntfLogPath <> "/ntf-server-store.log"] else ["Store log disabled."])
-  r `shouldContain` ["Listening on port 443 (TLS)..."]
-  capture_ (withStdin "Y" . withArgs ["delete"] $ ntfServerCLI ntfCfgPath ntfLogPath)
-    >>= (`shouldSatisfy` ("WARNING: deleting the server will make all queues inaccessible" `isPrefixOf`))
-  doesFileExist (cfgPath <> "/ca.key") `shouldReturn` False
diff --git a/source/tests/CoreTests/CryptoTests.hs b/source/tests/CoreTests/CryptoTests.hs
deleted file mode 100644
index 25975dc..0000000
--- a/source/tests/CoreTests/CryptoTests.hs
+++ /dev/null
@@ -1,36 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-
-module CoreTests.CryptoTests (cryptoTests) where
-
-import qualified Simplex.Messaging.Crypto as C
-import Test.Hspec
-import Test.Hspec.QuickCheck (modifyMaxSuccess)
-import Test.QuickCheck
-import qualified Data.Text as T
-import qualified Data.ByteString.Char8 as B
-import Data.Text.Encoding (encodeUtf8)
-
-cryptoTests :: Spec
-cryptoTests = modifyMaxSuccess (const 10000) $ do
-  describe "padding / unpadding" $ do
-    it "should pad / unpad string" . property $ \(s, paddedLen) ->
-      let b = encodeUtf8 $ T.pack s
-          len = B.length b
-          padded = C.pad b paddedLen
-       in if len < 2 ^ (16 :: Int) - 3 && len <= paddedLen - 2
-            then (padded >>= C.unPad) == Right b
-            else padded == Left C.CryptoLargeMsgError
-    it "pad should fail on large string" $ do
-      C.pad "abc" 5 `shouldBe` Right "\000\003abc"
-      C.pad "abc" 4 `shouldBe` Left C.CryptoLargeMsgError
-      let s = B.replicate 65533 'a'
-      (C.pad s 65535 >>= C.unPad) `shouldBe` Right s
-      C.pad (B.replicate 65534 'a') 65536 `shouldBe` Left C.CryptoLargeMsgError
-      C.pad (B.replicate 65535 'a') 65537 `shouldBe` Left C.CryptoLargeMsgError
-    it "unpad should fail on invalid string" $ do
-      C.unPad "\000\000" `shouldBe` Right ""
-      C.unPad "\000" `shouldBe` Left C.CryptoInvalidMsgError
-      C.unPad "" `shouldBe` Left C.CryptoInvalidMsgError
-    it "unpad should fail on shorter string" $ do
-      C.unPad "\000\003abc" `shouldBe` Right "abc"
-      C.unPad "\000\003ab" `shouldBe` Left C.CryptoInvalidMsgError
diff --git a/source/tests/CoreTests/EncodingTests.hs b/source/tests/CoreTests/EncodingTests.hs
deleted file mode 100644
index 52ed738..0000000
--- a/source/tests/CoreTests/EncodingTests.hs
+++ /dev/null
@@ -1,46 +0,0 @@
-{-# LANGUAGE OverloadedStrings #-}
-
-module CoreTests.EncodingTests where
-
-import Data.Bits (shiftR)
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.ByteString.Char8 as B
-import Data.ByteString.Internal (w2c)
-import Data.Int (Int64)
-import Data.Time.Clock.System (SystemTime (..), getSystemTime, utcToSystemTime)
-import Data.Time.ISO8601 (parseISO8601)
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Parsers (parseAll)
-import Test.Hspec
-import Test.Hspec.QuickCheck (modifyMaxSuccess)
-import Test.QuickCheck
-
-int64 :: Int64
-int64 = 1234567890123456789
-
-s64 :: ByteString
-s64 = B.pack $ map (w2c . fromIntegral . (int64 `shiftR`)) [56, 48, 40, 32, 24, 16, 8, 0]
-
-encodingTests :: Spec
-encodingTests = modifyMaxSuccess (const 1000) $ do
-  describe "Encoding Int64" $ do
-    it "should encode and decode Int64 example" $ do
-      s64 `shouldBe` "\17\34\16\244\125\233\129\21"
-      smpEncode int64 `shouldBe` s64
-      parseAll smpP s64 `shouldBe` Right int64
-    it "parse(encode(Int64) should equal the same Int64" . property $
-      \i -> parseAll smpP (smpEncode i) == Right (i :: Int64)
-  describe "Encoding SystemTime" $ do
-    it "should encode and decode SystemTime" $ do
-      t <- getSystemTime
-      testSystemTime t
-      Just t' <- pure $ utcToSystemTime <$> parseISO8601 "2022-01-01T10:24:05.000Z"
-      systemSeconds t' `shouldBe` 1641032645
-      testSystemTime t'
-    it "parse(encode(SystemTime) should equal the same Int64" . property $
-      \i -> parseAll smpP (smpEncode i) == Right (i :: Int64)
-  where
-    testSystemTime :: SystemTime -> Expectation
-    testSystemTime t = do
-      smpEncode t `shouldBe` smpEncode (systemSeconds t)
-      parseAll smpP (smpEncode t) `shouldBe` Right t {systemNanoseconds = 0}
diff --git a/source/tests/CoreTests/ProtocolErrorTests.hs b/source/tests/CoreTests/ProtocolErrorTests.hs
deleted file mode 100644
index 30964be..0000000
--- a/source/tests/CoreTests/ProtocolErrorTests.hs
+++ /dev/null
@@ -1,28 +0,0 @@
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-
-module CoreTests.ProtocolErrorTests where
-
-import qualified Data.ByteString.Char8 as B
-import qualified Data.Text as T
-import Data.Text.Encoding (encodeUtf8)
-import Simplex.Messaging.Agent.Protocol (AgentErrorType (..))
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Parsers (parseAll)
-import Test.Hspec
-import Test.Hspec.QuickCheck (modifyMaxSuccess)
-import Test.QuickCheck
-
-protocolErrorTests :: Spec
-protocolErrorTests = modifyMaxSuccess (const 1000) $ do
-  describe "errors parsing / serializing" $ do
-    it "should parse SMP protocol errors" . property $ \(err :: AgentErrorType) ->
-      errServerHasSpaces err
-        || parseAll strP (strEncode err) == Right err
-    it "should parse SMP agent errors" . property $ \(err :: AgentErrorType) ->
-      errServerHasSpaces err
-        || parseAll strP (strEncode err) == Right err
-  where
-    errServerHasSpaces = \case
-      BROKER srv _ -> ' ' `B.elem` encodeUtf8 (T.pack srv)
-      _ -> False
diff --git a/source/tests/CoreTests/VersionRangeTests.hs b/source/tests/CoreTests/VersionRangeTests.hs
deleted file mode 100644
index 4a623cd..0000000
--- a/source/tests/CoreTests/VersionRangeTests.hs
+++ /dev/null
@@ -1,58 +0,0 @@
-{-# LANGUAGE DeriveGeneric #-}
-{-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE TypeFamilies #-}
-
-module CoreTests.VersionRangeTests where
-
-import GHC.Generics (Generic)
-import Generic.Random (genericArbitraryU)
-import Simplex.Messaging.Version
-import Test.Hspec
-import Test.Hspec.QuickCheck (modifyMaxSuccess)
-import Test.QuickCheck
-
-data V = V1 | V2 | V3 | V4 | V5 deriving (Eq, Enum, Ord, Generic, Show)
-
-instance Arbitrary V where arbitrary = genericArbitraryU
-
-versionRangeTests :: Spec
-versionRangeTests = modifyMaxSuccess (const 1000) $ do
-  describe "VersionRange construction" $ do
-    it "should fail on invalid range" $ do
-      vr 1 1 `shouldBe` vr 1 1
-      vr 1 2 `shouldBe` vr 1 2
-      (pure $! vr 2 1) `shouldThrow` anyErrorCall
-  describe "compatible version" $ do
-    it "should choose mutually compatible max version" $ do
-      (vr 1 1, vr 1 1) `compatible` Just 1
-      (vr 1 1, vr 1 2) `compatible` Just 1
-      (vr 1 2, vr 1 2) `compatible` Just 2
-      (vr 1 2, vr 2 3) `compatible` Just 2
-      (vr 1 3, vr 2 3) `compatible` Just 3
-      (vr 1 3, vr 2 4) `compatible` Just 3
-      (vr 1 2, vr 3 4) `compatible` Nothing
-    it "should check if version is compatible" $ do
-      isCompatible (1 :: Version) (vr 1 2) `shouldBe` True
-      isCompatible (2 :: Version) (vr 1 2) `shouldBe` True
-      isCompatible (2 :: Version) (vr 1 1) `shouldBe` False
-      isCompatible (1 :: Version) (vr 2 2) `shouldBe` False
-    it "compatibleVersion should pass isCompatible check" . property $
-      \((min1, max1) :: (V, V)) ((min2, max2) :: (V, V)) ->
-        min1 > max1 || min2 > max2 -- one of ranges is invalid, skip testing it
-          || let w = fromIntegral . fromEnum
-                 vr1 = mkVersionRange (w min1) (w max1) :: VersionRange
-                 vr2 = mkVersionRange (w min2) (w max2) :: VersionRange
-              in case compatibleVersion vr1 vr2 of
-                   Just (Compatible v) -> v `isCompatible` vr1 && v `isCompatible` vr2
-                   _ -> True
-  where
-    vr = mkVersionRange
-    compatible :: (VersionRange, VersionRange) -> Maybe Version -> Expectation
-    (vr1, vr2) `compatible` v = do
-      (vr1, vr2) `checkCompatible` v
-      (vr2, vr1) `checkCompatible` v
-    (vr1, vr2) `checkCompatible` v =
-      case compatibleVersion vr1 vr2 of
-        Just (Compatible v') -> Just v' `shouldBe` v
-        Nothing -> Nothing `shouldBe` v
diff --git a/source/tests/NtfClient.hs b/source/tests/NtfClient.hs
deleted file mode 100644
index 42a31db..0000000
--- a/source/tests/NtfClient.hs
+++ /dev/null
@@ -1,227 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DeriveAnyClass #-}
-{-# LANGUAGE DeriveGeneric #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE StandaloneDeriving #-}
-{-# LANGUAGE TypeApplications #-}
-{-# OPTIONS_GHC -fno-warn-orphans #-}
-
-module NtfClient where
-
-import Control.Monad
-import Control.Monad.Except (runExceptT)
-import Control.Monad.IO.Unlift
-import Data.Aeson (FromJSON (..), ToJSON (..), (.:))
-import qualified Data.Aeson as J
-import qualified Data.Aeson.Types as JT
-import Data.ByteString.Builder (lazyByteString)
-import Data.ByteString.Char8 (ByteString)
-import Data.List.NonEmpty (NonEmpty)
-import Data.Text (Text)
-import GHC.Generics (Generic)
-import Network.HTTP.Types (Status)
-import qualified Network.HTTP.Types as N
-import qualified Network.HTTP2.Server as H
-import Network.Socket
-import Simplex.Messaging.Client (chooseTransportHost, defaultNetworkConfig)
-import Simplex.Messaging.Client.Agent (defaultSMPClientAgentConfig)
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Notifications.Server (runNtfServerBlocking)
-import Simplex.Messaging.Notifications.Server.Env
-import Simplex.Messaging.Notifications.Server.Push.APNS
-import Simplex.Messaging.Notifications.Transport
-import Simplex.Messaging.Protocol
-import Simplex.Messaging.Transport
-import Simplex.Messaging.Transport.Client
-import Simplex.Messaging.Transport.HTTP2 (http2TLSParams)
-import Simplex.Messaging.Transport.HTTP2.Client
-import Simplex.Messaging.Transport.HTTP2.Server
-import Simplex.Messaging.Transport.KeepAlive
-import Test.Hspec
-import UnliftIO.Async
-import UnliftIO.Concurrent
-import qualified UnliftIO.Exception as E
-import UnliftIO.STM
-import UnliftIO.Timeout (timeout)
-
-testHost :: NonEmpty TransportHost
-testHost = "localhost"
-
-ntfTestPort :: ServiceName
-ntfTestPort = "6001"
-
-apnsTestPort :: ServiceName
-apnsTestPort = "6010"
-
-testKeyHash :: C.KeyHash
-testKeyHash = "LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI="
-
-ntfTestStoreLogFile :: FilePath
-ntfTestStoreLogFile = "tests/tmp/ntf-server-store.log"
-
-testNtfClient :: (Transport c, MonadUnliftIO m, MonadFail m) => (THandle c -> m a) -> m a
-testNtfClient client = do
-  Right host <- pure $ chooseTransportHost defaultNetworkConfig testHost
-  runTransportClient Nothing host ntfTestPort (Just testKeyHash) (Just defaultKeepAliveOpts) $ \h ->
-    liftIO (runExceptT $ ntfClientHandshake h testKeyHash supportedNTFServerVRange) >>= \case
-      Right th -> client th
-      Left e -> error $ show e
-
-ntfServerCfg :: NtfServerConfig
-ntfServerCfg =
-  NtfServerConfig
-    { transports = undefined,
-      subIdBytes = 24,
-      regCodeBytes = 32,
-      clientQSize = 1,
-      subQSize = 1,
-      pushQSize = 1,
-      smpAgentCfg = defaultSMPClientAgentConfig,
-      apnsConfig =
-        defaultAPNSPushClientConfig
-          { apnsPort = apnsTestPort,
-            http2cfg = defaultHTTP2ClientConfig {caStoreFile = "tests/fixtures/ca.crt"}
-          },
-      inactiveClientExpiration = Just defaultInactiveClientExpiration,
-      storeLogFile = Nothing,
-      resubscribeDelay = 1000,
-      -- CA certificate private key is not needed for initialization
-      caCertificateFile = "tests/fixtures/ca.crt",
-      privateKeyFile = "tests/fixtures/server.key",
-      certificateFile = "tests/fixtures/server.crt",
-      -- stats config
-      logStatsInterval = Nothing,
-      logStatsStartTime = 0,
-      serverStatsLogFile = "tests/ntf-server-stats.daily.log",
-      serverStatsBackupFile = Nothing
-    }
-
-withNtfServerStoreLog :: ATransport -> (ThreadId -> IO a) -> IO a
-withNtfServerStoreLog t = withNtfServerCfg t ntfServerCfg {storeLogFile = Just ntfTestStoreLogFile}
-
-withNtfServerThreadOn :: ATransport -> ServiceName -> (ThreadId -> IO a) -> IO a
-withNtfServerThreadOn t port' = withNtfServerCfg t ntfServerCfg {transports = [(port', t)]}
-
-withNtfServerCfg :: ATransport -> NtfServerConfig -> (ThreadId -> IO a) -> IO a
-withNtfServerCfg t cfg =
-  serverBracket
-    (\started -> runNtfServerBlocking started cfg {transports = [(ntfTestPort, t)]})
-    (pure ())
-
-serverBracket :: MonadUnliftIO m => (TMVar Bool -> m ()) -> m () -> (ThreadId -> m a) -> m a
-serverBracket process afterProcess f = do
-  started <- newEmptyTMVarIO
-  E.bracket
-    (forkIOWithUnmask ($ process started))
-    (\t -> killThread t >> afterProcess >> waitFor started "stop")
-    (\t -> waitFor started "start" >> f t)
-  where
-    waitFor started s =
-      5_000_000 `timeout` atomically (takeTMVar started) >>= \case
-        Nothing -> error $ "server did not " <> s
-        _ -> pure ()
-
-withNtfServerOn :: ATransport -> ServiceName -> IO a -> IO a
-withNtfServerOn t port' = withNtfServerThreadOn t port' . const
-
-withNtfServer :: ATransport -> IO a -> IO a
-withNtfServer t = withNtfServerOn t ntfTestPort
-
-runNtfTest :: forall c a. Transport c => (THandle c -> IO a) -> IO a
-runNtfTest test = withNtfServer (transport @c) $ testNtfClient test
-
-ntfServerTest ::
-  forall c smp.
-  (Transport c, Encoding smp) =>
-  TProxy c ->
-  (Maybe C.ASignature, ByteString, ByteString, smp) ->
-  IO (Maybe C.ASignature, ByteString, ByteString, BrokerMsg)
-ntfServerTest _ t = runNtfTest $ \h -> tPut' h t >> tGet' h
-  where
-    tPut' h (sig, corrId, queueId, smp) = do
-      let t' = smpEncode (sessionId (h :: THandle c), corrId, queueId, smp)
-      [Right ()] <- tPut h [(sig, t')]
-      pure ()
-    tGet' h = do
-      [(Nothing, _, (CorrId corrId, qId, Right cmd))] <- tGet h
-      pure (Nothing, corrId, qId, cmd)
-
-ntfTest :: Transport c => TProxy c -> (THandle c -> IO ()) -> Expectation
-ntfTest _ test' = runNtfTest test' `shouldReturn` ()
-
-data APNSMockRequest = APNSMockRequest
-  { notification :: APNSNotification,
-    sendApnsResponse :: APNSMockResponse -> IO ()
-  }
-
-data APNSMockResponse = APNSRespOk | APNSRespError Status Text
-
-data APNSMockServer = APNSMockServer
-  { action :: Async (),
-    apnsQ :: TBQueue APNSMockRequest,
-    http2Server :: HTTP2Server
-  }
-
-apnsMockServerConfig :: HTTP2ServerConfig
-apnsMockServerConfig =
-  HTTP2ServerConfig
-    { qSize = 1,
-      http2Port = apnsTestPort,
-      serverSupported = http2TLSParams,
-      caCertificateFile = "tests/fixtures/ca.crt",
-      privateKeyFile = "tests/fixtures/server.key",
-      certificateFile = "tests/fixtures/server.crt"
-    }
-
-withAPNSMockServer :: (APNSMockServer -> IO ()) -> IO ()
-withAPNSMockServer = E.bracket (getAPNSMockServer apnsMockServerConfig) closeAPNSMockServer
-
-deriving instance Generic APNSAlertBody
-
-instance FromJSON APNSAlertBody where
-  parseJSON (J.Object v) = do
-    title <- v .: "title"
-    subtitle <- v .: "subtitle"
-    body <- v .: "body"
-    pure APNSAlertObject {title, subtitle, body}
-  parseJSON (J.String v) = pure $ APNSAlertText v
-  parseJSON invalid = JT.prependFailure "parsing Coord failed, " (JT.typeMismatch "Object" invalid)
-
-instance FromJSON APNSNotificationBody where parseJSON = J.genericParseJSON apnsJSONOptions {J.rejectUnknownFields = True}
-
-deriving instance FromJSON APNSNotification
-
-deriving instance ToJSON APNSErrorResponse
-
-getAPNSMockServer :: HTTP2ServerConfig -> IO APNSMockServer
-getAPNSMockServer config@HTTP2ServerConfig {qSize} = do
-  http2Server <- getHTTP2Server config
-  apnsQ <- newTBQueueIO qSize
-  action <- async $ runAPNSMockServer apnsQ http2Server
-  pure APNSMockServer {action, apnsQ, http2Server}
-  where
-    runAPNSMockServer apnsQ HTTP2Server {reqQ} = forever $ do
-      HTTP2Request {reqBody, sendResponse} <- atomically $ readTBQueue reqQ
-      let sendApnsResponse = \case
-            APNSRespOk -> sendResponse $ H.responseNoBody N.ok200 []
-            APNSRespError status reason ->
-              sendResponse . H.responseBuilder status [] . lazyByteString $ J.encode APNSErrorResponse {reason}
-      case J.decodeStrict' reqBody of
-        Just notification ->
-          atomically $ writeTBQueue apnsQ APNSMockRequest {notification, sendApnsResponse}
-        _ -> do
-          putStrLn $ "runAPNSMockServer J.decodeStrict' error, reqBody: " <> show reqBody
-          sendApnsResponse $ APNSRespError N.badRequest400 "bad_request_body"
-
-closeAPNSMockServer :: APNSMockServer -> IO ()
-closeAPNSMockServer APNSMockServer {action, http2Server} = do
-  closeHTTP2Server http2Server
-  uninterruptibleCancel action
diff --git a/source/tests/NtfServerTests.hs b/source/tests/NtfServerTests.hs
deleted file mode 100644
index 42c4399..0000000
--- a/source/tests/NtfServerTests.hs
+++ /dev/null
@@ -1,167 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# OPTIONS_GHC -fno-warn-incomplete-uni-patterns #-}
-
-module NtfServerTests where
-
-import Control.Concurrent (threadDelay)
-import Control.Monad.Except (runExceptT)
-import qualified Data.Aeson as J
-import qualified Data.Aeson.Types as JT
-import Data.Bifunctor (first)
-import qualified Data.ByteString.Base64.URL as U
-import Data.ByteString.Char8 (ByteString)
-import Data.Text.Encoding (encodeUtf8)
-import NtfClient
-import SMPClient as SMP
-import ServerTests
-  ( createAndSecureQueue,
-    sampleDhPubKey,
-    samplePubKey,
-    sampleSig,
-    signSendRecv,
-    tGet1,
-    tPut1,
-    (#==),
-    _SEND',
-    pattern Resp,
-  )
-import qualified Simplex.Messaging.Agent.Protocol as AP
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Notifications.Protocol
-import Simplex.Messaging.Notifications.Server.Push.APNS
-import qualified Simplex.Messaging.Notifications.Server.Push.APNS as APNS
-import Simplex.Messaging.Parsers (parse, parseAll)
-import Simplex.Messaging.Protocol hiding (notification)
-import Simplex.Messaging.Transport
-import Test.Hspec
-import UnliftIO.STM
-
-ntfServerTests :: ATransport -> Spec
-ntfServerTests t = do
-  describe "Notifications server protocol syntax" $ ntfSyntaxTests t
-  describe "Notification subscriptions" $ testNotificationSubscription t
-
-ntfSyntaxTests :: ATransport -> Spec
-ntfSyntaxTests (ATransport t) = do
-  it "unknown command" $ ("", "abcd", "1234", ('H', 'E', 'L', 'L', 'O')) >#> ("", "abcd", "1234", ERR $ CMD UNKNOWN)
-  describe "NEW" $ do
-    it "no parameters" $ (sampleSig, "bcda", "", TNEW_) >#> ("", "bcda", "", ERR $ CMD SYNTAX)
-    it "many parameters" $ (sampleSig, "cdab", "", (TNEW_, (' ', '\x01', 'A'), ('T', 'A', 'T', "abcd" :: ByteString), samplePubKey, sampleDhPubKey)) >#> ("", "cdab", "", ERR $ CMD SYNTAX)
-    it "no signature" $ ("", "dabc", "", (TNEW_, ' ', ('T', 'A', 'T', "abcd" :: ByteString), samplePubKey, sampleDhPubKey)) >#> ("", "dabc", "", ERR $ CMD NO_AUTH)
-    it "token ID" $ (sampleSig, "abcd", "12345678", (TNEW_, ' ', ('T', 'A', 'T', "abcd" :: ByteString), samplePubKey, sampleDhPubKey)) >#> ("", "abcd", "12345678", ERR $ CMD HAS_AUTH)
-  where
-    (>#>) ::
-      Encoding smp =>
-      (Maybe C.ASignature, ByteString, ByteString, smp) ->
-      (Maybe C.ASignature, ByteString, ByteString, BrokerMsg) ->
-      Expectation
-    command >#> response = withAPNSMockServer $ \_ -> ntfServerTest t command `shouldReturn` response
-
-pattern RespNtf :: CorrId -> QueueId -> NtfResponse -> SignedTransmission NtfResponse
-pattern RespNtf corrId queueId command <- (_, _, (corrId, queueId, Right command))
-
-sendRecvNtf :: forall c e. (Transport c, NtfEntityI e) => THandle c -> (Maybe C.ASignature, ByteString, ByteString, NtfCommand e) -> IO (SignedTransmission NtfResponse)
-sendRecvNtf h@THandle {thVersion, sessionId} (sgn, corrId, qId, cmd) = do
-  let t = encodeTransmission thVersion sessionId (CorrId corrId, qId, cmd)
-  Right () <- tPut1 h (sgn, t)
-  tGet1 h
-
-signSendRecvNtf :: forall c e. (Transport c, NtfEntityI e) => THandle c -> C.APrivateSignKey -> (ByteString, ByteString, NtfCommand e) -> IO (SignedTransmission NtfResponse)
-signSendRecvNtf h@THandle {thVersion, sessionId} pk (corrId, qId, cmd) = do
-  let t = encodeTransmission thVersion sessionId (CorrId corrId, qId, cmd)
-  Right sig <- runExceptT $ C.sign pk t
-  Right () <- tPut1 h (Just sig, t)
-  tGet1 h
-
-(.->) :: J.Value -> J.Key -> Either String ByteString
-v .-> key =
-  let J.Object o = v
-   in U.decodeLenient . encodeUtf8 <$> JT.parseEither (J..: key) o
-
-testNotificationSubscription :: ATransport -> Spec
-testNotificationSubscription (ATransport t) =
-  it "should create notification subscription and notify when message is received" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    (nPub, nKey) <- C.generateSignatureKeyPair C.SEd25519
-    (tknPub, tknKey) <- C.generateSignatureKeyPair C.SEd25519
-    (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-    let tkn = DeviceToken PPApnsTest "abcd"
-    withAPNSMockServer $ \APNSMockServer {apnsQ} ->
-      smpTest2 t $ \rh sh ->
-        ntfTest t $ \nh -> do
-          -- create queue
-          (sId, rId, rKey, rcvDhSecret) <- createAndSecureQueue rh sPub
-          -- register and verify token
-          RespNtf "1" "" (NRTknId tId ntfDh) <- signSendRecvNtf nh tknKey ("1", "", TNEW $ NewNtfTkn tkn tknPub dhPub)
-          APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData}, sendApnsResponse = send} <-
-            atomically $ readTBQueue apnsQ
-          send APNSRespOk
-          let dhSecret = C.dh' ntfDh dhPriv
-              Right verification = ntfData .-> "verification"
-              Right nonce = C.cbNonce <$> ntfData .-> "nonce"
-              Right code = NtfRegCode <$> C.cbDecrypt dhSecret nonce verification
-          RespNtf "2" _ NROk <- signSendRecvNtf nh tknKey ("2", tId, TVFY code)
-          RespNtf "2a" _ (NRTkn NTActive) <- signSendRecvNtf nh tknKey ("2a", tId, TCHK)
-          -- enable queue notifications
-          (rcvNtfPubDhKey, rcvNtfPrivDhKey) <- C.generateKeyPair'
-          Resp "3" _ (NID nId rcvNtfSrvPubDhKey) <- signSendRecv rh rKey ("3", rId, NKEY nPub rcvNtfPubDhKey)
-          let srv = SMPServer SMP.testHost SMP.testPort SMP.testKeyHash
-              q = SMPQueueNtf srv nId
-              rcvNtfDhSecret = C.dh' rcvNtfSrvPubDhKey rcvNtfPrivDhKey
-          RespNtf "4" _ (NRSubId _subId) <- signSendRecvNtf nh tknKey ("4", "", SNEW $ NewNtfSub tId q nKey)
-          -- send message
-          threadDelay 50000
-          Resp "5" _ OK <- signSendRecv sh sKey ("5", sId, _SEND' "hello")
-          -- receive notification
-          APNSMockRequest {notification, sendApnsResponse = send'} <- atomically $ readTBQueue apnsQ
-          let APNSNotification {aps = APNSMutableContent {}, notificationData = Just ntfData'} = notification
-              Right nonce' = C.cbNonce <$> ntfData' .-> "nonce"
-              Right message = ntfData' .-> "message"
-              Right ntfDataDecrypted = C.cbDecrypt dhSecret nonce' message
-              Right APNS.PNMessageData {smpQueue = SMPQueueNtf {smpServer, notifierId}, nmsgNonce, encNMsgMeta} =
-                parse strP (AP.INTERNAL "error parsing PNMessageData") ntfDataDecrypted
-              Right nMsgMeta = C.cbDecrypt rcvNtfDhSecret nmsgNonce encNMsgMeta
-              Right NMsgMeta {msgId, msgTs} = parse smpP (AP.INTERNAL "error parsing NMsgMeta") nMsgMeta
-          smpServer `shouldBe` srv
-          notifierId `shouldBe` nId
-          send' APNSRespOk
-          -- receive message
-          Resp "" _ (MSG RcvMessage {msgId = mId1, msgBody = EncRcvMsgBody body}) <- tGet1 rh
-          Right ClientRcvMsgBody {msgTs = mTs, msgBody} <- pure $ parseAll clientRcvMsgBodyP =<< first show (C.cbDecrypt rcvDhSecret (C.cbNonce mId1) body)
-          mId1 `shouldBe` msgId
-          mTs `shouldBe` msgTs
-          (msgBody, "hello") #== "delivered from queue"
-          Resp "6" _ OK <- signSendRecv rh rKey ("6", rId, ACK mId1)
-          pure ()
-          -- replace token
-          let tkn' = DeviceToken PPApnsTest "efgh"
-          RespNtf "7" tId' NROk <- signSendRecvNtf nh tknKey ("7", tId, TRPL tkn')
-          tId `shouldBe` tId'
-          APNSMockRequest {notification = APNSNotification {aps = APNSBackground _, notificationData = Just ntfData2}, sendApnsResponse = send2} <-
-            atomically $ readTBQueue apnsQ
-          send2 APNSRespOk
-          let Right verification2 = ntfData2 .-> "verification"
-              Right nonce2 = C.cbNonce <$> ntfData2 .-> "nonce"
-              Right code2 = NtfRegCode <$> C.cbDecrypt dhSecret nonce2 verification2
-          RespNtf "8" _ NROk <- signSendRecvNtf nh tknKey ("8", tId, TVFY code2)
-          RespNtf "8a" _ (NRTkn NTActive) <- signSendRecvNtf nh tknKey ("8a", tId, TCHK)
-          -- send message
-          Resp "9" _ OK <- signSendRecv sh sKey ("9", sId, _SEND' "hello 2")
-          APNSMockRequest {notification = notification3, sendApnsResponse = send3} <- atomically $ readTBQueue apnsQ
-          let APNSNotification {aps = APNSMutableContent {}, notificationData = Just ntfData3} = notification3
-              Right nonce3 = C.cbNonce <$> ntfData3 .-> "nonce"
-              Right message3 = ntfData3 .-> "message"
-              Right ntfDataDecrypted3 = C.cbDecrypt dhSecret nonce3 message3
-              Right APNS.PNMessageData {smpQueue = SMPQueueNtf {smpServer = smpServer3, notifierId = notifierId3}} =
-                parse strP (AP.INTERNAL "error parsing PNMessageData") ntfDataDecrypted3
-          smpServer3 `shouldBe` srv
-          notifierId3 `shouldBe` nId
-          send3 APNSRespOk
diff --git a/source/tests/SMPAgentClient.hs b/source/tests/SMPAgentClient.hs
deleted file mode 100644
index 11ac7f2..0000000
--- a/source/tests/SMPAgentClient.hs
+++ /dev/null
@@ -1,238 +0,0 @@
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE TypeApplications #-}
-
-module SMPAgentClient where
-
-import Control.Monad.IO.Unlift
-import Crypto.Random
-import qualified Data.ByteString.Char8 as B
-import Data.List.NonEmpty (NonEmpty)
-import qualified Data.List.NonEmpty as L
-import Network.Socket (ServiceName)
-import NtfClient (ntfTestPort)
-import SMPClient
-  ( serverBracket,
-    testKeyHash,
-    testPort,
-    testPort2,
-    withSmpServer,
-    withSmpServerOn,
-    withSmpServerThreadOn,
-  )
-import Simplex.Messaging.Agent.Env.SQLite
-import Simplex.Messaging.Agent.Protocol
-import Simplex.Messaging.Agent.RetryInterval
-import Simplex.Messaging.Agent.Server (runSMPAgentBlocking)
-import Simplex.Messaging.Client (ProtocolClientConfig (..), chooseTransportHost, defaultClientConfig, defaultNetworkConfig)
-import Simplex.Messaging.Parsers (parseAll)
-import Simplex.Messaging.Transport
-import Simplex.Messaging.Transport.Client
-import Simplex.Messaging.Transport.KeepAlive
-import Test.Hspec
-import UnliftIO.Concurrent
-import UnliftIO.Directory
-
-agentTestHost :: NonEmpty TransportHost
-agentTestHost = "localhost"
-
-agentTestPort :: ServiceName
-agentTestPort = "5010"
-
-agentTestPort2 :: ServiceName
-agentTestPort2 = "5011"
-
-agentTestPort3 :: ServiceName
-agentTestPort3 = "5012"
-
-testDB :: AgentDatabase
-testDB = AgentDBFile {dbFile = "tests/tmp/smp-agent.test.protocol.db", dbKey = ""}
-
-testDB2 :: AgentDatabase
-testDB2 = AgentDBFile {dbFile = "tests/tmp/smp-agent2.test.protocol.db", dbKey = ""}
-
-testDB3 :: AgentDatabase
-testDB3 = AgentDBFile {dbFile = "tests/tmp/smp-agent3.test.protocol.db", dbKey = ""}
-
-smpAgentTest :: forall c. Transport c => TProxy c -> ARawTransmission -> IO ARawTransmission
-smpAgentTest _ cmd = runSmpAgentTest $ \(h :: c) -> tPutRaw h cmd >> get h
-  where
-    get h = do
-      t@(_, _, cmdStr) <- tGetRaw h
-      case parseAll networkCommandP cmdStr of
-        Right (ACmd SAgent CONNECT {}) -> get h
-        Right (ACmd SAgent DISCONNECT {}) -> get h
-        _ -> pure t
-
-runSmpAgentTest :: forall c a. Transport c => (c -> IO a) -> IO a
-runSmpAgentTest test = withSmpServer t . withSmpAgent t $ testSMPAgentClient test
-  where
-    t = transport @c
-
-runSmpAgentServerTest :: forall c a. Transport c => ((ThreadId, ThreadId) -> c -> IO a) -> IO a
-runSmpAgentServerTest test =
-  withSmpServerThreadOn t testPort $
-    \server -> withSmpAgentThreadOn t (agentTestPort, testPort, testDB) $
-      \agent -> testSMPAgentClient $ test (server, agent)
-  where
-    t = transport @c
-
-smpAgentServerTest :: Transport c => ((ThreadId, ThreadId) -> c -> IO ()) -> Expectation
-smpAgentServerTest test' = runSmpAgentServerTest test' `shouldReturn` ()
-
-runSmpAgentTestN :: forall c a. Transport c => [(ServiceName, ServiceName, AgentDatabase)] -> ([c] -> IO a) -> IO a
-runSmpAgentTestN agents test = withSmpServer t $ run agents []
-  where
-    run :: [(ServiceName, ServiceName, AgentDatabase)] -> [c] -> IO a
-    run [] hs = test hs
-    run (a@(p, _, _) : as) hs = withSmpAgentOn t a $ testSMPAgentClientOn p $ \h -> run as (h : hs)
-    t = transport @c
-
-runSmpAgentTestN_1 :: forall c a. Transport c => Int -> ([c] -> IO a) -> IO a
-runSmpAgentTestN_1 nClients test = withSmpServer t . withSmpAgent t $ run nClients []
-  where
-    run :: Int -> [c] -> IO a
-    run 0 hs = test hs
-    run n hs = testSMPAgentClient $ \h -> run (n - 1) (h : hs)
-    t = transport @c
-
-smpAgentTestN :: Transport c => [(ServiceName, ServiceName, AgentDatabase)] -> ([c] -> IO ()) -> Expectation
-smpAgentTestN agents test' = runSmpAgentTestN agents test' `shouldReturn` ()
-
-smpAgentTestN_1 :: Transport c => Int -> ([c] -> IO ()) -> Expectation
-smpAgentTestN_1 n test' = runSmpAgentTestN_1 n test' `shouldReturn` ()
-
-smpAgentTest2_2_2 :: forall c. Transport c => (c -> c -> IO ()) -> Expectation
-smpAgentTest2_2_2 test' =
-  withSmpServerOn (transport @c) testPort2 $
-    smpAgentTest2_2_2_needs_server test'
-
-smpAgentTest2_2_2_needs_server :: forall c. Transport c => (c -> c -> IO ()) -> Expectation
-smpAgentTest2_2_2_needs_server test' =
-  smpAgentTestN
-    [ (agentTestPort, testPort, testDB),
-      (agentTestPort2, testPort2, testDB2)
-    ]
-    _test
-  where
-    _test [h1, h2] = test' h1 h2
-    _test _ = error "expected 2 handles"
-
-smpAgentTest2_2_1 :: Transport c => (c -> c -> IO ()) -> Expectation
-smpAgentTest2_2_1 test' =
-  smpAgentTestN
-    [ (agentTestPort, testPort, testDB),
-      (agentTestPort2, testPort, testDB2)
-    ]
-    _test
-  where
-    _test [h1, h2] = test' h1 h2
-    _test _ = error "expected 2 handles"
-
-smpAgentTest2_1_1 :: Transport c => (c -> c -> IO ()) -> Expectation
-smpAgentTest2_1_1 test' = smpAgentTestN_1 2 _test
-  where
-    _test [h1, h2] = test' h1 h2
-    _test _ = error "expected 2 handles"
-
-smpAgentTest3 :: Transport c => (c -> c -> c -> IO ()) -> Expectation
-smpAgentTest3 test' =
-  smpAgentTestN
-    [ (agentTestPort, testPort, testDB),
-      (agentTestPort2, testPort, testDB2),
-      (agentTestPort3, testPort, testDB3)
-    ]
-    _test
-  where
-    _test [h1, h2, h3] = test' h1 h2 h3
-    _test _ = error "expected 3 handles"
-
-smpAgentTest3_1_1 :: Transport c => (c -> c -> c -> IO ()) -> Expectation
-smpAgentTest3_1_1 test' = smpAgentTestN_1 3 _test
-  where
-    _test [h1, h2, h3] = test' h1 h2 h3
-    _test _ = error "expected 3 handles"
-
-smpAgentTest1_1_1 :: forall c. Transport c => (c -> IO ()) -> Expectation
-smpAgentTest1_1_1 test' =
-  smpAgentTestN
-    [(agentTestPort2, testPort2, testDB2)]
-    _test
-  where
-    _test [h] = test' h
-    _test _ = error "expected 1 handle"
-
-testSMPServer :: SMPServer
-testSMPServer = "smp://LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI=@localhost:5001"
-
-testSMPServer2 :: SMPServer
-testSMPServer2 = "smp://LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI=@localhost:5002"
-
-initAgentServers :: InitialAgentServers
-initAgentServers =
-  InitialAgentServers
-    { smp = L.fromList [noAuthSrv testSMPServer],
-      ntf = ["ntf://LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI=@localhost:6001"],
-      netCfg = defaultNetworkConfig {tcpTimeout = 500_000}
-    }
-
-initAgentServers2 :: InitialAgentServers
-initAgentServers2 = initAgentServers {smp = L.fromList [noAuthSrv testSMPServer, noAuthSrv testSMPServer2]}
-
-agentCfg :: AgentConfig
-agentCfg =
-  defaultAgentConfig
-    { tcpPort = agentTestPort,
-      tbqSize = 4,
-      database = testDB,
-      smpCfg =
-        defaultClientConfig
-          { qSize = 1,
-            defaultTransport = (testPort, transport @TLS),
-            networkConfig = defaultNetworkConfig {tcpTimeout = 500_000}
-          },
-      ntfCfg =
-        defaultClientConfig
-          { qSize = 1,
-            defaultTransport = (ntfTestPort, transport @TLS)
-          },
-      reconnectInterval = defaultReconnectInterval {initialInterval = 50_000},
-      ntfWorkerDelay = 1000,
-      ntfSMPWorkerDelay = 1000,
-      caCertificateFile = "tests/fixtures/ca.crt",
-      privateKeyFile = "tests/fixtures/server.key",
-      certificateFile = "tests/fixtures/server.crt"
-    }
-
-withSmpAgentThreadOn_ :: (MonadUnliftIO m, MonadRandom m) => ATransport -> (ServiceName, ServiceName, AgentDatabase) -> m () -> (ThreadId -> m a) -> m a
-withSmpAgentThreadOn_ t (port', smpPort', db') afterProcess =
-  let cfg' = agentCfg {tcpPort = port', database = db'}
-      initServers' = initAgentServers {smp = L.fromList [ProtoServerWithAuth (SMPServer "localhost" smpPort' testKeyHash) Nothing]}
-   in serverBracket
-        (\started -> runSMPAgentBlocking t started cfg' initServers')
-        afterProcess
-
-withSmpAgentThreadOn :: (MonadUnliftIO m, MonadRandom m) => ATransport -> (ServiceName, ServiceName, AgentDatabase) -> (ThreadId -> m a) -> m a
-withSmpAgentThreadOn t a@(_, _, db') = withSmpAgentThreadOn_ t a $ removeFile (dbFile db')
-
-withSmpAgentOn :: (MonadUnliftIO m, MonadRandom m) => ATransport -> (ServiceName, ServiceName, AgentDatabase) -> m a -> m a
-withSmpAgentOn t (port', smpPort', db') = withSmpAgentThreadOn t (port', smpPort', db') . const
-
-withSmpAgent :: (MonadUnliftIO m, MonadRandom m) => ATransport -> m a -> m a
-withSmpAgent t = withSmpAgentOn t (agentTestPort, testPort, testDB)
-
-testSMPAgentClientOn :: (Transport c, MonadUnliftIO m, MonadFail m) => ServiceName -> (c -> m a) -> m a
-testSMPAgentClientOn port' client = do
-  Right useHost <- pure $ chooseTransportHost defaultNetworkConfig agentTestHost
-  runTransportClient Nothing useHost port' (Just testKeyHash) (Just defaultKeepAliveOpts) $ \h -> do
-    line <- liftIO $ getLn h
-    if line == "Welcome to SMP agent v" <> B.pack simplexMQVersion
-      then client h
-      else do
-        error $ "wrong welcome message: " <> B.unpack line
-
-testSMPAgentClient :: (Transport c, MonadUnliftIO m, MonadFail m) => (c -> m a) -> m a
-testSMPAgentClient = testSMPAgentClientOn agentTestPort
diff --git a/source/tests/SMPClient.hs b/source/tests/SMPClient.hs
deleted file mode 100644
index 0af206b..0000000
--- a/source/tests/SMPClient.hs
+++ /dev/null
@@ -1,179 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE FlexibleContexts #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NumericUnderscores #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE TypeApplications #-}
-
-module SMPClient where
-
-import Control.Monad.Except (runExceptT)
-import Control.Monad.IO.Unlift
-import Data.ByteString.Char8 (ByteString)
-import Data.List.NonEmpty (NonEmpty)
-import Network.Socket
-import Simplex.Messaging.Client (chooseTransportHost, defaultNetworkConfig)
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Protocol
-import Simplex.Messaging.Server (runSMPServerBlocking)
-import Simplex.Messaging.Server.Env.STM
-import Simplex.Messaging.Transport
-import Simplex.Messaging.Transport.Client
-import Simplex.Messaging.Transport.KeepAlive
-import Simplex.Messaging.Version
-import Test.Hspec
-import UnliftIO.Concurrent
-import qualified UnliftIO.Exception as E
-import UnliftIO.STM (TMVar, atomically, newEmptyTMVarIO, takeTMVar)
-import UnliftIO.Timeout (timeout)
-
-testHost :: NonEmpty TransportHost
-testHost = "localhost"
-
-testPort :: ServiceName
-testPort = "5001"
-
-testPort2 :: ServiceName
-testPort2 = "5002"
-
-testKeyHash :: C.KeyHash
-testKeyHash = "LcJUMfVhwD8yxjAiSaDzzGF3-kLG4Uh0Fl_ZIjrRwjI="
-
-testStoreLogFile :: FilePath
-testStoreLogFile = "tests/tmp/smp-server-store.log"
-
-testStoreLogFile2 :: FilePath
-testStoreLogFile2 = "tests/tmp/smp-server-store.log.2"
-
-testStoreMsgsFile :: FilePath
-testStoreMsgsFile = "tests/tmp/smp-server-messages.log"
-
-testServerStatsBackupFile :: FilePath
-testServerStatsBackupFile = "tests/tmp/smp-server-stats.log"
-
-testSMPClient :: (Transport c, MonadUnliftIO m, MonadFail m) => (THandle c -> m a) -> m a
-testSMPClient client = do
-  Right useHost <- pure $ chooseTransportHost defaultNetworkConfig testHost
-  runTransportClient Nothing useHost testPort (Just testKeyHash) (Just defaultKeepAliveOpts) $ \h ->
-    liftIO (runExceptT $ smpClientHandshake h testKeyHash supportedSMPServerVRange) >>= \case
-      Right th -> client th
-      Left e -> error $ show e
-
-cfgV2 :: ServerConfig
-cfgV2 = cfg {smpServerVRange = mkVersionRange 1 2}
-
-cfg :: ServerConfig
-cfg =
-  ServerConfig
-    { transports = undefined,
-      tbqSize = 1,
-      serverTbqSize = 1,
-      msgQueueQuota = 4,
-      queueIdBytes = 24,
-      msgIdBytes = 24,
-      storeLogFile = Nothing,
-      storeMsgsFile = Nothing,
-      allowNewQueues = True,
-      newQueueBasicAuth = Nothing,
-      messageExpiration = Just defaultMessageExpiration,
-      inactiveClientExpiration = Just defaultInactiveClientExpiration,
-      logStatsInterval = Nothing,
-      logStatsStartTime = 0,
-      serverStatsLogFile = "tests/smp-server-stats.daily.log",
-      serverStatsBackupFile = Nothing,
-      caCertificateFile = "tests/fixtures/ca.crt",
-      privateKeyFile = "tests/fixtures/server.key",
-      certificateFile = "tests/fixtures/server.crt",
-      smpServerVRange = supportedSMPServerVRange
-    }
-
-withSmpServerStoreMsgLogOnV2 :: ATransport -> ServiceName -> (ThreadId -> IO a) -> IO a
-withSmpServerStoreMsgLogOnV2 t = withSmpServerConfigOn t cfgV2 {storeLogFile = Just testStoreLogFile, storeMsgsFile = Just testStoreMsgsFile}
-
-withSmpServerStoreMsgLogOn :: ATransport -> ServiceName -> (ThreadId -> IO a) -> IO a
-withSmpServerStoreMsgLogOn t = withSmpServerConfigOn t cfg {storeLogFile = Just testStoreLogFile, storeMsgsFile = Just testStoreMsgsFile, serverStatsBackupFile = Just testServerStatsBackupFile}
-
-withSmpServerStoreLogOn :: ATransport -> ServiceName -> (ThreadId -> IO a) -> IO a
-withSmpServerStoreLogOn t = withSmpServerConfigOn t cfg {storeLogFile = Just testStoreLogFile, serverStatsBackupFile = Just testServerStatsBackupFile}
-
-withSmpServerConfigOn :: ATransport -> ServerConfig -> ServiceName -> (ThreadId -> IO a) -> IO a
-withSmpServerConfigOn t cfg' port' =
-  serverBracket
-    (\started -> runSMPServerBlocking started cfg' {transports = [(port', t)]})
-    (pure ())
-
-withSmpServerThreadOn :: ATransport -> ServiceName -> (ThreadId -> IO a) -> IO a
-withSmpServerThreadOn t = withSmpServerConfigOn t cfg
-
-serverBracket :: MonadUnliftIO m => (TMVar Bool -> m ()) -> m () -> (ThreadId -> m a) -> m a
-serverBracket process afterProcess f = do
-  started <- newEmptyTMVarIO
-  E.bracket
-    (forkIOWithUnmask ($ process started))
-    (\t -> killThread t >> afterProcess >> waitFor started "stop")
-    (\t -> waitFor started "start" >> f t)
-  where
-    waitFor started s =
-      5_000_000 `timeout` atomically (takeTMVar started) >>= \case
-        Nothing -> error $ "server did not " <> s
-        _ -> pure ()
-
-withSmpServerOn :: ATransport -> ServiceName -> IO a -> IO a
-withSmpServerOn t port' = withSmpServerThreadOn t port' . const
-
-withSmpServer :: ATransport -> IO a -> IO a
-withSmpServer t = withSmpServerOn t testPort
-
-runSmpTest :: forall c a. Transport c => (THandle c -> IO a) -> IO a
-runSmpTest test = withSmpServer (transport @c) $ testSMPClient test
-
-runSmpTestN :: forall c a. Transport c => Int -> ([THandle c] -> IO a) -> IO a
-runSmpTestN nClients test = withSmpServer (transport @c) $ run nClients []
-  where
-    run :: Int -> [THandle c] -> IO a
-    run 0 hs = test hs
-    run n hs = testSMPClient $ \h -> run (n - 1) (h : hs)
-
-smpServerTest ::
-  forall c smp.
-  (Transport c, Encoding smp) =>
-  TProxy c ->
-  (Maybe C.ASignature, ByteString, ByteString, smp) ->
-  IO (Maybe C.ASignature, ByteString, ByteString, BrokerMsg)
-smpServerTest _ t = runSmpTest $ \h -> tPut' h t >> tGet' h
-  where
-    tPut' h (sig, corrId, queueId, smp) = do
-      let t' = smpEncode (sessionId (h :: THandle c), corrId, queueId, smp)
-      [Right ()] <- tPut h [(sig, t')]
-      pure ()
-    tGet' h = do
-      [(Nothing, _, (CorrId corrId, qId, Right cmd))] <- tGet h
-      pure (Nothing, corrId, qId, cmd)
-
-smpTest :: Transport c => TProxy c -> (THandle c -> IO ()) -> Expectation
-smpTest _ test' = runSmpTest test' `shouldReturn` ()
-
-smpTestN :: Transport c => Int -> ([THandle c] -> IO ()) -> Expectation
-smpTestN n test' = runSmpTestN n test' `shouldReturn` ()
-
-smpTest2 :: Transport c => TProxy c -> (THandle c -> THandle c -> IO ()) -> Expectation
-smpTest2 _ test' = smpTestN 2 _test
-  where
-    _test [h1, h2] = test' h1 h2
-    _test _ = error "expected 2 handles"
-
-smpTest3 :: Transport c => TProxy c -> (THandle c -> THandle c -> THandle c -> IO ()) -> Expectation
-smpTest3 _ test' = smpTestN 3 _test
-  where
-    _test [h1, h2, h3] = test' h1 h2 h3
-    _test _ = error "expected 3 handles"
-
-smpTest4 :: Transport c => TProxy c -> (THandle c -> THandle c -> THandle c -> THandle c -> IO ()) -> Expectation
-smpTest4 _ test' = smpTestN 4 _test
-  where
-    _test [h1, h2, h3, h4] = test' h1 h2 h3 h4
-    _test _ = error "expected 4 handles"
diff --git a/source/tests/ServerTests.hs b/source/tests/ServerTests.hs
deleted file mode 100644
index 5dd98fe..0000000
--- a/source/tests/ServerTests.hs
+++ /dev/null
@@ -1,920 +0,0 @@
-{-# LANGUAGE DataKinds #-}
-{-# LANGUAGE DuplicateRecordFields #-}
-{-# LANGUAGE GADTs #-}
-{-# LANGUAGE LambdaCase #-}
-{-# LANGUAGE NamedFieldPuns #-}
-{-# LANGUAGE OverloadedLists #-}
-{-# LANGUAGE OverloadedStrings #-}
-{-# LANGUAGE PatternSynonyms #-}
-{-# LANGUAGE ScopedTypeVariables #-}
-{-# LANGUAGE TypeApplications #-}
-
-module ServerTests where
-
-import Control.Concurrent (ThreadId, killThread, threadDelay)
-import Control.Concurrent.STM
-import Control.Exception (SomeException, try)
-import Control.Monad.Except (forM, forM_, runExceptT)
-import Control.Monad.IO.Class
-import Data.Bifunctor (first)
-import Data.ByteString.Base64
-import Data.ByteString.Char8 (ByteString)
-import qualified Data.ByteString.Char8 as B
-import SMPClient
-import qualified Simplex.Messaging.Crypto as C
-import Simplex.Messaging.Encoding
-import Simplex.Messaging.Encoding.String
-import Simplex.Messaging.Parsers (parseAll)
-import Simplex.Messaging.Protocol
-import Simplex.Messaging.Server.Env.STM (ServerConfig (..))
-import Simplex.Messaging.Server.Expiration
-import Simplex.Messaging.Transport
-import System.Directory (removeFile)
-import System.TimeIt (timeItT)
-import System.Timeout
-import Test.HUnit
-import Test.Hspec
-
-serverTests :: ATransport -> Spec
-serverTests t@(ATransport t') = do
-  describe "SMP syntax" $ syntaxTests t
-  describe "SMP queues" $ do
-    describe "NEW and KEY commands, SEND messages (v2)" $ testCreateSecureV2 t'
-    describe "NEW and KEY commands, SEND messages (v3)" $ testCreateSecure t
-    describe "NEW, OFF and DEL commands, SEND messages" $ testCreateDelete t
-    describe "Stress test" $ stressTest t
-    describe "allowNewQueues setting" $ testAllowNewQueues t'
-  describe "SMP messages" $ do
-    describe "duplex communication over 2 SMP connections" $ testDuplex t
-    describe "switch subscription to another TCP connection" $ testSwitchSub t
-    describe "GET command" $ testGetCommand t'
-    describe "GET & SUB commands" $ testGetSubCommands t'
-  describe "Store log" $ testWithStoreLog t
-  describe "Restore messages" $ testRestoreMessages t
-  describe "Restore messages (v2)" $ testRestoreMessagesV2 t
-  describe "Timing of AUTH error" $ testTiming t
-  describe "Message notifications" $ testMessageNotifications t
-  describe "Message expiration" $ do
-    testMsgExpireOnSend t'
-    testMsgExpireOnInterval t'
-    testMsgNOTExpireOnInterval t'
-
-pattern Resp :: CorrId -> QueueId -> BrokerMsg -> SignedTransmission BrokerMsg
-pattern Resp corrId queueId command <- (_, _, (corrId, queueId, Right command))
-
-pattern Ids :: RecipientId -> SenderId -> RcvPublicDhKey -> BrokerMsg
-pattern Ids rId sId srvDh <- IDS (QIK rId sId srvDh)
-
-pattern Msg :: MsgId -> MsgBody -> BrokerMsg
-pattern Msg msgId body <- MSG RcvMessage {msgId, msgBody = EncRcvMsgBody body}
-
-sendRecv :: forall c p. (Transport c, PartyI p) => THandle c -> (Maybe C.ASignature, ByteString, ByteString, Command p) -> IO (SignedTransmission BrokerMsg)
-sendRecv h@THandle {thVersion, sessionId} (sgn, corrId, qId, cmd) = do
-  let t = encodeTransmission thVersion sessionId (CorrId corrId, qId, cmd)
-  Right () <- tPut1 h (sgn, t)
-  tGet1 h
-
-signSendRecv :: forall c p. (Transport c, PartyI p) => THandle c -> C.APrivateSignKey -> (ByteString, ByteString, Command p) -> IO (SignedTransmission BrokerMsg)
-signSendRecv h@THandle {thVersion, sessionId} pk (corrId, qId, cmd) = do
-  let t = encodeTransmission thVersion sessionId (CorrId corrId, qId, cmd)
-  Right sig <- runExceptT $ C.sign pk t
-  Right () <- tPut1 h (Just sig, t)
-  tGet1 h
-
-tPut1 :: Transport c => THandle c -> SentRawTransmission -> IO (Either TransportError ())
-tPut1 h t = do
-  [r] <- tPut h [t]
-  pure r
-
-tGet1 :: (ProtocolEncoding cmd, Transport c, MonadIO m, MonadFail m) => THandle c -> m (SignedTransmission cmd)
-tGet1 h = do
-  [r] <- tGet h
-  pure r
-
-(#==) :: (HasCallStack, Eq a, Show a) => (a, a) -> String -> Assertion
-(actual, expected) #== message = assertEqual message expected actual
-
-_SEND :: MsgBody -> Command 'Sender
-_SEND = SEND noMsgFlags
-
-_SEND' :: MsgBody -> Command 'Sender
-_SEND' = SEND MsgFlags {notification = True}
-
-decryptMsgV2 :: C.DhSecret 'C.X25519 -> ByteString -> ByteString -> Either C.CryptoError ByteString
-decryptMsgV2 dhShared = C.cbDecrypt dhShared . C.cbNonce
-
-decryptMsgV3 :: C.DhSecret 'C.X25519 -> ByteString -> ByteString -> Either String MsgBody
-decryptMsgV3 dhShared nonce body = do
-  ClientRcvMsgBody {msgBody} <- parseAll clientRcvMsgBodyP =<< first show (C.cbDecrypt dhShared (C.cbNonce nonce) body)
-  pure msgBody
-
-testCreateSecureV2 :: forall c. Transport c => TProxy c -> Spec
-testCreateSecureV2 _ =
-  it "should create (NEW) and secure (KEY) queue" $
-    withSmpServerConfigOn (transport @c) cfgV2 testPort $ \_ -> testSMPClient @c $ \h -> do
-      (rPub, rKey) <- C.generateSignatureKeyPair C.SEd448
-      (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" rId1 (Ids rId sId srvDh) <- signSendRecv h rKey ("abcd", "", NEW rPub dhPub Nothing)
-      let dec = decryptMsgV2 $ C.dh' srvDh dhPriv
-      (rId1, "") #== "creates queue"
-
-      Resp "bcda" sId1 ok1 <- sendRecv h ("", "bcda", sId, _SEND "hello")
-      (ok1, OK) #== "accepts unsigned SEND"
-      (sId1, sId) #== "same queue ID in response 1"
-
-      Resp "" _ (Msg mId1 msg1) <- tGet1 h
-      (dec mId1 msg1, Right "hello") #== "delivers message"
-
-      Resp "cdab" _ ok4 <- signSendRecv h rKey ("cdab", rId, ACK mId1)
-      (ok4, OK) #== "replies OK when message acknowledged if no more messages"
-
-      Resp "dabc" _ err6 <- signSendRecv h rKey ("dabc", rId, ACK mId1)
-      (err6, ERR NO_MSG) #== "replies ERR when message acknowledged without messages"
-
-      (sPub, sKey) <- C.generateSignatureKeyPair C.SEd448
-      Resp "abcd" sId2 err1 <- signSendRecv h sKey ("abcd", sId, _SEND "hello")
-      (err1, ERR AUTH) #== "rejects signed SEND"
-      (sId2, sId) #== "same queue ID in response 2"
-
-      Resp "bcda" _ err2 <- sendRecv h (sampleSig, "bcda", rId, KEY sPub)
-      (err2, ERR AUTH) #== "rejects KEY with wrong signature"
-
-      Resp "cdab" _ err3 <- signSendRecv h rKey ("cdab", sId, KEY sPub)
-      (err3, ERR AUTH) #== "rejects KEY with sender's ID"
-
-      Resp "dabc" rId2 ok2 <- signSendRecv h rKey ("dabc", rId, KEY sPub)
-      (ok2, OK) #== "secures queue"
-      (rId2, rId) #== "same queue ID in response 3"
-
-      Resp "abcd" _ OK <- signSendRecv h rKey ("abcd", rId, KEY sPub)
-      (sPub', _) <- C.generateSignatureKeyPair C.SEd448
-      Resp "abcd" _ err4 <- signSendRecv h rKey ("abcd", rId, KEY sPub')
-      (err4, ERR AUTH) #== "rejects if secured with different key"
-
-      Resp "bcda" _ ok3 <- signSendRecv h sKey ("bcda", sId, _SEND "hello again")
-      (ok3, OK) #== "accepts signed SEND"
-
-      Resp "" _ (Msg mId2 msg2) <- tGet1 h
-      (dec mId2 msg2, Right "hello again") #== "delivers message 2"
-
-      Resp "cdab" _ ok5 <- signSendRecv h rKey ("cdab", rId, ACK mId2)
-      (ok5, OK) #== "replies OK when message acknowledged 2"
-
-      Resp "dabc" _ err5 <- sendRecv h ("", "dabc", sId, _SEND "hello")
-      (err5, ERR AUTH) #== "rejects unsigned SEND"
-
-      let maxAllowedMessage = B.replicate maxMessageLength '-'
-      Resp "bcda" _ OK <- signSendRecv h sKey ("bcda", sId, _SEND maxAllowedMessage)
-      Resp "" _ (Msg mId3 msg3) <- tGet1 h
-      (dec mId3 msg3, Right maxAllowedMessage) #== "delivers message of max size"
-
-      let biggerMessage = B.replicate (maxMessageLength + 1) '-'
-      Resp "bcda" _ (ERR LARGE_MSG) <- signSendRecv h sKey ("bcda", sId, _SEND biggerMessage)
-      pure ()
-
-testCreateSecure :: ATransport -> Spec
-testCreateSecure (ATransport t) =
-  it "should create (NEW) and secure (KEY) queue" $
-    smpTest t $ \h -> do
-      (rPub, rKey) <- C.generateSignatureKeyPair C.SEd448
-      (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" rId1 (Ids rId sId srvDh) <- signSendRecv h rKey ("abcd", "", NEW rPub dhPub Nothing)
-      let dec = decryptMsgV3 $ C.dh' srvDh dhPriv
-      (rId1, "") #== "creates queue"
-
-      Resp "bcda" sId1 ok1 <- sendRecv h ("", "bcda", sId, _SEND "hello")
-      (ok1, OK) #== "accepts unsigned SEND"
-      (sId1, sId) #== "same queue ID in response 1"
-
-      Resp "" _ (Msg mId1 msg1) <- tGet1 h
-      (dec mId1 msg1, Right "hello") #== "delivers message"
-
-      Resp "cdab" _ ok4 <- signSendRecv h rKey ("cdab", rId, ACK mId1)
-      (ok4, OK) #== "replies OK when message acknowledged if no more messages"
-
-      Resp "dabc" _ err6 <- signSendRecv h rKey ("dabc", rId, ACK mId1)
-      (err6, ERR NO_MSG) #== "replies ERR when message acknowledged without messages"
-
-      (sPub, sKey) <- C.generateSignatureKeyPair C.SEd448
-      Resp "abcd" sId2 err1 <- signSendRecv h sKey ("abcd", sId, _SEND "hello")
-      (err1, ERR AUTH) #== "rejects signed SEND"
-      (sId2, sId) #== "same queue ID in response 2"
-
-      Resp "bcda" _ err2 <- sendRecv h (sampleSig, "bcda", rId, KEY sPub)
-      (err2, ERR AUTH) #== "rejects KEY with wrong signature"
-
-      Resp "cdab" _ err3 <- signSendRecv h rKey ("cdab", sId, KEY sPub)
-      (err3, ERR AUTH) #== "rejects KEY with sender's ID"
-
-      Resp "dabc" rId2 ok2 <- signSendRecv h rKey ("dabc", rId, KEY sPub)
-      (ok2, OK) #== "secures queue"
-      (rId2, rId) #== "same queue ID in response 3"
-
-      Resp "abcd" _ OK <- signSendRecv h rKey ("abcd", rId, KEY sPub)
-      (sPub', _) <- C.generateSignatureKeyPair C.SEd448
-      Resp "abcd" _ err4 <- signSendRecv h rKey ("abcd", rId, KEY sPub')
-      (err4, ERR AUTH) #== "rejects if secured with different key"
-
-      Resp "bcda" _ ok3 <- signSendRecv h sKey ("bcda", sId, _SEND "hello again")
-      (ok3, OK) #== "accepts signed SEND"
-
-      Resp "" _ (Msg mId2 msg2) <- tGet1 h
-      (dec mId2 msg2, Right "hello again") #== "delivers message 2"
-
-      Resp "cdab" _ ok5 <- signSendRecv h rKey ("cdab", rId, ACK mId2)
-      (ok5, OK) #== "replies OK when message acknowledged 2"
-
-      Resp "dabc" _ err5 <- sendRecv h ("", "dabc", sId, _SEND "hello")
-      (err5, ERR AUTH) #== "rejects unsigned SEND"
-
-      let maxAllowedMessage = B.replicate maxMessageLength '-'
-      Resp "bcda" _ OK <- signSendRecv h sKey ("bcda", sId, _SEND maxAllowedMessage)
-      Resp "" _ (Msg mId3 msg3) <- tGet1 h
-      (dec mId3 msg3, Right maxAllowedMessage) #== "delivers message of max size"
-
-      let biggerMessage = B.replicate (maxMessageLength + 1) '-'
-      Resp "bcda" _ (ERR LARGE_MSG) <- signSendRecv h sKey ("bcda", sId, _SEND biggerMessage)
-      pure ()
-
-testCreateDelete :: ATransport -> Spec
-testCreateDelete (ATransport t) =
-  it "should create (NEW), suspend (OFF) and delete (DEL) queue" $
-    smpTest2 t $ \rh sh -> do
-      (rPub, rKey) <- C.generateSignatureKeyPair C.SEd25519
-      (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" rId1 (Ids rId sId srvDh) <- signSendRecv rh rKey ("abcd", "", NEW rPub dhPub Nothing)
-      let dec = decryptMsgV3 $ C.dh' srvDh dhPriv
-      (rId1, "") #== "creates queue"
-
-      (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-      Resp "bcda" _ ok1 <- signSendRecv rh rKey ("bcda", rId, KEY sPub)
-      (ok1, OK) #== "secures queue"
-
-      Resp "cdab" _ ok2 <- signSendRecv sh sKey ("cdab", sId, _SEND "hello")
-      (ok2, OK) #== "accepts signed SEND"
-
-      Resp "dabc" _ ok7 <- signSendRecv sh sKey ("dabc", sId, _SEND "hello 2")
-      (ok7, OK) #== "accepts signed SEND 2 - this message is not delivered because the first is not ACKed"
-
-      Resp "" _ (Msg mId1 msg1) <- tGet1 rh
-      (dec mId1 msg1, Right "hello") #== "delivers message"
-
-      Resp "abcd" _ err1 <- sendRecv rh (sampleSig, "abcd", rId, OFF)
-      (err1, ERR AUTH) #== "rejects OFF with wrong signature"
-
-      Resp "bcda" _ err2 <- signSendRecv rh rKey ("bcda", sId, OFF)
-      (err2, ERR AUTH) #== "rejects OFF with sender's ID"
-
-      Resp "cdab" rId2 ok3 <- signSendRecv rh rKey ("cdab", rId, OFF)
-      (ok3, OK) #== "suspends queue"
-      (rId2, rId) #== "same queue ID in response 2"
-
-      Resp "dabc" _ err3 <- signSendRecv sh sKey ("dabc", sId, _SEND "hello")
-      (err3, ERR AUTH) #== "rejects signed SEND"
-
-      Resp "abcd" _ err4 <- sendRecv sh ("", "abcd", sId, _SEND "hello")
-      (err4, ERR AUTH) #== "reject unsigned SEND too"
-
-      Resp "bcda" _ ok4 <- signSendRecv rh rKey ("bcda", rId, OFF)
-      (ok4, OK) #== "accepts OFF when suspended"
-
-      Resp "cdab" _ (Msg mId2 msg2) <- signSendRecv rh rKey ("cdab", rId, SUB)
-      (dec mId2 msg2, Right "hello") #== "accepts SUB when suspended and delivers the message again (because was not ACKed)"
-
-      Resp "dabc" _ err5 <- sendRecv rh (sampleSig, "dabc", rId, DEL)
-      (err5, ERR AUTH) #== "rejects DEL with wrong signature"
-
-      Resp "abcd" _ err6 <- signSendRecv rh rKey ("abcd", sId, DEL)
-      (err6, ERR AUTH) #== "rejects DEL with sender's ID"
-
-      Resp "bcda" rId3 ok6 <- signSendRecv rh rKey ("bcda", rId, DEL)
-      (ok6, OK) #== "deletes queue"
-      (rId3, rId) #== "same queue ID in response 3"
-
-      Resp "cdab" _ err7 <- signSendRecv sh sKey ("cdab", sId, _SEND "hello")
-      (err7, ERR AUTH) #== "rejects signed SEND when deleted"
-
-      Resp "dabc" _ err8 <- sendRecv sh ("", "dabc", sId, _SEND "hello")
-      (err8, ERR AUTH) #== "rejects unsigned SEND too when deleted"
-
-      Resp "abcd" _ err11 <- signSendRecv rh rKey ("abcd", rId, ACK "")
-      (err11, ERR AUTH) #== "rejects ACK when conn deleted - the second message is deleted"
-
-      Resp "bcda" _ err9 <- signSendRecv rh rKey ("bcda", rId, OFF)
-      (err9, ERR AUTH) #== "rejects OFF when deleted"
-
-      Resp "cdab" _ err10 <- signSendRecv rh rKey ("cdab", rId, SUB)
-      (err10, ERR AUTH) #== "rejects SUB when deleted"
-
-stressTest :: ATransport -> Spec
-stressTest (ATransport t) =
-  it "should create many queues, disconnect and re-connect" $
-    smpTest3 t $ \h1 h2 h3 -> do
-      (rPub, rKey) <- C.generateSignatureKeyPair C.SEd25519
-      (dhPub, _ :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      rIds <- forM ([1 .. 50] :: [Int]) . const $ do
-        Resp "" "" (Ids rId _ _) <- signSendRecv h1 rKey ("", "", NEW rPub dhPub Nothing)
-        pure rId
-      let subscribeQueues h = forM_ rIds $ \rId -> do
-            Resp "" rId' OK <- signSendRecv h rKey ("", rId, SUB)
-            rId' `shouldBe` rId
-      closeConnection $ connection h1
-      subscribeQueues h2
-      closeConnection $ connection h2
-      subscribeQueues h3
-
-testAllowNewQueues :: forall c. Transport c => TProxy c -> Spec
-testAllowNewQueues t =
-  it "should prohibit creating new queues with allowNewQueues = False" $ do
-    withSmpServerConfigOn (ATransport t) cfg {allowNewQueues = False} testPort $ \_ ->
-      testSMPClient @c $ \h -> do
-        (rPub, rKey) <- C.generateSignatureKeyPair C.SEd448
-        (dhPub, _ :: C.PrivateKeyX25519) <- C.generateKeyPair'
-        Resp "abcd" "" (ERR AUTH) <- signSendRecv h rKey ("abcd", "", NEW rPub dhPub Nothing)
-        pure ()
-
-testDuplex :: ATransport -> Spec
-testDuplex (ATransport t) =
-  it "should create 2 simplex connections and exchange messages" $
-    smpTest2 t $ \alice bob -> do
-      (arPub, arKey) <- C.generateSignatureKeyPair C.SEd448
-      (aDhPub, aDhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" _ (Ids aRcv aSnd aSrvDh) <- signSendRecv alice arKey ("abcd", "", NEW arPub aDhPub Nothing)
-      let aDec = decryptMsgV3 $ C.dh' aSrvDh aDhPriv
-      -- aSnd ID is passed to Bob out-of-band
-
-      (bsPub, bsKey) <- C.generateSignatureKeyPair C.SEd448
-      Resp "bcda" _ OK <- sendRecv bob ("", "bcda", aSnd, _SEND $ "key " <> strEncode bsPub)
-      -- "key ..." is ad-hoc, not a part of SMP protocol
-
-      Resp "" _ (Msg mId1 msg1) <- tGet1 alice
-      Resp "cdab" _ OK <- signSendRecv alice arKey ("cdab", aRcv, ACK mId1)
-      Right ["key", bobKey] <- pure $ B.words <$> aDec mId1 msg1
-      (bobKey, strEncode bsPub) #== "key received from Bob"
-      Resp "dabc" _ OK <- signSendRecv alice arKey ("dabc", aRcv, KEY bsPub)
-
-      (brPub, brKey) <- C.generateSignatureKeyPair C.SEd448
-      (bDhPub, bDhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" _ (Ids bRcv bSnd bSrvDh) <- signSendRecv bob brKey ("abcd", "", NEW brPub bDhPub Nothing)
-      let bDec = decryptMsgV3 $ C.dh' bSrvDh bDhPriv
-      Resp "bcda" _ OK <- signSendRecv bob bsKey ("bcda", aSnd, _SEND $ "reply_id " <> encode bSnd)
-      -- "reply_id ..." is ad-hoc, not a part of SMP protocol
-
-      Resp "" _ (Msg mId2 msg2) <- tGet1 alice
-      Resp "cdab" _ OK <- signSendRecv alice arKey ("cdab", aRcv, ACK mId2)
-      Right ["reply_id", bId] <- pure $ B.words <$> aDec mId2 msg2
-      (bId, encode bSnd) #== "reply queue ID received from Bob"
-
-      (asPub, asKey) <- C.generateSignatureKeyPair C.SEd448
-      Resp "dabc" _ OK <- sendRecv alice ("", "dabc", bSnd, _SEND $ "key " <> strEncode asPub)
-      -- "key ..." is ad-hoc, not a part of  SMP protocol
-
-      Resp "" _ (Msg mId3 msg3) <- tGet1 bob
-      Resp "abcd" _ OK <- signSendRecv bob brKey ("abcd", bRcv, ACK mId3)
-      Right ["key", aliceKey] <- pure $ B.words <$> bDec mId3 msg3
-      (aliceKey, strEncode asPub) #== "key received from Alice"
-      Resp "bcda" _ OK <- signSendRecv bob brKey ("bcda", bRcv, KEY asPub)
-
-      Resp "cdab" _ OK <- signSendRecv bob bsKey ("cdab", aSnd, _SEND "hi alice")
-
-      Resp "" _ (Msg mId4 msg4) <- tGet1 alice
-      Resp "dabc" _ OK <- signSendRecv alice arKey ("dabc", aRcv, ACK mId4)
-      (aDec mId4 msg4, Right "hi alice") #== "message received from Bob"
-
-      Resp "abcd" _ OK <- signSendRecv alice asKey ("abcd", bSnd, _SEND "how are you bob")
-
-      Resp "" _ (Msg mId5 msg5) <- tGet1 bob
-      Resp "bcda" _ OK <- signSendRecv bob brKey ("bcda", bRcv, ACK mId5)
-      (bDec mId5 msg5, Right "how are you bob") #== "message received from alice"
-
-testSwitchSub :: ATransport -> Spec
-testSwitchSub (ATransport t) =
-  it "should create simplex connections and switch subscription to another TCP connection" $
-    smpTest3 t $ \rh1 rh2 sh -> do
-      (rPub, rKey) <- C.generateSignatureKeyPair C.SEd448
-      (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" _ (Ids rId sId srvDh) <- signSendRecv rh1 rKey ("abcd", "", NEW rPub dhPub Nothing)
-      let dec = decryptMsgV3 $ C.dh' srvDh dhPriv
-      Resp "bcda" _ ok1 <- sendRecv sh ("", "bcda", sId, _SEND "test1")
-      (ok1, OK) #== "sent test message 1"
-      Resp "cdab" _ ok2 <- sendRecv sh ("", "cdab", sId, _SEND "test2, no ACK")
-      (ok2, OK) #== "sent test message 2"
-
-      Resp "" _ (Msg mId1 msg1) <- tGet1 rh1
-      (dec mId1 msg1, Right "test1") #== "test message 1 delivered to the 1st TCP connection"
-      Resp "abcd" _ (Msg mId2 msg2) <- signSendRecv rh1 rKey ("abcd", rId, ACK mId1)
-      (dec mId2 msg2, Right "test2, no ACK") #== "test message 2 delivered, no ACK"
-
-      Resp "bcda" _ (Msg mId2' msg2') <- signSendRecv rh2 rKey ("bcda", rId, SUB)
-      (dec mId2' msg2', Right "test2, no ACK") #== "same simplex queue via another TCP connection, tes2 delivered again (no ACK in 1st queue)"
-      Resp "cdab" _ OK <- signSendRecv rh2 rKey ("cdab", rId, ACK mId2')
-
-      Resp "" _ end <- tGet1 rh1
-      (end, END) #== "unsubscribed the 1st TCP connection"
-
-      Resp "dabc" _ OK <- sendRecv sh ("", "dabc", sId, _SEND "test3")
-
-      Resp "" _ (Msg mId3 msg3) <- tGet1 rh2
-      (dec mId3 msg3, Right "test3") #== "delivered to the 2nd TCP connection"
-
-      Resp "abcd" _ err <- signSendRecv rh1 rKey ("abcd", rId, ACK mId3)
-      (err, ERR NO_MSG) #== "rejects ACK from the 1st TCP connection"
-
-      Resp "bcda" _ ok3 <- signSendRecv rh2 rKey ("bcda", rId, ACK mId3)
-      (ok3, OK) #== "accepts ACK from the 2nd TCP connection"
-
-      1000 `timeout` tGet @BrokerMsg rh1 >>= \case
-        Nothing -> return ()
-        Just _ -> error "nothing else is delivered to the 1st TCP connection"
-
-testGetCommand :: forall c. Transport c => TProxy c -> Spec
-testGetCommand t =
-  it "should retrieve messages from the queue using GET command" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    smpTest t $ \sh -> do
-      queue <- newEmptyTMVarIO
-      testSMPClient @c $ \rh ->
-        atomically . putTMVar queue =<< createAndSecureQueue rh sPub
-      testSMPClient @c $ \rh -> do
-        (sId, rId, rKey, dhShared) <- atomically $ takeTMVar queue
-        let dec = decryptMsgV3 dhShared
-        Resp "1" _ OK <- signSendRecv sh sKey ("1", sId, _SEND "hello")
-        Resp "2" _ (Msg mId1 msg1) <- signSendRecv rh rKey ("2", rId, GET)
-        (dec mId1 msg1, Right "hello") #== "retrieved from queue"
-        Resp "3" _ OK <- signSendRecv rh rKey ("3", rId, ACK mId1)
-        Resp "4" _ OK <- signSendRecv rh rKey ("4", rId, GET)
-        pure ()
-
-testGetSubCommands :: forall c. Transport c => TProxy c -> Spec
-testGetSubCommands t =
-  it "should retrieve messages with GET and receive with SUB, only one ACK would work" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    smpTest3 t $ \rh1 rh2 sh -> do
-      (sId, rId, rKey, dhShared) <- createAndSecureQueue rh1 sPub
-      let dec = decryptMsgV3 dhShared
-      Resp "1" _ OK <- signSendRecv sh sKey ("1", sId, _SEND "hello 1")
-      Resp "1a" _ OK <- signSendRecv sh sKey ("1a", sId, _SEND "hello 2")
-      Resp "1b" _ OK <- signSendRecv sh sKey ("1b", sId, _SEND "hello 3")
-      Resp "1c" _ OK <- signSendRecv sh sKey ("1c", sId, _SEND "hello 4")
-      -- both get the same if not ACK'd
-      Resp "" _ (Msg mId1 msg1) <- tGet1 rh1
-      Resp "2" _ (Msg mId1' msg1') <- signSendRecv rh2 rKey ("2", rId, GET)
-      (dec mId1 msg1, Right "hello 1") #== "received from queue via SUB"
-      (dec mId1' msg1', Right "hello 1") #== "retrieved from queue with GET"
-      mId1 `shouldBe` mId1'
-      msg1 `shouldBe` msg1'
-      -- subscriber cannot GET, getter cannot SUB
-      Resp "3" _ (ERR (CMD PROHIBITED)) <- signSendRecv rh1 rKey ("3", rId, GET)
-      Resp "3a" _ (ERR (CMD PROHIBITED)) <- signSendRecv rh2 rKey ("3a", rId, SUB)
-      -- ACK for SUB delivers the next message
-      Resp "4" _ (Msg mId2 msg2) <- signSendRecv rh1 rKey ("4", rId, ACK mId1)
-      (dec mId2 msg2, Right "hello 2") #== "received from queue via SUB"
-      -- bad msgId returns error
-      Resp "5" _ (ERR NO_MSG) <- signSendRecv rh2 rKey ("5", rId, ACK "1234")
-      -- already ACK'd by subscriber, but still returns OK when msgId matches
-      Resp "5a" _ OK <- signSendRecv rh2 rKey ("5a", rId, ACK mId1)
-      -- msg2 is not lost - even if subscriber does not ACK it, it is delivered to getter
-      Resp "6" _ (Msg mId2' msg2') <- signSendRecv rh2 rKey ("6", rId, GET)
-      (dec mId2' msg2', Right "hello 2") #== "retrieved from queue with GET"
-      mId2 `shouldBe` mId2'
-      msg2 `shouldBe` msg2'
-      -- getter ACK returns OK, even though there is the next message
-      Resp "7" _ OK <- signSendRecv rh2 rKey ("7", rId, ACK mId2')
-      Resp "8" _ (Msg mId3 msg3) <- signSendRecv rh2 rKey ("8", rId, GET)
-      (dec mId3 msg3, Right "hello 3") #== "retrieved from queue with GET"
-      -- subscriber ACK does not lose message
-      Resp "9" _ (Msg mId3' msg3') <- signSendRecv rh1 rKey ("9", rId, ACK mId2')
-      (dec mId3' msg3', Right "hello 3") #== "retrieved from queue with GET"
-      mId3 `shouldBe` mId3'
-      msg3 `shouldBe` msg3'
-      Resp "10" _ (Msg mId4 msg4) <- signSendRecv rh1 rKey ("10", rId, ACK mId3)
-      (dec mId4 msg4, Right "hello 4") #== "retrieved from queue with GET"
-      Resp "11" _ OK <- signSendRecv rh1 rKey ("11", rId, ACK mId4)
-      -- no more messages for getter too
-      Resp "12" _ OK <- signSendRecv rh2 rKey ("12", rId, GET)
-      pure ()
-
-testWithStoreLog :: ATransport -> Spec
-testWithStoreLog at@(ATransport t) =
-  it "should store simplex queues to log and restore them after server restart" $ do
-    (sPub1, sKey1) <- C.generateSignatureKeyPair C.SEd25519
-    (sPub2, sKey2) <- C.generateSignatureKeyPair C.SEd25519
-    (nPub, nKey) <- C.generateSignatureKeyPair C.SEd25519
-    recipientId1 <- newTVarIO ""
-    recipientKey1 <- newTVarIO Nothing
-    dhShared1 <- newTVarIO Nothing
-    senderId1 <- newTVarIO ""
-    senderId2 <- newTVarIO ""
-    notifierId <- newTVarIO ""
-
-    withSmpServerStoreLogOn at testPort . runTest t $ \h -> runClient t $ \h1 -> do
-      (sId1, rId1, rKey1, dhShared) <- createAndSecureQueue h sPub1
-      (rcvNtfPubDhKey, _) <- C.generateKeyPair'
-      Resp "abcd" _ (NID nId _) <- signSendRecv h rKey1 ("abcd", rId1, NKEY nPub rcvNtfPubDhKey)
-      atomically $ do
-        writeTVar recipientId1 rId1
-        writeTVar recipientKey1 $ Just rKey1
-        writeTVar dhShared1 $ Just dhShared
-        writeTVar senderId1 sId1
-        writeTVar notifierId nId
-      Resp "dabc" _ OK <- signSendRecv h1 nKey ("dabc", nId, NSUB)
-      Resp "bcda" _ OK <- signSendRecv h sKey1 ("bcda", sId1, _SEND' "hello")
-      Resp "" _ (Msg mId1 msg1) <- tGet1 h
-      (decryptMsgV3 dhShared mId1 msg1, Right "hello") #== "delivered from queue 1"
-      Resp "" _ (NMSG _ _) <- tGet1 h1
-
-      (sId2, rId2, rKey2, dhShared2) <- createAndSecureQueue h sPub2
-      atomically $ writeTVar senderId2 sId2
-      Resp "cdab" _ OK <- signSendRecv h sKey2 ("cdab", sId2, _SEND "hello too")
-      Resp "" _ (Msg mId2 msg2) <- tGet1 h
-      (decryptMsgV3 dhShared2 mId2 msg2, Right "hello too") #== "delivered from queue 2"
-
-      Resp "dabc" _ OK <- signSendRecv h rKey2 ("dabc", rId2, DEL)
-      pure ()
-
-    logSize testStoreLogFile `shouldReturn` 6
-
-    withSmpServerThreadOn at testPort . runTest t $ \h -> do
-      sId1 <- readTVarIO senderId1
-      -- fails if store log is disabled
-      Resp "bcda" _ (ERR AUTH) <- signSendRecv h sKey1 ("bcda", sId1, _SEND "hello")
-      pure ()
-
-    withSmpServerStoreLogOn at testPort . runTest t $ \h -> runClient t $ \h1 -> do
-      -- this queue is restored
-      rId1 <- readTVarIO recipientId1
-      Just rKey1 <- readTVarIO recipientKey1
-      Just dh1 <- readTVarIO dhShared1
-      sId1 <- readTVarIO senderId1
-      nId <- readTVarIO notifierId
-      Resp "dabc" _ OK <- signSendRecv h1 nKey ("dabc", nId, NSUB)
-      Resp "bcda" _ OK <- signSendRecv h sKey1 ("bcda", sId1, _SEND' "hello")
-      Resp "cdab" _ (Msg mId3 msg3) <- signSendRecv h rKey1 ("cdab", rId1, SUB)
-      (decryptMsgV3 dh1 mId3 msg3, Right "hello") #== "delivered from restored queue"
-      Resp "" _ (NMSG _ _) <- tGet1 h1
-      -- this queue is removed - not restored
-      sId2 <- readTVarIO senderId2
-      Resp "cdab" _ (ERR AUTH) <- signSendRecv h sKey2 ("cdab", sId2, _SEND "hello too")
-      pure ()
-
-    logSize testStoreLogFile `shouldReturn` 1
-    removeFile testStoreLogFile
-  where
-    runTest :: Transport c => TProxy c -> (THandle c -> IO ()) -> ThreadId -> Expectation
-    runTest _ test' server = do
-      testSMPClient test' `shouldReturn` ()
-      killThread server
-
-    runClient :: Transport c => TProxy c -> (THandle c -> IO ()) -> Expectation
-    runClient _ test' = testSMPClient test' `shouldReturn` ()
-
-logSize :: FilePath -> IO Int
-logSize f =
-  try (length . B.lines <$> B.readFile f) >>= \case
-    Right l -> pure l
-    Left (_ :: SomeException) -> logSize f
-
-testRestoreMessages :: ATransport -> Spec
-testRestoreMessages at@(ATransport t) =
-  it "should store messages on exit and restore on start" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    recipientId <- newTVarIO ""
-    recipientKey <- newTVarIO Nothing
-    dhShared <- newTVarIO Nothing
-    senderId <- newTVarIO ""
-
-    withSmpServerStoreMsgLogOn at testPort . runTest t $ \h -> do
-      runClient t $ \h1 -> do
-        (sId, rId, rKey, dh) <- createAndSecureQueue h1 sPub
-        atomically $ do
-          writeTVar recipientId rId
-          writeTVar recipientKey $ Just rKey
-          writeTVar dhShared $ Just dh
-          writeTVar senderId sId
-        Resp "1" _ OK <- signSendRecv h sKey ("1", sId, _SEND "hello")
-        Resp "" _ (Msg mId1 msg1) <- tGet1 h1
-        Resp "1a" _ OK <- signSendRecv h1 rKey ("1a", rId, ACK mId1)
-        (decryptMsgV3 dh mId1 msg1, Right "hello") #== "message delivered"
-      -- messages below are delivered after server restart
-      sId <- readTVarIO senderId
-      Resp "2" _ OK <- signSendRecv h sKey ("2", sId, _SEND "hello 2")
-      Resp "3" _ OK <- signSendRecv h sKey ("3", sId, _SEND "hello 3")
-      Resp "4" _ OK <- signSendRecv h sKey ("4", sId, _SEND "hello 4")
-      pure ()
-
-    logSize testStoreLogFile `shouldReturn` 2
-    logSize testStoreMsgsFile `shouldReturn` 3
-
-    withSmpServerStoreMsgLogOn at testPort . runTest t $ \h -> do
-      rId <- readTVarIO recipientId
-      Just rKey <- readTVarIO recipientKey
-      Just dh <- readTVarIO dhShared
-      let dec = decryptMsgV3 dh
-      Resp "2" _ (Msg mId2 msg2) <- signSendRecv h rKey ("2", rId, SUB)
-      (dec mId2 msg2, Right "hello 2") #== "restored message delivered"
-      Resp "3" _ (Msg mId3 msg3) <- signSendRecv h rKey ("3", rId, ACK mId2)
-      (dec mId3 msg3, Right "hello 3") #== "restored message delivered"
-      Resp "4" _ (Msg mId4 msg4) <- signSendRecv h rKey ("4", rId, ACK mId3)
-      (dec mId4 msg4, Right "hello 4") #== "restored message delivered"
-
-    logSize testStoreLogFile `shouldReturn` 1
-    -- the last message is not removed because it was not ACK'd
-    logSize testStoreMsgsFile `shouldReturn` 1
-
-    withSmpServerStoreMsgLogOn at testPort . runTest t $ \h -> do
-      rId <- readTVarIO recipientId
-      Just rKey <- readTVarIO recipientKey
-      Just dh <- readTVarIO dhShared
-      Resp "4" _ (Msg mId4 msg4) <- signSendRecv h rKey ("4", rId, SUB)
-      Resp "5" _ OK <- signSendRecv h rKey ("5", rId, ACK mId4)
-      (decryptMsgV3 dh mId4 msg4, Right "hello 4") #== "restored message delivered"
-
-    logSize testStoreLogFile `shouldReturn` 1
-    logSize testStoreMsgsFile `shouldReturn` 0
-
-    removeFile testStoreLogFile
-    removeFile testStoreMsgsFile
-  where
-    runTest :: Transport c => TProxy c -> (THandle c -> IO ()) -> ThreadId -> Expectation
-    runTest _ test' server = do
-      testSMPClient test' `shouldReturn` ()
-      killThread server
-
-    runClient :: Transport c => TProxy c -> (THandle c -> IO ()) -> Expectation
-    runClient _ test' = testSMPClient test' `shouldReturn` ()
-
-testRestoreMessagesV2 :: ATransport -> Spec
-testRestoreMessagesV2 at@(ATransport t) =
-  it "should store messages on exit and restore on start" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    recipientId <- newTVarIO ""
-    recipientKey <- newTVarIO Nothing
-    dhShared <- newTVarIO Nothing
-    senderId <- newTVarIO ""
-
-    withSmpServerStoreMsgLogOnV2 at testPort . runTest t $ \h -> do
-      runClient t $ \h1 -> do
-        (sId, rId, rKey, dh) <- createAndSecureQueue h1 sPub
-        atomically $ do
-          writeTVar recipientId rId
-          writeTVar recipientKey $ Just rKey
-          writeTVar dhShared $ Just dh
-          writeTVar senderId sId
-        Resp "1" _ OK <- signSendRecv h sKey ("1", sId, _SEND "hello")
-        Resp "" _ (Msg mId1 msg1) <- tGet1 h1
-        Resp "1a" _ OK <- signSendRecv h1 rKey ("1a", rId, ACK mId1)
-        (decryptMsgV2 dh mId1 msg1, Right "hello") #== "message delivered"
-      -- messages below are delivered after server restart
-      sId <- readTVarIO senderId
-      Resp "2" _ OK <- signSendRecv h sKey ("2", sId, _SEND "hello 2")
-      Resp "3" _ OK <- signSendRecv h sKey ("3", sId, _SEND "hello 3")
-      Resp "4" _ OK <- signSendRecv h sKey ("4", sId, _SEND "hello 4")
-      pure ()
-
-    logSize testStoreLogFile `shouldReturn` 2
-    logSize testStoreMsgsFile `shouldReturn` 3
-
-    withSmpServerStoreMsgLogOnV2 at testPort . runTest t $ \h -> do
-      rId <- readTVarIO recipientId
-      Just rKey <- readTVarIO recipientKey
-      Just dh <- readTVarIO dhShared
-      let dec = decryptMsgV2 dh
-      Resp "2" _ (Msg mId2 msg2) <- signSendRecv h rKey ("2", rId, SUB)
-      (dec mId2 msg2, Right "hello 2") #== "restored message delivered"
-      Resp "3" _ (Msg mId3 msg3) <- signSendRecv h rKey ("3", rId, ACK mId2)
-      (dec mId3 msg3, Right "hello 3") #== "restored message delivered"
-      Resp "4" _ (Msg mId4 msg4) <- signSendRecv h rKey ("4", rId, ACK mId3)
-      (dec mId4 msg4, Right "hello 4") #== "restored message delivered"
-
-    logSize testStoreLogFile `shouldReturn` 1
-    -- the last message is not removed because it was not ACK'd
-    logSize testStoreMsgsFile `shouldReturn` 1
-
-    withSmpServerStoreMsgLogOnV2 at testPort . runTest t $ \h -> do
-      rId <- readTVarIO recipientId
-      Just rKey <- readTVarIO recipientKey
-      Just dh <- readTVarIO dhShared
-      Resp "4" _ (Msg mId4 msg4) <- signSendRecv h rKey ("4", rId, SUB)
-      Resp "5" _ OK <- signSendRecv h rKey ("5", rId, ACK mId4)
-      (decryptMsgV2 dh mId4 msg4, Right "hello 4") #== "restored message delivered"
-
-    logSize testStoreLogFile `shouldReturn` 1
-    logSize testStoreMsgsFile `shouldReturn` 0
-
-    removeFile testStoreLogFile
-    removeFile testStoreMsgsFile
-  where
-    runTest :: Transport c => TProxy c -> (THandle c -> IO ()) -> ThreadId -> Expectation
-    runTest _ test' server = do
-      testSMPClient test' `shouldReturn` ()
-      killThread server
-
-    runClient :: Transport c => TProxy c -> (THandle c -> IO ()) -> Expectation
-    runClient _ test' = testSMPClient test' `shouldReturn` ()
-
-createAndSecureQueue :: Transport c => THandle c -> SndPublicVerifyKey -> IO (SenderId, RecipientId, RcvPrivateSignKey, RcvDhSecret)
-createAndSecureQueue h sPub = do
-  (rPub, rKey) <- C.generateSignatureKeyPair C.SEd448
-  (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-  Resp "abcd" "" (Ids rId sId srvDh) <- signSendRecv h rKey ("abcd", "", NEW rPub dhPub Nothing)
-  let dhShared = C.dh' srvDh dhPriv
-  Resp "dabc" rId' OK <- signSendRecv h rKey ("dabc", rId, KEY sPub)
-  (rId', rId) #== "same queue ID"
-  pure (sId, rId, rKey, dhShared)
-
-testTiming :: ATransport -> Spec
-testTiming (ATransport t) =
-  it "should have similar time for auth error, whether queue exists or not, for all key sizes" $
-    smpTest2 t $ \rh sh ->
-      mapM_ (testSameTiming rh sh) timingTests
-  where
-    timingTests :: [(Int, Int, Int)]
-    timingTests =
-      [ (32, 32, 200),
-        (32, 57, 100),
-        (57, 32, 200),
-        (57, 57, 100)
-      ]
-    timeRepeat n = fmap fst . timeItT . forM_ (replicate n ()) . const
-    similarTime t1 t2 = abs (t2 / t1 - 1) < 0.25 `shouldBe` True
-    testSameTiming :: Transport c => THandle c -> THandle c -> (Int, Int, Int) -> Expectation
-    testSameTiming rh sh (goodKeySize, badKeySize, n) = do
-      (rPub, rKey) <- generateKeys goodKeySize
-      (dhPub, dhPriv :: C.PrivateKeyX25519) <- C.generateKeyPair'
-      Resp "abcd" "" (Ids rId sId srvDh) <- signSendRecv rh rKey ("abcd", "", NEW rPub dhPub Nothing)
-      let dec = decryptMsgV3 $ C.dh' srvDh dhPriv
-      Resp "cdab" _ OK <- signSendRecv rh rKey ("cdab", rId, SUB)
-
-      (_, badKey) <- generateKeys badKeySize
-      -- runTimingTest rh badKey rId "SUB"
-
-      (sPub, sKey) <- generateKeys goodKeySize
-      Resp "dabc" _ OK <- signSendRecv rh rKey ("dabc", rId, KEY sPub)
-
-      Resp "bcda" _ OK <- signSendRecv sh sKey ("bcda", sId, _SEND "hello")
-      Resp "" _ (Msg mId msg) <- tGet1 rh
-      (dec mId msg, Right "hello") #== "delivered from queue"
-
-      runTimingTest sh badKey sId $ _SEND "hello"
-      where
-        generateKeys = \case
-          32 -> C.generateSignatureKeyPair C.SEd25519
-          57 -> C.generateSignatureKeyPair C.SEd448
-          _ -> error "unsupported key size"
-        runTimingTest h badKey qId cmd = do
-          timeWrongKey <- timeRepeat n $ do
-            Resp "cdab" _ (ERR AUTH) <- signSendRecv h badKey ("cdab", qId, cmd)
-            return ()
-          timeNoQueue <- timeRepeat n $ do
-            Resp "dabc" _ (ERR AUTH) <- signSendRecv h badKey ("dabc", "1234", cmd)
-            return ()
-          -- (putStrLn . unwords . map show)
-          --   [ fromIntegral goodKeySize,
-          --     fromIntegral badKeySize,
-          --     timeWrongKey,
-          --     timeNoQueue,
-          --     timeWrongKey / timeNoQueue - 1
-          --   ]
-          similarTime timeNoQueue timeWrongKey
-
-testMessageNotifications :: ATransport -> Spec
-testMessageNotifications (ATransport t) =
-  it "should create simplex connection, subscribe notifier and deliver notifications" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    (nPub, nKey) <- C.generateSignatureKeyPair C.SEd25519
-    smpTest4 t $ \rh sh nh1 nh2 -> do
-      (sId, rId, rKey, dhShared) <- createAndSecureQueue rh sPub
-      let dec = decryptMsgV3 dhShared
-      (rcvNtfPubDhKey, _) <- C.generateKeyPair'
-      Resp "1" _ (NID nId' _) <- signSendRecv rh rKey ("1", rId, NKEY nPub rcvNtfPubDhKey)
-      Resp "1a" _ (NID nId _) <- signSendRecv rh rKey ("1a", rId, NKEY nPub rcvNtfPubDhKey)
-      nId' `shouldNotBe` nId
-      Resp "2" _ OK <- signSendRecv nh1 nKey ("2", nId, NSUB)
-      Resp "3" _ OK <- signSendRecv sh sKey ("3", sId, _SEND' "hello")
-      Resp "" _ (Msg mId1 msg1) <- tGet1 rh
-      (dec mId1 msg1, Right "hello") #== "delivered from queue"
-      Resp "3a" _ OK <- signSendRecv rh rKey ("3a", rId, ACK mId1)
-      Resp "" _ (NMSG _ _) <- tGet1 nh1
-      Resp "4" _ OK <- signSendRecv nh2 nKey ("4", nId, NSUB)
-      Resp "" _ END <- tGet1 nh1
-      Resp "5" _ OK <- signSendRecv sh sKey ("5", sId, _SEND' "hello again")
-      Resp "" _ (Msg mId2 msg2) <- tGet1 rh
-      Resp "5a" _ OK <- signSendRecv rh rKey ("5a", rId, ACK mId2)
-      (dec mId2 msg2, Right "hello again") #== "delivered from queue again"
-      Resp "" _ (NMSG _ _) <- tGet1 nh2
-      1000 `timeout` tGet @BrokerMsg nh1 >>= \case
-        Nothing -> pure ()
-        Just _ -> error "nothing else should be delivered to the 1st notifier's TCP connection"
-      Resp "6" _ OK <- signSendRecv rh rKey ("6", rId, NDEL)
-      Resp "7" _ OK <- signSendRecv sh sKey ("7", sId, _SEND' "hello there")
-      Resp "" _ (Msg mId3 msg3) <- tGet1 rh
-      (dec mId3 msg3, Right "hello there") #== "delivered from queue again"
-      1000 `timeout` tGet @BrokerMsg nh2 >>= \case
-        Nothing -> pure ()
-        Just _ -> error "nothing else should be delivered to the 2nd notifier's TCP connection"
-
-testMsgExpireOnSend :: forall c. Transport c => TProxy c -> Spec
-testMsgExpireOnSend t =
-  it "should expire messages that are not received before messageTTL on SEND" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    let cfg' = cfg {messageExpiration = Just ExpirationConfig {ttl = 1, checkInterval = 10000}}
-    withSmpServerConfigOn (ATransport t) cfg' testPort $ \_ ->
-      testSMPClient @c $ \sh -> do
-        (sId, rId, rKey, dhShared) <- testSMPClient @c $ \rh -> createAndSecureQueue rh sPub
-        let dec = decryptMsgV3 dhShared
-        Resp "1" _ OK <- signSendRecv sh sKey ("1", sId, _SEND "hello (should expire)")
-        threadDelay 2500000
-        Resp "2" _ OK <- signSendRecv sh sKey ("2", sId, _SEND "hello (should NOT expire)")
-        testSMPClient @c $ \rh -> do
-          Resp "3" _ (Msg mId msg) <- signSendRecv rh rKey ("3", rId, SUB)
-          (dec mId msg, Right "hello (should NOT expire)") #== "delivered"
-          1000 `timeout` tGet @BrokerMsg rh >>= \case
-            Nothing -> return ()
-            Just _ -> error "nothing else should be delivered"
-
-testMsgExpireOnInterval :: forall c. Transport c => TProxy c -> Spec
-testMsgExpireOnInterval t =
-  it "should expire messages that are not received before messageTTL after expiry interval" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    let cfg' = cfg {messageExpiration = Just ExpirationConfig {ttl = 1, checkInterval = 1}}
-    withSmpServerConfigOn (ATransport t) cfg' testPort $ \_ ->
-      testSMPClient @c $ \sh -> do
-        (sId, rId, rKey, _) <- testSMPClient @c $ \rh -> createAndSecureQueue rh sPub
-        Resp "1" _ OK <- signSendRecv sh sKey ("1", sId, _SEND "hello (should expire)")
-        threadDelay 2500000
-        testSMPClient @c $ \rh -> do
-          Resp "2" _ OK <- signSendRecv rh rKey ("2", rId, SUB)
-          1000 `timeout` tGet @BrokerMsg rh >>= \case
-            Nothing -> return ()
-            Just _ -> error "nothing should be delivered"
-
-testMsgNOTExpireOnInterval :: forall c. Transport c => TProxy c -> Spec
-testMsgNOTExpireOnInterval t =
-  it "should NOT expire messages that are not received before messageTTL if expiry interval is large" $ do
-    (sPub, sKey) <- C.generateSignatureKeyPair C.SEd25519
-    let cfg' = cfg {messageExpiration = Just ExpirationConfig {ttl = 1, checkInterval = 10000}}
-    withSmpServerConfigOn (ATransport t) cfg' testPort $ \_ ->
-      testSMPClient @c $ \sh -> do
-        (sId, rId, rKey, dhShared) <- testSMPClient @c $ \rh -> createAndSecureQueue rh sPub
-        let dec = decryptMsgV3 dhShared
-        Resp "1" _ OK <- signSendRecv sh sKey ("1", sId, _SEND "hello (should NOT expire)")
-        threadDelay 2500000
-        testSMPClient @c $ \rh -> do
-          Resp "2" _ (Msg mId msg) <- signSendRecv rh rKey ("2", rId, SUB)
-          (dec mId msg, Right "hello (should NOT expire)") #== "delivered"
-          1000 `timeout` tGet @BrokerMsg rh >>= \case
-            Nothing -> return ()
-            Just _ -> error "nothing else should be delivered"
-
-samplePubKey :: C.APublicVerifyKey
-samplePubKey = C.APublicVerifyKey C.SEd25519 "MCowBQYDK2VwAyEAfAOflyvbJv1fszgzkQ6buiZJVgSpQWsucXq7U6zjMgY="
-
-sampleDhPubKey :: C.PublicKey 'C.X25519
-sampleDhPubKey = "MCowBQYDK2VuAyEAriy+HcARIhqsgSjVnjKqoft+y6pxrxdY68zn4+LjYhQ="
-
-sampleSig :: Maybe C.ASignature
-sampleSig = "e8JK+8V3fq6kOLqco/SaKlpNaQ7i1gfOrXoqekEl42u4mF8Bgu14T5j0189CGcUhJHw2RwCMvON+qbvQ9ecJAA=="
-
-syntaxTests :: ATransport -> Spec
-syntaxTests (ATransport t) = do
-  it "unknown command" $ ("", "abcd", "1234", ('H', 'E', 'L', 'L', 'O')) >#> ("", "abcd", "1234", ERR $ CMD UNKNOWN)
-  describe "NEW" $ do
-    it "no parameters" $ (sampleSig, "bcda", "", NEW_) >#> ("", "bcda", "", ERR $ CMD SYNTAX)
-    it "many parameters" $ (sampleSig, "cdab", "", (NEW_, ' ', ('\x01', 'A'), samplePubKey, sampleDhPubKey)) >#> ("", "cdab", "", ERR $ CMD SYNTAX)
-    it "no signature" $ ("", "dabc", "", (NEW_, ' ', samplePubKey, sampleDhPubKey)) >#> ("", "dabc", "", ERR $ CMD NO_AUTH)
-    it "queue ID" $ (sampleSig, "abcd", "12345678", (NEW_, ' ', samplePubKey, sampleDhPubKey)) >#> ("", "abcd", "12345678", ERR $ CMD HAS_AUTH)
-  describe "KEY" $ do
-    it "valid syntax" $ (sampleSig, "bcda", "12345678", (KEY_, ' ', samplePubKey)) >#> ("", "bcda", "12345678", ERR AUTH)
-    it "no parameters" $ (sampleSig, "cdab", "12345678", KEY_) >#> ("", "cdab", "12345678", ERR $ CMD SYNTAX)
-    it "many parameters" $ (sampleSig, "dabc", "12345678", (KEY_, ' ', ('\x01', 'A'), samplePubKey)) >#> ("", "dabc", "12345678", ERR $ CMD SYNTAX)
-    it "no signature" $ ("", "abcd", "12345678", (KEY_, ' ', samplePubKey)) >#> ("", "abcd", "12345678", ERR $ CMD NO_AUTH)
-    it "no queue ID" $ (sampleSig, "bcda", "", (KEY_, ' ', samplePubKey)) >#> ("", "bcda", "", ERR $ CMD NO_AUTH)
-  noParamsSyntaxTest "SUB" SUB_
-  noParamsSyntaxTest "OFF" OFF_
-  noParamsSyntaxTest "DEL" DEL_
-  describe "SEND" $ do
-    it "valid syntax" $ (sampleSig, "cdab", "12345678", (SEND_, ' ', noMsgFlags, ' ', "hello" :: ByteString)) >#> ("", "cdab", "12345678", ERR AUTH)
-    it "no parameters" $ (sampleSig, "abcd", "12345678", SEND_) >#> ("", "abcd", "12345678", ERR $ CMD SYNTAX)
-    it "no queue ID" $ (sampleSig, "bcda", "", (SEND_, ' ', noMsgFlags, ' ', "hello" :: ByteString)) >#> ("", "bcda", "", ERR $ CMD NO_ENTITY)
-  describe "ACK" $ do
-    it "valid syntax" $ (sampleSig, "cdab", "12345678", (ACK_, ' ', "1234" :: ByteString)) >#> ("", "cdab", "12345678", ERR AUTH)
-    it "no parameters" $ (sampleSig, "abcd", "12345678", ACK_) >#> ("", "abcd", "12345678", ERR $ CMD SYNTAX)
-    it "no queue ID" $ (sampleSig, "bcda", "", (ACK_, ' ', "1234" :: ByteString)) >#> ("", "bcda", "", ERR $ CMD NO_AUTH)
-    it "no signature" $ ("", "cdab", "12345678", (ACK_, ' ', "1234" :: ByteString)) >#> ("", "cdab", "12345678", ERR $ CMD NO_AUTH)
-  describe "PING" $ do
-    it "valid syntax" $ ("", "abcd", "", PING_) >#> ("", "abcd", "", PONG)
-  describe "broker response not allowed" $ do
-    it "OK" $ (sampleSig, "bcda", "12345678", OK_) >#> ("", "bcda", "12345678", ERR $ CMD UNKNOWN)
-  where
-    noParamsSyntaxTest :: PartyI p => String -> CommandTag p -> Spec
-    noParamsSyntaxTest description cmd = describe description $ do
-      it "valid syntax" $ (sampleSig, "abcd", "12345678", cmd) >#> ("", "abcd", "12345678", ERR AUTH)
-      it "wrong terminator" $ (sampleSig, "bcda", "12345678", (cmd, '=')) >#> ("", "bcda", "12345678", ERR $ CMD UNKNOWN)
-      it "no signature" $ ("", "cdab", "12345678", cmd) >#> ("", "cdab", "12345678", ERR $ CMD NO_AUTH)
-      it "no queue ID" $ (sampleSig, "dabc", "", cmd) >#> ("", "dabc", "", ERR $ CMD NO_AUTH)
-    (>#>) ::
-      Encoding smp =>
-      (Maybe C.ASignature, ByteString, ByteString, smp) ->
-      (Maybe C.ASignature, ByteString, ByteString, BrokerMsg) ->
-      Expectation
-    command >#> response = smpServerTest t command `shouldReturn` response
diff --git a/source/tests/Test.hs b/source/tests/Test.hs
deleted file mode 100644
index fbf8a4a..0000000
--- a/source/tests/Test.hs
+++ /dev/null
@@ -1,39 +0,0 @@
-{-# LANGUAGE TypeApplications #-}
-
-import AgentTests (agentTests)
--- import Control.Logger.Simple
-import CLITests
-import CoreTests.CryptoTests
-import CoreTests.EncodingTests
-import CoreTests.ProtocolErrorTests
-import CoreTests.VersionRangeTests
-import NtfServerTests (ntfServerTests)
-import ServerTests
-import Simplex.Messaging.Transport (TLS, Transport (..))
-import Simplex.Messaging.Transport.WebSockets (WS)
-import System.Directory (createDirectoryIfMissing, removeDirectoryRecursive)
-import System.Environment (setEnv)
-import Test.Hspec
-
--- logCfg :: LogConfig
--- logCfg = LogConfig {lc_file = Nothing, lc_stderr = True}
-
-main :: IO ()
-main = do
-  -- setLogLevel LogInfo -- LogError
-  -- withGlobalLogging logCfg $ do
-  createDirectoryIfMissing False "tests/tmp"
-  setEnv "APNS_KEY_ID" "H82WD9K9AQ"
-  setEnv "APNS_KEY_FILE" "./tests/fixtures/AuthKey_H82WD9K9AQ.p8"
-  hspec $ do
-    describe "Core tests" $ do
-      describe "Encoding tests" encodingTests
-      describe "Protocol error tests" protocolErrorTests
-      describe "Version range" versionRangeTests
-      describe "Encryption tests" cryptoTests
-    describe "SMP server via TLS" $ serverTests (transport @TLS)
-    describe "SMP server via WebSockets" $ serverTests (transport @WS)
-    describe "Notifications server" $ ntfServerTests (transport @TLS)
-    describe "SMP client agent" $ agentTests (transport @TLS)
-    describe "Server CLIs" cliTests
-  removeDirectoryRecursive "tests/tmp"
diff --git a/source/tests/fixtures/.gitignore b/source/tests/fixtures/.gitignore
deleted file mode 100644
index e988acd..0000000
--- a/source/tests/fixtures/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-server.csr
diff --git a/source/tests/fixtures/AuthKey_H82WD9K9AQ.p8 b/source/tests/fixtures/AuthKey_H82WD9K9AQ.p8
deleted file mode 100644
index d6531ce..0000000
--- a/source/tests/fixtures/AuthKey_H82WD9K9AQ.p8
+++ /dev/null
@@ -1,6 +0,0 @@
------BEGIN PRIVATE KEY-----
-MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgWuPap5jF6eioxuHM
-XWZWUK78LdcxkTnMXWg2GqyXuBugCgYIKoZIzj0DAQehRANCAAQn64CvAIbEEzvM
-KwYjlOxVD5SxlgP1ZcYvVM/+VHLFu0aCkG7ueICTi3qWyqoB5hjjuAqwtc3EK0q0
-yupyM7Yx
------END PRIVATE KEY-----
\ No newline at end of file
diff --git a/source/tests/fixtures/README.md b/source/tests/fixtures/README.md
deleted file mode 100644
index 82cadc6..0000000
--- a/source/tests/fixtures/README.md
+++ /dev/null
@@ -1,28 +0,0 @@
-To generate fixtures:
-
-(keep these instructions and *openssl_ca.conf* and *openssl_server.conf* files consistent with certificate generation on server)
-
-```sh
-# CA certificate (identity/offline)
-openssl genpkey -algorithm ED448 -out ca.key
-openssl req -new -x509 -days 999999 -config openssl_ca.conf -extensions v3 -key ca.key -out ca.crt
-
-# Server certificate (online)
-openssl genpkey -algorithm ED448 -out server.key
-openssl req -new -config openssl_server.conf -reqexts v3 -key server.key -out server.csr
-openssl x509 -req -days 999999 -extfile openssl_server.conf -extensions v3 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt
-
-# To pretty-print
-openssl x509 -in ca.crt -text -noout
-openssl req -in server.csr -text -noout
-openssl x509 -in server.crt -text -noout
-```
-
-To compute fingerprint for tests:
-
-```haskell
-stack ghci
-> import Data.X509.Validation (Fingerprint (..))
-> Fingerprint fp <- loadFingerprint "tests/fixtures/ca.crt"
-> strEncode fp
-```
diff --git a/source/tests/fixtures/ca.crt b/source/tests/fixtures/ca.crt
deleted file mode 100644
index e990252..0000000
--- a/source/tests/fixtures/ca.crt
+++ /dev/null
@@ -1,12 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIBtjCCATagAwIBAgIUe2PryrWo0xXX9vcA3WfbCzcdmgAwBQYDK2VxMCoxFjAU
-BgNVBAMMDVNNUCBzZXJ2ZXIgQ0ExEDAOBgNVBAoMB1NpbXBsZVgwIBcNMjIwMTEx
-MTExNjM5WhgPNDc1OTEyMDgxMTE2MzlaMCoxFjAUBgNVBAMMDVNNUCBzZXJ2ZXIg
-Q0ExEDAOBgNVBAoMB1NpbXBsZVgwQzAFBgMrZXEDOgCAcvFwVicR+RLZpiEWPFNR
-XYTbf+mFcX1NHIyPQDugFwOCgqJAW1fsjYgFhtQJSMH/lc1N7clfm4CjUzBRMB0G
-A1UdDgQWBBQcUJvR7mm26yxMQfCsWgbnwMmJVDAfBgNVHSMEGDAWgBQcUJvR7mm2
-6yxMQfCsWgbnwMmJVDAPBgNVHRMBAf8EBTADAQH/MAUGAytlcQNzAAAP/hMPNxyW
-fyJi+iJViodU+C/aklnvHtjh5P3AbiVCSUfY6+PEdvkC8Ov0pBAYpYi5ukSNNVXl
-ABVRlipB+vOcLQStNyaZ7kXzQ2IO/0btmIidh+G6SP8I4aytYIYYcV5pEUZpG1L1
-57g8P29SDv81AA==
------END CERTIFICATE-----
diff --git a/source/tests/fixtures/ca.key b/source/tests/fixtures/ca.key
deleted file mode 100644
index 33f2e1f..0000000
--- a/source/tests/fixtures/ca.key
+++ /dev/null
@@ -1,4 +0,0 @@
------BEGIN PRIVATE KEY-----
-MEcCAQAwBQYDK2VxBDsEOW6vCN7H7or3VsiMaNrFUoCf4LsuhYchWJKataA1mXhN
-VIYFo7xWZWBnczDf5hkWQLIHNHm7DDr6+A==
------END PRIVATE KEY-----
diff --git a/source/tests/fixtures/openssl_ca.conf b/source/tests/fixtures/openssl_ca.conf
deleted file mode 100644
index 6cebea6..0000000
--- a/source/tests/fixtures/openssl_ca.conf
+++ /dev/null
@@ -1,12 +0,0 @@
-[req]
-distinguished_name = req_distinguished_name
-prompt = no
-
-[req_distinguished_name]
-CN = SMP server CA
-O = SimpleX
-
-[v3]
-subjectKeyIdentifier = hash
-authorityKeyIdentifier = keyid:always
-basicConstraints = critical,CA:true
diff --git a/source/tests/fixtures/openssl_server.conf b/source/tests/fixtures/openssl_server.conf
deleted file mode 100644
index bbf6434..0000000
--- a/source/tests/fixtures/openssl_server.conf
+++ /dev/null
@@ -1,11 +0,0 @@
-[req]
-distinguished_name = req_distinguished_name
-prompt = no
-
-[req_distinguished_name]
-CN = localhost
-
-[v3]
-basicConstraints = CA:FALSE
-keyUsage = digitalSignature, nonRepudiation, keyAgreement
-extendedKeyUsage = serverAuth
diff --git a/source/tests/fixtures/server.crt b/source/tests/fixtures/server.crt
deleted file mode 100644
index 68234a1..0000000
--- a/source/tests/fixtures/server.crt
+++ /dev/null
@@ -1,12 +0,0 @@
------BEGIN CERTIFICATE-----
-MIIBvDCCATygAwIBAgIUUgqht3ibEJ9jp5JuroML5Baxa/IwBQYDK2VxMCoxFjAU
-BgNVBAMMDVNNUCBzZXJ2ZXIgQ0ExEDAOBgNVBAoMB1NpbXBsZVgwIBcNMjIwMTEx
-MTYzOTQ2WhgPNDc1OTEyMDgxNjM5NDZaMBQxEjAQBgNVBAMMCWxvY2FsaG9zdDBD
-MAUGAytlcQM6AFj+fmjmgOMBFgQ7lXfICSlSaB5sYp1wzhM2IaqgmVhWbDs3Tw7W
-oUXFJsWpKku1kFjLH2yhqIInAKNvMG0wCQYDVR0TBAIwADALBgNVHQ8EBAMCA8gw
-EwYDVR0lBAwwCgYIKwYBBQUHAwEwHQYDVR0OBBYEFMjbHbxESDI8YDPjJ8kXWjkg
-jHxmMB8GA1UdIwQYMBaAFBxQm9HuabbrLExB8KxaBufAyYlUMAUGAytlcQNzAP98
-RpFacmjxsc07GwC07uAxUxNgxX4R2nA+0St866uFbdyxApiyn44giG+m+YXCXLjh
-1ffKEhhqAPdlpzByLarx8EWgmOsisBCRWrmraksOV15FKxjPqm7OYKp4f9GvieAQ
-o/SKOyZVVdcZX7NcuDUxAA==
------END CERTIFICATE-----
diff --git a/source/tests/fixtures/server.key b/source/tests/fixtures/server.key
deleted file mode 100644
index 27e0b7c..0000000
--- a/source/tests/fixtures/server.key
+++ /dev/null
@@ -1,4 +0,0 @@
------BEGIN PRIVATE KEY-----
-MEcCAQAwBQYDK2VxBDsEOZcXSjKQ3FQ9EBfqHmFIidOu4LecpUgi5NVPMhx7mS2d
-QNQ0lFasp+EfvLErbs1Sd9xLVxA1hnZJng==
------END PRIVATE KEY-----
